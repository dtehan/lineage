---
phase: 07-environment-variable-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/db_config.py
  - lineage-api/python_server.py
autonomous: true

must_haves:
  truths:
    - "TERADATA_* variables work as primary for Python scripts"
    - "TD_* variables work as legacy fallback for Python scripts"
    - "TERADATA_PORT is supported in Python db_config"
    - "API_PORT controls Python server port with PORT as fallback"
    - "Existing .env files with TD_* still work (backwards compatible)"
  artifacts:
    - path: "database/db_config.py"
      provides: "Centralized database config with TERADATA_* primary, TD_* fallback"
      contains: "get_env.*TERADATA_HOST.*TD_HOST"
    - path: "lineage-api/python_server.py"
      provides: "Flask server with API_PORT support"
      contains: "API_PORT"
  key_links:
    - from: "database/db_config.py"
      to: "os.environ"
      via: "get_env helper function"
      pattern: "get_env.*TERADATA.*TD_"
    - from: "lineage-api/python_server.py"
      to: "API_PORT env var"
      via: "os.environ.get"
      pattern: "API_PORT.*PORT"
---

<objective>
Consolidate Python configuration to use TERADATA_* as primary variables with TD_* as legacy fallback, and support API_PORT for server port.

Purpose: Eliminate dual naming confusion in Python scripts while maintaining backwards compatibility for existing deployments.
Output: Updated db_config.py and python_server.py with unified environment variable handling.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-environment-variable-consolidation/07-RESEARCH.md

# Source files to modify
@database/db_config.py
@lineage-api/python_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modernize db_config.py with TERADATA_* primary pattern</name>
  <files>database/db_config.py</files>
  <action>
Refactor db_config.py to use TERADATA_* as primary variable names with TD_* as legacy fallback.

1. Create a `get_env(*names, required=False, default=None)` helper function that:
   - Takes variable names in priority order (TERADATA_* first, TD_* second)
   - Returns first non-empty value found
   - Exits with error code 1 if required=True and no value found
   - Returns default if not required and no value found

2. Update module docstring to document new variable naming:
   - Primary: TERADATA_HOST, TERADATA_USER, TERADATA_PASSWORD, TERADATA_DATABASE, TERADATA_PORT
   - Legacy (deprecated): TD_HOST, TD_USER, TD_PASSWORD, TD_DATABASE

3. Update get_config() function to use new pattern:
   - host: get_env("TERADATA_HOST", "TD_HOST", default="localhost")
   - user: get_env("TERADATA_USER", "TD_USER", default="demo_user")
   - password: get_env("TERADATA_PASSWORD", "TD_PASSWORD", required=True)
   - database: get_env("TERADATA_DATABASE", "TD_DATABASE", default="demo_user")
   - port: int(get_env("TERADATA_PORT", "TD_PORT", default="1025"))

4. Remove the REQUIRED_CREDENTIALS list and validate_required_credentials() function - replace with inline validation in get_env() when required=True.

5. Keep existing dotenv loading logic unchanged.

Pattern from research:
```python
def get_env(*names: str, required: bool = False, default: str = None) -> str:
    for name in names:
        value = os.environ.get(name, "").strip()
        if value:
            return value
    if required:
        print(f"ERROR: Missing required environment variable:", file=sys.stderr)
        print(f"  Set one of: {', '.join(names)}", file=sys.stderr)
        sys.exit(1)
    return default
```

DO NOT change the CONFIG dict structure - only the source of values.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "import db_config; print(db_config.CONFIG)"` - should print config dict without error.

Test with TERADATA_* vars: `TERADATA_HOST=test TERADATA_PASSWORD=pass python -c "import db_config; print(db_config.CONFIG['host'])"` - should print "test".

Test with TD_* vars: `TD_HOST=legacy TD_PASSWORD=pass python -c "import db_config; print(db_config.CONFIG['host'])"` - should print "legacy".

Test TERADATA_* takes precedence: `TERADATA_HOST=primary TD_HOST=secondary TERADATA_PASSWORD=pass python -c "import db_config; print(db_config.CONFIG['host'])"` - should print "primary".
  </verify>
  <done>
- db_config.py uses TERADATA_* as primary variable names
- TD_* works as fallback when TERADATA_* not set
- TERADATA_PORT is supported (default 1025)
- Module-level validation still fails fast on missing password
- Backwards compatible with existing TD_* deployments
  </done>
</task>

<task type="auto">
  <name>Task 2: Add API_PORT support to python_server.py</name>
  <files>lineage-api/python_server.py</files>
  <action>
Update python_server.py to use API_PORT as the primary port variable with PORT as fallback.

1. Update the server startup section at the bottom of the file:
   - Change from: `port = int(os.environ.get("PORT", "8080"))`
   - Change to: `port = int(os.environ.get("API_PORT") or os.environ.get("PORT", "8080"))`

2. Update the docstring at the top of the file to document:
   - API_PORT: Server port (default: 8080)
   - PORT: Legacy alias for API_PORT

3. The DB_CONFIG section already uses TERADATA_* as primary - no changes needed there.

DO NOT modify any other logic in the file - only the port configuration.
  </action>
  <verify>
Test API_PORT: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && API_PORT=9000 TERADATA_PASSWORD=test python -c "import python_server; print('API_PORT works')"` - should not error on import.

Test PORT fallback: `PORT=9001 TERADATA_PASSWORD=test python -c "import python_server; print('PORT fallback works')"` - should not error.

Verify precedence by checking the code: `grep -n "API_PORT" /Users/Daniel.Tehan/Code/lineage/lineage-api/python_server.py` - should show API_PORT checked first.
  </verify>
  <done>
- python_server.py uses API_PORT as primary port variable
- PORT works as fallback for backwards compatibility
- Docstring documents the new variable naming
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Import test for db_config.py:
```bash
cd /Users/Daniel.Tehan/Code/lineage/database
TERADATA_PASSWORD=test python -c "import db_config; print('db_config OK')"
```

2. Import test for python_server.py:
```bash
cd /Users/Daniel.Tehan/Code/lineage/lineage-api
TERADATA_PASSWORD=test python -c "import python_server; print('python_server OK')"
```

3. Verify both files have consistent patterns:
```bash
grep -l "TERADATA_HOST" /Users/Daniel.Tehan/Code/lineage/database/db_config.py /Users/Daniel.Tehan/Code/lineage/lineage-api/python_server.py
```
</verification>

<success_criteria>
- [ ] db_config.py uses TERADATA_* as primary, TD_* as fallback
- [ ] db_config.py supports TERADATA_PORT (default 1025)
- [ ] python_server.py uses API_PORT as primary, PORT as fallback
- [ ] Both files import without error when TERADATA_PASSWORD is set
- [ ] Backwards compatibility: TD_* and PORT still work when TERADATA_*/API_PORT not set
</success_criteria>

<output>
After completion, create `.planning/phases/07-environment-variable-consolidation/07-01-SUMMARY.md`
</output>
