---
phase: 31-cache-control-and-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-api/internal/domain/repository.go
  - lineage-api/internal/adapter/outbound/redis/cache.go
  - lineage-api/internal/adapter/outbound/redis/cache_metadata.go
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
  - lineage-api/internal/adapter/inbound/http/cache_middleware.go
  - lineage-api/internal/adapter/inbound/http/cache_middleware_test.go
  - lineage-api/internal/adapter/inbound/http/router.go
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
  - lineage-api/internal/adapter/outbound/redis/cache_test.go
autonomous: true

must_haves:
  truths:
    - "API responses from cached v2 endpoints include X-Cache: HIT or X-Cache: MISS header"
    - "API responses from cached v2 endpoints include X-Cache-TTL header with seconds remaining on cache hit"
    - "Adding ?refresh=true to a cached v2 endpoint bypasses cache read and returns fresh data from Teradata"
    - "After ?refresh=true, the fresh result is stored in cache so subsequent normal requests return it"
    - "Uncached endpoints (health, v1, jobs, runs) do NOT include X-Cache headers"
    - "When NoOpCache is active, responses get X-Cache: MISS with no X-Cache-TTL header"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/redis/cache_metadata.go"
      provides: "CacheMetadata struct, context helpers, bypass signal"
      contains: "CacheMetadata"
    - path: "lineage-api/internal/adapter/inbound/http/cache_middleware.go"
      provides: "CacheControl middleware with ResponseWriter wrapper"
      contains: "CacheControl"
    - path: "lineage-api/internal/adapter/inbound/http/cache_middleware_test.go"
      provides: "Middleware tests for HIT/MISS headers, TTL, bypass, and NoOpCache"
  key_links:
    - from: "lineage-api/internal/adapter/inbound/http/cache_middleware.go"
      to: "lineage-api/internal/adapter/outbound/redis/cache_metadata.go"
      via: "context.WithValue for CacheMetadata propagation"
      pattern: "NewCacheMetadataContext|GetCacheMetadata|IsCacheBypass"
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      to: "lineage-api/internal/adapter/outbound/redis/cache_metadata.go"
      via: "reads bypass signal, writes hit/miss/ttl to metadata"
      pattern: "IsCacheBypass|GetCacheMetadata"
    - from: "lineage-api/internal/adapter/inbound/http/router.go"
      to: "lineage-api/internal/adapter/inbound/http/cache_middleware.go"
      via: "middleware mounted on v2 API routes"
      pattern: "CacheControl"
---

<objective>
Add cache status headers (X-Cache: HIT/MISS, X-Cache-TTL) and ?refresh=true cache bypass to all cached v2 API endpoints using a context-based metadata propagation pattern with a Chi middleware.

Purpose: Operators and users can observe cache effectiveness (HIT/MISS headers), and users can force fresh data when needed (?refresh=true). This completes the backend portion of Phase 31 cache observability.

Output: CacheMetadata context type, CacheControl middleware with ResponseWriter wrapper, updated CachedOpenLineageRepository with bypass and metadata support, TTL method on CacheRepository interface, CORS ExposedHeaders update, and comprehensive tests.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-cache-control-and-observability/31-RESEARCH.md
@lineage-api/internal/domain/repository.go
@lineage-api/internal/adapter/outbound/redis/cache.go
@lineage-api/internal/adapter/outbound/redis/cache_keys.go
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
@lineage-api/internal/adapter/inbound/http/router.go
@lineage-api/internal/adapter/inbound/http/response.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TTL to CacheRepository interface, implement on Redis and NoOpCache, create CacheMetadata context type</name>
  <files>
    lineage-api/internal/domain/repository.go
    lineage-api/internal/adapter/outbound/redis/cache.go
    lineage-api/internal/adapter/outbound/redis/cache_metadata.go
    lineage-api/internal/adapter/outbound/redis/cache_test.go
  </files>
  <action>
    1. Add `TTL(ctx context.Context, key string) (int, error)` method to `domain.CacheRepository` interface in repository.go. This returns remaining TTL in seconds (-2 for non-existent key, -1 for no expiry).

    2. Implement `TTL` on `CacheRepository` in cache.go:
       ```go
       func (r *CacheRepository) TTL(ctx context.Context, key string) (int, error) {
           duration, err := r.client.TTL(ctx, key).Result()
           if err != nil {
               return -1, err
           }
           return int(duration.Seconds()), nil
       }
       ```

    3. Implement `TTL` on `NoOpCache` in cache.go:
       ```go
       func (c *NoOpCache) TTL(ctx context.Context, key string) (int, error) {
           return -1, nil
       }
       ```

    4. Create new file `cache_metadata.go` in the redis package with:
       - A package-level unexported `contextKey` type (string-based) to avoid context key collisions
       - `CacheMetadata` struct with fields: `Hit bool`, `TTL int` (seconds remaining, -1 if not cached), `Touched bool` (whether a cache-aside method was invoked)
       - `cacheMetadataKey` and `cacheBypassKey` constants of type contextKey
       - `NewCacheMetadataContext(ctx) context.Context` -- stores `&CacheMetadata{TTL: -1}` in context
       - `GetCacheMetadata(ctx) *CacheMetadata` -- retrieves pointer from context (nil if not present)
       - `WithCacheBypass(ctx) context.Context` -- stores `true` for bypass key
       - `IsCacheBypass(ctx) bool` -- reads bypass signal from context, defaults false

    5. Add a test for `NoOpCache.TTL` in cache_test.go alongside existing NoOpCache tests: verify it returns (-1, nil).

    6. Add a test for `TTL` on the mock in cached_openlineage_repo_test.go or update MockCacheRepository in domain/mocks/repositories.go to include a `TTL` method that returns a configurable value. The simplest approach: add `TTL` to MockCacheRepository that returns a fixed value (e.g., 900 seconds) so the mock satisfies the interface.

    IMPORTANT: The `contextKey` type in cache_metadata.go must be exported enough for the http middleware package to call the helper functions. Since the helper functions are exported (`NewCacheMetadataContext`, `GetCacheMetadata`, `WithCacheBypass`, `IsCacheBypass`), the contextKey type itself can remain unexported.
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` -- must compile with no errors.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/outbound/redis/...` -- all tests pass including new NoOpCache.TTL test.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/domain/mocks/...` -- mock compiles (if applicable).
  </verify>
  <done>
    domain.CacheRepository has TTL method. CacheRepository and NoOpCache both implement it. CacheMetadata context type exists with helpers for metadata propagation and bypass signaling. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CachedOpenLineageRepository to read bypass signal and write metadata to context</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
    lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
  </files>
  <action>
    Modify all 9 cached methods in `CachedOpenLineageRepository` (GetColumnLineageGraph, GetDataset, ListNamespaces, GetNamespace, ListDatasets, SearchDatasets, ListFields, GetDatasetStatistics, GetDatasetDDL) to:

    1. At the start of each method, get cache metadata: `md := GetCacheMetadata(ctx)`

    2. Before attempting cache.Get(), check for bypass: `if !IsCacheBypass(ctx) { ... }`. If bypass is true, skip the cache.Get() block entirely and fall through to the inner repository.

    3. On cache HIT (inside the existing `if err := r.cache.Get(...); err == nil` block):
       - If `md != nil`, set `md.Hit = true`, `md.Touched = true`
       - Get actual remaining TTL: `if ttl, err := r.cache.TTL(ctx, key); err == nil { md.TTL = ttl }`
       - Return the cached value as before

    4. On cache MISS or bypass, after successfully fetching from inner repo and populating cache:
       - If `md != nil`, set `md.Hit = false`, `md.Touched = true`
       - For the TTL value on miss: use the configured TTL value for that data type (e.g., `md.TTL = r.ttls.LineageTTL` for lineage, `md.TTL = r.ttls.AssetTTL` for assets, etc.) since we just set the cache with that TTL.

    5. Keep existing slog.Debug lines for cache hit/miss logging. Change the "cache miss" message to "cache miss/bypass" when IsCacheBypass is true (or just keep "cache miss" -- this is debug-level and the bypass is logged by the middleware).

    Update tests in cached_openlineage_repo_test.go:
    - Add test: "cache bypass skips Get, calls inner repo, populates cache, sets metadata Touched=true Hit=false"
    - Add test: "cache hit sets metadata Hit=true Touched=true with TTL from cache.TTL()"
    - Add test: "cache miss sets metadata Hit=false Touched=true with configured TTL"
    - Add test: "no metadata in context (nil pointer) does not panic" -- verifies nil-safety of `if md != nil` guards

    For these tests, use `NewCacheMetadataContext(ctx)` to set up context with metadata, then inspect `GetCacheMetadata(ctx)` after the method call. For bypass tests, use `WithCacheBypass(ctx)`.
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/outbound/redis/... -v -run "Bypass|Metadata|metadata"` -- new tests pass.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/outbound/redis/...` -- all 46+ tests pass (no regressions on existing tests).
  </verify>
  <done>
    All 9 cached methods support bypass via context signal and populate CacheMetadata for middleware consumption. New tests verify bypass, metadata population on hit/miss, and nil-safety. Existing tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CacheControl middleware, update CORS and router, add middleware tests</name>
  <files>
    lineage-api/internal/adapter/inbound/http/cache_middleware.go
    lineage-api/internal/adapter/inbound/http/cache_middleware_test.go
    lineage-api/internal/adapter/inbound/http/router.go
  </files>
  <action>
    1. Create `cache_middleware.go` in the http package:

       a. Import the redis package for `NewCacheMetadataContext`, `GetCacheMetadata`, `WithCacheBypass`, and `IsCacheBypass`.

       b. Define `cacheResponseWriter` struct wrapping `http.ResponseWriter`:
          - Fields: `http.ResponseWriter` (embedded), `ctx context.Context`, `wroteHeader bool`
          - Override `WriteHeader(code int)`: if `!crw.wroteHeader`, set `crw.wroteHeader = true`, read `GetCacheMetadata(crw.ctx)`, and:
            - If `md != nil && md.Touched`: set `X-Cache: HIT` or `X-Cache: MISS` based on `md.Hit`
            - If `md.Hit && md.TTL >= 0`: set `X-Cache-TTL` to `strconv.Itoa(md.TTL)`
            - Then call `crw.ResponseWriter.WriteHeader(code)`
          - Override `Write(b []byte) (int, error)`: if `!crw.wroteHeader`, call `crw.WriteHeader(http.StatusOK)`. Then call `crw.ResponseWriter.Write(b)`.
          - Implement `Unwrap() http.ResponseWriter` to return the inner writer (supports `http.ResponseController` and middleware chaining).

       c. Define `CacheControl` middleware function with signature `func CacheControl(next http.Handler) http.Handler`:
          - Return `http.HandlerFunc` that:
            - Creates cache metadata context: `ctx = redis.NewCacheMetadataContext(ctx)`
            - If `r.URL.Query().Get("refresh") == "true"`: `ctx = redis.WithCacheBypass(ctx)`
            - Creates `cacheResponseWriter{ResponseWriter: w, ctx: ctx}`
            - Calls `next.ServeHTTP(crw, r.WithContext(ctx))`

    2. Update `router.go`:
       a. Add `"X-Cache"` and `"X-Cache-TTL"` to the `ExposedHeaders` slice in CORS config:
          `ExposedHeaders: []string{"Link", "X-Cache", "X-Cache-TTL"},`

       b. Mount `CacheControl` middleware on the v2 API route group. Inside the `r.Route("/api/v2/openlineage", ...)` block, add `r.Use(CacheControl)` as the first line before any route definitions. This ensures only v2 routes get cache headers.

    3. Create `cache_middleware_test.go` with tests:

       a. **Test HIT header**: Create a handler that sets CacheMetadata `{Hit: true, Touched: true, TTL: 900}` in context metadata (simulate by pre-populating metadata in the middleware context). Use httptest.NewRecorder. Verify response has `X-Cache: HIT` and `X-Cache-TTL: 900`.

       b. **Test MISS header**: Same approach with `{Hit: false, Touched: true, TTL: -1}`. Verify `X-Cache: MISS` and no `X-Cache-TTL` header.

       c. **Test refresh=true sets bypass**: Send request with `?refresh=true` query param through middleware. Inside the handler, verify `redis.IsCacheBypass(r.Context()) == true`.

       d. **Test no refresh param**: Send request without refresh param. Verify `redis.IsCacheBypass(r.Context()) == false`.

       e. **Test untouched metadata (uncached endpoint)**: Metadata exists but `Touched` is false. Verify no `X-Cache` header set.

       f. **Test Unwrap returns inner writer**: Verify `cacheResponseWriter.Unwrap()` returns the original ResponseWriter.

       For tests a and b, the most practical approach: create a real handler that manually populates the CacheMetadata pointer (retrieved via `redis.GetCacheMetadata(r.Context())`) to simulate what the decorator would do, then call respondJSON. The middleware wraps the ResponseWriter, so headers get injected when WriteHeader is called.
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` -- compiles.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/inbound/http/... -v -run "CacheMiddleware|CacheControl|cacheResponse"` -- all middleware tests pass.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./...` -- all tests pass (full suite).
  </verify>
  <done>
    CacheControl middleware intercepts v2 API responses, injects X-Cache HIT/MISS and X-Cache-TTL headers based on context metadata, and reads ?refresh=true to set bypass signal. CORS exposes custom headers to browsers. Only v2 routes have the middleware. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` -- full compilation succeeds
2. `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./...` -- all tests pass (including new middleware, bypass, and metadata tests)
3. `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go vet ./...` -- no vet warnings
4. Grep for `X-Cache` in cache_middleware.go -- headers are set
5. Grep for `ExposedHeaders` in router.go -- includes X-Cache and X-Cache-TTL
6. Grep for `IsCacheBypass` in cached_openlineage_repo.go -- bypass check present in all 9 cached methods
7. Grep for `GetCacheMetadata` in cached_openlineage_repo.go -- metadata population present in all 9 cached methods
</verification>

<success_criteria>
- CONTROL-02: X-Cache: HIT header on cache hits (verified by test)
- CONTROL-03: X-Cache: MISS header on cache misses (verified by test)
- CONTROL-04: X-Cache-TTL header showing seconds until expiration (verified by test)
- CONTROL-01: ?refresh=true cache bypass (verified by test -- bypass signal propagated to repository)
- No X-Cache headers on uncached endpoints (v1, health, jobs, runs)
- CORS ExposedHeaders updated so browsers can read X-Cache and X-Cache-TTL
- NoOpCache path: X-Cache: MISS with no X-Cache-TTL (correct behavior)
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/31-cache-control-and-observability/31-01-SUMMARY.md`
</output>
