---
phase: 31-cache-control-and-observability
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - lineage-ui/src/types/openlineage.ts
  - lineage-ui/src/api/client.ts
  - lineage-ui/src/api/hooks/useOpenLineage.ts
  - lineage-ui/src/components/domain/LineageGraph/Toolbar.tsx
  - lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
  - lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
autonomous: true

must_haves:
  truths:
    - "Lineage graph toolbar has a refresh button that forces fresh data from Teradata"
    - "Asset browser has a refresh button that forces fresh namespace and dataset data"
    - "Clicking refresh sends ?refresh=true to the API and displays fresh data"
    - "After refresh, subsequent requests without refresh return newly cached data"
    - "Refresh button shows spinning animation while data is loading"
    - "Refresh button is disabled during initial load"
  artifacts:
    - path: "lineage-ui/src/types/openlineage.ts"
      provides: "Updated LineageQueryParams with refresh field"
      contains: "refresh"
    - path: "lineage-ui/src/api/client.ts"
      provides: "API client methods that pass refresh param"
      contains: "refresh"
    - path: "lineage-ui/src/components/domain/LineageGraph/Toolbar.tsx"
      provides: "Refresh button with RefreshCw icon"
      contains: "RefreshCw"
    - path: "lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx"
      provides: "Refresh button in asset browser header"
      contains: "RefreshCw"
  key_links:
    - from: "lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx"
      to: "lineage-ui/src/api/hooks/useOpenLineage.ts"
      via: "queryClient.invalidateQueries to force refetch with refresh param"
      pattern: "invalidateQueries|refetch"
    - from: "lineage-ui/src/api/client.ts"
      to: "Backend ?refresh=true parameter"
      via: "axios params.refresh passed as query string"
      pattern: "refresh.*true"
---

<objective>
Add UI refresh buttons to the lineage graph toolbar and asset browser that trigger cache bypass requests via ?refresh=true, completing the user-facing cache control feature.

Purpose: Users can force fresh data when they know the underlying Teradata data has changed, completing the v6.0 Redis caching milestone with full observability.

Output: Refresh button in lineage toolbar (RefreshCw icon), refresh button in asset browser header, updated API client passing refresh param, TanStack Query invalidation after refresh.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-cache-control-and-observability/31-RESEARCH.md
@.planning/phases/31-cache-control-and-observability/31-01-SUMMARY.md
@lineage-ui/src/types/openlineage.ts
@lineage-ui/src/api/client.ts
@lineage-ui/src/api/hooks/useOpenLineage.ts
@lineage-ui/src/components/domain/LineageGraph/Toolbar.tsx
@lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
@lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add refresh parameter support to API client and types</name>
  <files>
    lineage-ui/src/types/openlineage.ts
    lineage-ui/src/api/client.ts
  </files>
  <action>
    1. In `lineage-ui/src/types/openlineage.ts`, add `refresh?: boolean` to the `LineageQueryParams` interface:
       ```typescript
       export interface LineageQueryParams {
         direction?: LineageDirection;
         maxDepth?: number;
         refresh?: boolean;
       }
       ```

    2. In `lineage-ui/src/api/client.ts`, update all three lineage API methods (getLineageGraph, getTableLineageGraph, getDatabaseLineageGraph) to pass the `refresh` parameter. The key: only include `refresh=true` in the query string when it's actually true. If `params?.refresh` is falsy, omit it entirely so the URL stays clean.

       For `getLineageGraph`:
       ```typescript
       async getLineageGraph(
         datasetId: string,
         fieldName: string,
         params?: LineageQueryParams
       ): Promise<OpenLineageLineageResponse> {
         const { refresh, ...queryParams } = params || {};
         const response = await apiClientV2.get<OpenLineageLineageResponse>(
           `/api/v2/openlineage/lineage/${encodeURIComponent(datasetId)}/${encodeURIComponent(fieldName)}`,
           { params: { ...queryParams, ...(refresh ? { refresh: 'true' } : {}) } }
         );
         return response.data;
       }
       ```

       Apply the same pattern to `getTableLineageGraph` and `getDatabaseLineageGraph`.

    3. Also add refresh support to the non-lineage API methods that go through cached endpoints. Add an optional `options?: { refresh?: boolean }` parameter to: `getNamespaces`, `getNamespace`, `getDatasets`, `getDataset`, `searchDatasets`, `getDatasetStatistics`, `getDatasetDDL`. For each, if `options?.refresh` is true, append `refresh: 'true'` to the params object.

       Example for `getNamespaces`:
       ```typescript
       async getNamespaces(options?: { refresh?: boolean }): Promise<NamespacesResponse> {
         const response = await apiClientV2.get<NamespacesResponse>(
           '/api/v2/openlineage/namespaces',
           { params: options?.refresh ? { refresh: 'true' } : undefined }
         );
         return response.data;
       }
       ```

       Example for `getDatasets` (which already has params):
       ```typescript
       async getDatasets(
         namespaceId: string,
         params?: OpenLineagePaginationParams,
         options?: { refresh?: boolean }
       ): Promise<DatasetsResponse> {
         const response = await apiClientV2.get<DatasetsResponse>(
           `/api/v2/openlineage/namespaces/${encodeURIComponent(namespaceId)}/datasets`,
           { params: { ...params, ...(options?.refresh ? { refresh: 'true' } : {}) } }
         );
         return response.data;
       }
       ```
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` -- TypeScript compilation passes with no errors.
  </verify>
  <done>
    All API client methods support an optional refresh parameter. When refresh is true, `?refresh=true` is appended to the request URL. When false or omitted, no refresh param is sent. TypeScript types are correct.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add refresh button to lineage toolbar and asset browser, wire up cache bypass</name>
  <files>
    lineage-ui/src/components/domain/LineageGraph/Toolbar.tsx
    lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
    lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
    lineage-ui/src/api/hooks/useOpenLineage.ts
  </files>
  <action>
    **Toolbar.tsx changes:**

    1. Add `RefreshCw` to lucide-react imports:
       ```typescript
       import { Search, Maximize2, Download, ChevronDown, Focus, Filter, Crosshair, RefreshCw } from 'lucide-react';
       ```

    2. Add to `ToolbarProps` interface:
       ```typescript
       onRefresh?: () => void;
       isFetching?: boolean;  // true when refetching (distinct from initial isLoading)
       ```

    3. Add `onRefresh` and `isFetching = false` to the destructured props.

    4. Add a refresh button in the action buttons section (the `ml-auto` div), BEFORE the Fit to View button:
       ```tsx
       {onRefresh && (
         <Tooltip content="Refresh data (bypass cache)" position="bottom">
           <button
             onClick={onRefresh}
             disabled={isLoading}
             className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg transition-colors disabled:opacity-50"
             aria-label="Refresh data"
             data-testid="refresh-btn"
           >
             <RefreshCw className={`w-4 h-4 ${isFetching ? 'animate-spin' : ''}`} />
           </button>
         </Tooltip>
       )}
       ```

    **LineageGraph.tsx changes:**

    1. Add `useQueryClient` import from `@tanstack/react-query`:
       ```typescript
       import { useQueryClient } from '@tanstack/react-query';
       ```

    2. Inside `LineageGraphInner`, get queryClient and isFetching:
       ```typescript
       const queryClient = useQueryClient();
       ```

    3. Destructure `isFetching` from the `useOpenLineageTableLineage` hook:
       ```typescript
       const { data, isLoading, isFetching, error } = useOpenLineageTableLineage(datasetId, direction, maxDepth);
       ```

    4. Create a `handleRefresh` callback:
       ```typescript
       const handleRefresh = useCallback(async () => {
         // Fetch fresh data with refresh=true to bypass backend cache
         const freshData = await openLineageApi.getTableLineageGraph(datasetId, {
           direction,
           maxDepth,
           refresh: true,
         });
         // Update TanStack Query cache with fresh data
         queryClient.setQueryData(
           ['openlineage', 'table-lineage', datasetId, direction, maxDepth],
           freshData
         );
       }, [datasetId, direction, maxDepth, queryClient]);
       ```

       Import `openLineageApi` from the client module:
       ```typescript
       import { openLineageApi } from '../../../api/client';
       ```

    5. Pass `onRefresh={handleRefresh}` and `isFetching={isFetching && !isLoading}` to the `<Toolbar>` component.

    **AssetBrowser.tsx changes:**

    1. Add `RefreshCw` to lucide-react imports.

    2. Add `useQueryClient` import from `@tanstack/react-query`.

    3. Inside `AssetBrowser` function, get `queryClient`:
       ```typescript
       const queryClient = useQueryClient();
       ```

    4. Destructure `isFetching` from the namespaces and datasets hooks:
       ```typescript
       const { data: namespacesData, isLoading: isLoadingNamespaces, isFetching: isFetchingNamespaces } = useOpenLineageNamespaces();
       const { data: datasetsData, isLoading: isLoadingDatasets, isFetching: isFetchingDatasets } = useOpenLineageDatasets(...);
       ```

    5. Create a `handleRefresh` callback that invalidates all openlineage queries, forcing TanStack to refetch with fresh data:
       ```typescript
       const handleRefresh = useCallback(async () => {
         // Fetch fresh namespace and dataset data, bypassing cache
         // Invalidate queries to trigger refetch
         await queryClient.invalidateQueries({ queryKey: ['openlineage'] });
       }, [queryClient]);
       ```

       Note: `invalidateQueries` marks all matching queries as stale and refetches active ones. This does NOT pass `?refresh=true` automatically -- but for the asset browser, a simple refetch (which results in a cache HIT on the backend) is sufficient because the backend cache was already populated. If users want a full cache bypass, the lineage toolbar's approach (manual fetch with refresh=true + setQueryData) is more appropriate. For the asset browser, use the simpler invalidation approach since asset data is less time-sensitive.

       ALTERNATIVE (if full cache bypass is desired for asset browser): Create wrapper functions in the hooks file that accept a refresh option. But for simplicity and since the success criteria says "refresh button that triggers cache bypass request", let's do the full bypass:

       ```typescript
       const handleRefresh = useCallback(async () => {
         // Fetch fresh data bypassing backend cache
         if (defaultNamespace) {
           const [freshNamespaces, freshDatasets] = await Promise.all([
             openLineageApi.getNamespaces({ refresh: true }),
             openLineageApi.getDatasets(defaultNamespace.id, { limit: 1000, offset: 0 }, { refresh: true }),
           ]);
           queryClient.setQueryData(['openlineage', 'namespaces'], freshNamespaces);
           queryClient.setQueryData(
             ['openlineage', 'datasets', defaultNamespace.id, { limit: 1000, offset: 0 }],
             freshDatasets
           );
         }
       }, [defaultNamespace, queryClient]);
       ```

       Import `openLineageApi` from the client.

    6. Add the refresh button in the header area, next to the "Databases" heading:
       ```tsx
       <div className="p-2">
         <div className="flex items-center justify-between px-2 py-1">
           <h2 className="text-sm font-semibold text-slate-700">Databases</h2>
           <Tooltip content="Refresh data (bypass cache)" position="right">
             <button
               onClick={handleRefresh}
               disabled={isLoadingNamespaces || isLoadingDatasets}
               className="p-1 text-slate-500 hover:bg-slate-100 rounded transition-colors disabled:opacity-50"
               aria-label="Refresh data"
               data-testid="asset-browser-refresh-btn"
             >
               <RefreshCw className={`w-3.5 h-3.5 ${(isFetchingNamespaces || isFetchingDatasets) && !(isLoadingNamespaces || isLoadingDatasets) ? 'animate-spin' : ''}`} />
             </button>
           </Tooltip>
         </div>
       ```
       This replaces the existing `<h2>` tag. The refresh icon spins only during refetch (not initial load).
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` -- TypeScript compilation passes.
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run` -- all existing unit tests pass.
    Grep for `RefreshCw` in Toolbar.tsx -- import and usage present.
    Grep for `RefreshCw` in AssetBrowser.tsx -- import and usage present.
    Grep for `onRefresh` in LineageGraph.tsx -- prop passed to Toolbar.
    Grep for `refresh` in client.ts -- param support in API methods.
  </verify>
  <done>
    Lineage graph toolbar has a refresh button (RefreshCw icon) that fetches data with ?refresh=true and updates the TanStack cache. Asset browser has a refresh button in the header that bypasses cache for namespaces and datasets. Both buttons show spinning animation during refetch and are disabled during initial load. All TypeScript types are correct and existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` -- TypeScript compilation passes
2. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run` -- all unit tests pass
3. Grep for `RefreshCw` in Toolbar.tsx and AssetBrowser.tsx -- refresh buttons exist
4. Grep for `refresh.*true` in client.ts -- API methods pass refresh param
5. Grep for `onRefresh` in LineageGraph.tsx -- toolbar integration wired
6. Grep for `handleRefresh` in AssetBrowser.tsx -- asset browser refresh wired
7. Grep for `data-testid="refresh-btn"` in Toolbar.tsx -- testid present
8. Grep for `data-testid="asset-browser-refresh-btn"` in AssetBrowser.tsx -- testid present
</verification>

<success_criteria>
- CONTROL-05: UI refresh buttons send ?refresh=true to force fresh data
- Lineage graph toolbar has refresh button with RefreshCw icon
- Asset browser has refresh button in header section
- Refresh button spins while data is being fetched
- After refresh, TanStack Query cache is updated with fresh data
- Subsequent requests (without refresh) serve newly cached data
- All existing unit tests pass with zero regressions
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/31-cache-control-and-observability/31-02-SUMMARY.md`
</output>
