---
phase: 16-correctness-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/test_correctness.py
autonomous: true

must_haves:
  truths:
    - "Cycle patterns terminate without infinite loops"
    - "Diamond patterns produce correct node counts"
    - "Fan-out patterns include all target nodes"
    - "Fan-in patterns include all source nodes"
    - "Combined patterns produce correct totals"
  artifacts:
    - path: "database/test_correctness.py"
      provides: "CTE correctness validation test suite"
      min_lines: 200
  key_links:
    - from: "database/test_correctness.py"
      to: "OL_COLUMN_LINEAGE"
      via: "Recursive CTE queries"
      pattern: "WITH RECURSIVE"
---

<objective>
Create database-level CTE correctness tests that validate graph algorithm behavior

Purpose: Verify that the recursive CTE queries correctly handle cycles, diamonds, and fan patterns using POSITION(id IN path) cycle detection
Output: Python test script `database/test_correctness.py` that runs against Phase 15 test data
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-correctness-validation/16-RESEARCH.md
@database/insert_cte_test_data.py
@database/run_tests.py
@lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CTE correctness test script</name>
  <files>database/test_correctness.py</files>
  <action>
Create a new Python test script `database/test_correctness.py` that validates graph algorithm correctness. Follow the existing pattern from `database/run_tests.py`.

**Structure:**
```python
#!/usr/bin/env python3
"""
CTE Correctness Validation Tests (Phase 16)
Validates graph algorithms handle complex patterns correctly.
"""
import teradatasql
import sys
from db_config import CONFIG

# Expected counts derived from insert_cte_test_data.py
EXPECTED_COUNTS = {
    # CORRECT-VAL-01: Cycles
    'CYCLE_TEST': {'nodes': 2, 'edges': 2},       # 2-node cycle: A->B->A
    'MCYCLE_TEST': {'nodes': 4, 'edges': 4},      # 4-node cycle: A->B->C->D->A
    'CYCLE5_TEST': {'nodes': 5, 'edges': 5},      # 5-node cycle: A->B->C->D->E->A

    # CORRECT-VAL-02: Diamonds
    'DIAMOND': {'nodes': 4, 'edges': 4},          # Simple: A->B->D, A->C->D
    'NESTED_DIAMOND': {'nodes': 7, 'edges': 8},   # Two diamonds in series
    'WIDE_DIAMOND': {'nodes': 6, 'edges': 8},     # A->B,C,D,E->F

    # CORRECT-VAL-03: Fan-out
    'FANOUT5_TEST': {'nodes': 6, 'edges': 5},     # 1 source + 5 targets
    'FANOUT10_TEST': {'nodes': 11, 'edges': 10},  # 1 source + 10 targets

    # CORRECT-VAL-04: Fan-in
    'FANIN5_TEST': {'nodes': 6, 'edges': 5},      # 5 sources + 1 target
    'FANIN10_TEST': {'nodes': 11, 'edges': 10},   # 10 sources + 1 target

    # CORRECT-VAL-05: Combined
    'COMBINED_CYCLE_DIAMOND': {'nodes': 4, 'edges': 5},
    'COMBINED_FAN': {'nodes': 5, 'edges': 6},
}
```

**Test Functions to implement:**

1. `test_cycle_detection(cursor, table_name, expected)` - Tests that cycles terminate:
   - Run upstream CTE query from a node in the cycle
   - Assert query completes without timeout (5 second timeout)
   - Assert returned edge count matches expected (proves no infinite loop)
   - Assert returned node count matches expected (proves no duplicates)

2. `test_diamond_deduplication(cursor, table_name, expected)` - Tests no duplicate nodes:
   - Run bidirectional CTE query from the sink node (col_d)
   - Assert unique node count matches expected
   - Assert edge count matches expected
   - Verify no node ID appears twice in result

3. `test_fanout_completeness(cursor, table_name, expected)` - Tests all targets included:
   - Run downstream CTE query from source
   - Assert all target nodes present in result
   - Assert edge count matches expected

4. `test_fanin_completeness(cursor, table_name, expected)` - Tests all sources included:
   - Run upstream CTE query from target
   - Assert all source nodes present in result
   - Assert edge count matches expected

**CTE Query Pattern (same as openlineage_repo.go):**
```sql
WITH RECURSIVE upstream AS (
    SELECT lineage_id, source_dataset, source_field, target_dataset, target_field,
           1 AS depth, CAST(lineage_id AS VARCHAR(4000)) AS path
    FROM demo_user.OL_COLUMN_LINEAGE
    WHERE target_dataset = ? AND target_field = ? AND is_active = 'Y'
    UNION ALL
    SELECT cl.lineage_id, cl.source_dataset, cl.source_field, cl.target_dataset, cl.target_field,
           u.depth + 1, u.path || ',' || cl.lineage_id
    FROM demo_user.OL_COLUMN_LINEAGE cl
    JOIN upstream u ON cl.target_dataset = u.source_dataset AND cl.target_field = u.source_field
    WHERE cl.is_active = 'Y' AND u.depth < 10 AND POSITION(cl.lineage_id IN u.path) = 0
)
SELECT COUNT(DISTINCT lineage_id) AS edge_count,
       COUNT(DISTINCT source_field) + COUNT(DISTINCT target_field) AS approx_nodes
FROM upstream
```

**Main function:**
- Connect to database using CONFIG from db_config.py
- Run all test functions for each pattern in EXPECTED_COUNTS
- Print summary (passed/failed/skipped)
- Return exit code 0 if all pass, 1 otherwise

**Important:** Use `try/except` with timeout handling - if a query times out, that indicates an infinite loop bug.
  </action>
  <verify>python database/test_correctness.py --help or python -c "import database.test_correctness"</verify>
  <done>test_correctness.py exists with test functions for all pattern types</done>
</task>

<task type="auto">
  <name>Task 2: Run CTE correctness tests and validate results</name>
  <files>database/test_correctness.py</files>
  <action>
Execute the correctness tests against the database containing Phase 15 test data.

1. Ensure test data exists:
   ```bash
   cd database && python insert_cte_test_data.py
   ```

2. Run correctness tests:
   ```bash
   cd database && python test_correctness.py
   ```

3. Verify output shows:
   - All cycle tests pass (no timeouts, correct counts)
   - All diamond tests pass (no duplicate nodes)
   - All fan-out tests pass (all targets included)
   - All fan-in tests pass (all sources included)
   - All combined pattern tests pass

4. If any tests fail, debug and fix the test or document the issue.

**Expected output format:**
```
=== CTE Correctness Validation Tests ===

1. CYCLE DETECTION TESTS
  [PASS] CYCLE_TEST: 2-node cycle terminates (2 edges, 2 nodes)
  [PASS] MCYCLE_TEST: 4-node cycle terminates (4 edges, 4 nodes)
  [PASS] CYCLE5_TEST: 5-node cycle terminates (5 edges, 5 nodes)

2. DIAMOND DEDUPLICATION TESTS
  [PASS] DIAMOND: No duplicates (4 edges, 4 nodes)
  ...

Summary: X passed, Y failed, Z skipped
```

**Important:** If database is not available, the test should print a clear message and exit with code 0 (skip, not fail).
  </action>
  <verify>cd /Users/Daniel.Tehan/Code/lineage/database && python test_correctness.py 2>&1 | tail -20</verify>
  <done>All correctness tests pass or skip gracefully with documented results</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `database/test_correctness.py` exists and is executable
2. Test script covers requirements CORRECT-VAL-01 through CORRECT-VAL-07
3. Running `python test_correctness.py` produces meaningful output
4. No infinite loops or timeouts in any test case
</verification>

<success_criteria>
- Cycle patterns terminate without infinite loops (path tracking works)
- Diamond patterns produce single node instances (no duplicate nodes in graph)
- Fan-out patterns include all target nodes in the graph
- Fan-in patterns include all source nodes in the graph
- Node and edge counts match expected values for each test pattern
</success_criteria>

<output>
After completion, create `.planning/phases/16-correctness-validation/16-01-SUMMARY.md`
</output>
