---
phase: 16-correctness-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-ui/src/__tests__/integration/correctness.test.ts
autonomous: true

must_haves:
  truths:
    - "Frontend correctly handles cycle patterns in graph data"
    - "Frontend deduplicates nodes in diamond patterns"
    - "Frontend renders all nodes in fan-out patterns"
    - "Frontend renders all nodes in fan-in patterns"
    - "layoutGraph produces correct node/edge counts"
  artifacts:
    - path: "lineage-ui/src/__tests__/integration/correctness.test.ts"
      provides: "Frontend graph correctness validation tests"
      min_lines: 200
  key_links:
    - from: "lineage-ui/src/__tests__/integration/correctness.test.ts"
      to: "lineage-ui/src/utils/graph/layoutEngine.ts"
      via: "layoutGraph function calls"
      pattern: "layoutGraph"
---

<objective>
Create frontend integration tests validating graph algorithm correctness with mock data

Purpose: Verify that layoutEngine and groupColumnsByTable correctly handle complex patterns from API responses
Output: Vitest test file `lineage-ui/src/__tests__/integration/correctness.test.ts`
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-correctness-validation/16-RESEARCH.md
@lineage-ui/src/utils/graph/layoutEngine.ts
@lineage-ui/src/utils/graph/layoutEngine.test.ts
@lineage-ui/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration directory structure</name>
  <files>lineage-ui/src/__tests__/integration/correctness.test.ts</files>
  <action>
Create the integration test directory and test file:

```bash
mkdir -p lineage-ui/src/__tests__/integration
```

Create `lineage-ui/src/__tests__/integration/correctness.test.ts` with the test structure. This file tests that the frontend graph utilities correctly handle complex patterns.

**Test file structure:**
```typescript
import { describe, it, expect } from 'vitest';
import { layoutGraph, groupByTable } from '../../utils/graph/layoutEngine';
import type { LineageNode, LineageEdge } from '../../types';

/**
 * Phase 16: Correctness Validation Tests
 *
 * These tests validate that the frontend graph utilities correctly handle
 * complex patterns (cycles, diamonds, fans) that may come from the API.
 *
 * Requirements covered:
 * - CORRECT-VAL-01: Cycle detection (frontend handles cyclic edges)
 * - CORRECT-VAL-02: Diamond deduplication (no duplicate table nodes)
 * - CORRECT-VAL-03: Fan-out completeness (all targets rendered)
 * - CORRECT-VAL-04: Fan-in completeness (all sources rendered)
 * - CORRECT-VAL-06: Node count validation
 * - CORRECT-VAL-07: Edge count validation
 */

// Test data matching Phase 15 patterns (from insert_cte_test_data.py)
const EXPECTED_COUNTS = {
  // Cycles - frontend receives these as edges, should not cause issues
  CYCLE_2NODE: { nodes: 2, edges: 2, tables: 1 },
  CYCLE_5NODE: { nodes: 5, edges: 5, tables: 1 },

  // Diamonds - key test: no duplicate nodes
  DIAMOND_SIMPLE: { nodes: 4, edges: 4, tables: 4 },
  DIAMOND_WIDE: { nodes: 6, edges: 8, tables: 6 },

  // Fans - key test: all nodes present
  FANOUT_5: { nodes: 6, edges: 5, tables: 6 },
  FANIN_5: { nodes: 6, edges: 5, tables: 6 },
};
```

**Test Categories to implement:**

1. **Cycle Pattern Tests** (CORRECT-VAL-01):
   - Test that layoutGraph completes with cyclic edge data
   - Test that groupByTable handles columns from same table in cycle
   - Verify no infinite loops or stack overflow

2. **Diamond Pattern Tests** (CORRECT-VAL-02):
   - Test simple diamond: A->B->D, A->C->D
   - Test wide diamond: A->B,C,D,E->F
   - Verify unique node count (no duplicates)
   - Verify all edges preserved

3. **Fan-out Pattern Tests** (CORRECT-VAL-03):
   - Test 1->5 fan-out
   - Verify all 5 target nodes in result
   - Verify edge count matches input

4. **Fan-in Pattern Tests** (CORRECT-VAL-04):
   - Test 5->1 fan-in
   - Verify all 5 source nodes in result
   - Verify edge count matches input

5. **Node/Edge Count Tests** (CORRECT-VAL-06, CORRECT-VAL-07):
   - For each pattern, assert exact node count
   - For each pattern, assert exact edge count
   - Verify no data loss through layout process
  </action>
  <verify>ls -la lineage-ui/src/__tests__/integration/</verify>
  <done>Integration test directory and file structure created</done>
</task>

<task type="auto">
  <name>Task 2: Implement correctness validation tests</name>
  <files>lineage-ui/src/__tests__/integration/correctness.test.ts</files>
  <action>
Implement the full test suite in `lineage-ui/src/__tests__/integration/correctness.test.ts`.

**Test Data Helpers:**
```typescript
// Helper to create node for a column
function createColumnNode(db: string, table: string, column: string): LineageNode {
  return {
    id: `${db}.${table}.${column}`,
    type: 'column',
    databaseName: db,
    tableName: table,
    columnName: column,
  };
}

// Helper to create edge
function createEdge(sourceId: string, targetId: string, transType = 'DIRECT'): LineageEdge {
  return {
    id: `e_${sourceId}_${targetId}`,
    source: sourceId,
    target: targetId,
    transformationType: transType,
  };
}
```

**Test Implementations:**

```typescript
describe('CORRECT-VAL-01: Cycle Detection', () => {
  it('handles 2-node cycle without infinite loop', async () => {
    // A->B->A (same table)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'CYCLE_TEST', 'col_a'),
      createColumnNode('db', 'CYCLE_TEST', 'col_b'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.CYCLE_TEST.col_a', 'db.CYCLE_TEST.col_b'),
      createEdge('db.CYCLE_TEST.col_b', 'db.CYCLE_TEST.col_a'),
    ];

    // Should complete without timeout/error
    const result = await layoutGraph(nodes, edges);

    // Single table node with 2 columns
    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(2);
    // Both edges preserved (internal to same table)
    expect(result.edges).toHaveLength(2);
  });

  it('handles 5-node cycle without infinite loop', async () => {
    // A->B->C->D->E->A (same table)
    const columns = ['col_a', 'col_b', 'col_c', 'col_d', 'col_e'];
    const nodes = columns.map(c => createColumnNode('db', 'CYCLE5_TEST', c));
    const edges = columns.map((c, i) => {
      const next = columns[(i + 1) % columns.length];
      return createEdge(`db.CYCLE5_TEST.${c}`, `db.CYCLE5_TEST.${next}`);
    });

    const result = await layoutGraph(nodes, edges);

    expect(result.nodes).toHaveLength(1); // Single table
    expect(result.nodes[0].data.columns).toHaveLength(5);
    expect(result.edges).toHaveLength(5);
  });
});

describe('CORRECT-VAL-02: Diamond Deduplication', () => {
  it('simple diamond produces exactly 4 table nodes', async () => {
    // A->B->D, A->C->D (4 different tables)
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'col_a'),
      createColumnNode('db', 't2', 'col_b'),
      createColumnNode('db', 't3', 'col_c'),
      createColumnNode('db', 't4', 'col_d'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.t1.col_a', 'db.t2.col_b'),
      createEdge('db.t1.col_a', 'db.t3.col_c'),
      createEdge('db.t2.col_b', 'db.t4.col_d'),
      createEdge('db.t3.col_c', 'db.t4.col_d'),
    ];

    const result = await layoutGraph(nodes, edges);

    // 4 unique table nodes
    expect(result.nodes).toHaveLength(4);
    // All 4 edges preserved
    expect(result.edges).toHaveLength(4);

    // No duplicate IDs
    const nodeIds = result.nodes.map(n => n.id);
    expect(new Set(nodeIds).size).toBe(nodeIds.length);
  });

  it('wide diamond with 4 middle nodes produces correct counts', async () => {
    // A->B,C,D,E->F
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'col_a'),
      createColumnNode('db', 't2', 'col_b'),
      createColumnNode('db', 't3', 'col_c'),
      createColumnNode('db', 't4', 'col_d'),
      createColumnNode('db', 't5', 'col_e'),
      createColumnNode('db', 't6', 'col_f'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.t1.col_a', 'db.t2.col_b'),
      createEdge('db.t1.col_a', 'db.t3.col_c'),
      createEdge('db.t1.col_a', 'db.t4.col_d'),
      createEdge('db.t1.col_a', 'db.t5.col_e'),
      createEdge('db.t2.col_b', 'db.t6.col_f'),
      createEdge('db.t3.col_c', 'db.t6.col_f'),
      createEdge('db.t4.col_d', 'db.t6.col_f'),
      createEdge('db.t5.col_e', 'db.t6.col_f'),
    ];

    const result = await layoutGraph(nodes, edges);

    expect(result.nodes).toHaveLength(6);
    expect(result.edges).toHaveLength(8);
  });
});

describe('CORRECT-VAL-03: Fan-out Completeness', () => {
  it('fan-out 5 includes all 5 target nodes', async () => {
    // 1 source -> 5 targets (different tables)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'src', 'source'),
      ...Array.from({ length: 5 }, (_, i) =>
        createColumnNode('db', `tgt${i + 1}`, `target_${i + 1}`)
      ),
    ];
    const edges = Array.from({ length: 5 }, (_, i) =>
      createEdge('db.src.source', `db.tgt${i + 1}.target_${i + 1}`)
    );

    const result = await layoutGraph(nodes, edges);

    // 6 table nodes (1 source + 5 targets)
    expect(result.nodes).toHaveLength(6);
    // 5 edges
    expect(result.edges).toHaveLength(5);

    // Verify all target tables present
    const tableIds = result.nodes.map(n => n.id);
    for (let i = 1; i <= 5; i++) {
      expect(tableIds).toContain(`db.tgt${i}`);
    }
  });
});

describe('CORRECT-VAL-04: Fan-in Completeness', () => {
  it('fan-in 5 includes all 5 source nodes', async () => {
    // 5 sources -> 1 target (different tables)
    const nodes: LineageNode[] = [
      ...Array.from({ length: 5 }, (_, i) =>
        createColumnNode('db', `src${i + 1}`, `source_${i + 1}`)
      ),
      createColumnNode('db', 'tgt', 'target'),
    ];
    const edges = Array.from({ length: 5 }, (_, i) =>
      createEdge(`db.src${i + 1}.source_${i + 1}`, 'db.tgt.target')
    );

    const result = await layoutGraph(nodes, edges);

    // 6 table nodes (5 sources + 1 target)
    expect(result.nodes).toHaveLength(6);
    // 5 edges
    expect(result.edges).toHaveLength(5);

    // Verify all source tables present
    const tableIds = result.nodes.map(n => n.id);
    for (let i = 1; i <= 5; i++) {
      expect(tableIds).toContain(`db.src${i}`);
    }
  });
});

describe('CORRECT-VAL-06 & CORRECT-VAL-07: Node/Edge Counts', () => {
  it('preserves all nodes through layout', async () => {
    // Complex graph with 10 nodes
    const nodes = Array.from({ length: 10 }, (_, i) =>
      createColumnNode('db', `t${i}`, `col${i}`)
    );
    const edges = [
      createEdge('db.t0.col0', 'db.t1.col1'),
      createEdge('db.t0.col0', 'db.t2.col2'),
      createEdge('db.t1.col1', 'db.t3.col3'),
      createEdge('db.t2.col2', 'db.t3.col3'),
      createEdge('db.t3.col3', 'db.t4.col4'),
      createEdge('db.t4.col4', 'db.t5.col5'),
      createEdge('db.t4.col4', 'db.t6.col6'),
      createEdge('db.t5.col5', 'db.t7.col7'),
      createEdge('db.t6.col6', 'db.t7.col7'),
      createEdge('db.t7.col7', 'db.t8.col8'),
      createEdge('db.t8.col8', 'db.t9.col9'),
    ];

    const result = await layoutGraph(nodes, edges);

    // All 10 nodes preserved
    expect(result.nodes).toHaveLength(10);
    // All 11 edges preserved
    expect(result.edges).toHaveLength(11);
  });

  it('groupByTable produces unique keys', () => {
    // Columns from 3 tables
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'a'),
      createColumnNode('db', 't1', 'b'),
      createColumnNode('db', 't2', 'c'),
      createColumnNode('db', 't3', 'd'),
      createColumnNode('db', 't3', 'e'),
      createColumnNode('db', 't3', 'f'),
    ];

    const groups = groupByTable(nodes);

    // 3 unique table groups
    expect(groups.size).toBe(3);
    expect(groups.get('db.t1')?.length).toBe(2);
    expect(groups.get('db.t2')?.length).toBe(1);
    expect(groups.get('db.t3')?.length).toBe(3);
  });
});
```
  </action>
  <verify>cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run src/__tests__/integration/correctness.test.ts 2>&1 | tail -30</verify>
  <done>All correctness tests pass with correct node/edge counts</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `lineage-ui/src/__tests__/integration/correctness.test.ts` exists
2. Running `npm test -- src/__tests__/integration/correctness.test.ts` passes
3. Test file covers requirements CORRECT-VAL-01 through CORRECT-VAL-07
4. No test timeouts or failures
</verification>

<success_criteria>
- Frontend correctly handles cycle patterns in graph data
- Frontend deduplicates nodes in diamond patterns
- Frontend renders all nodes in fan-out patterns
- Frontend renders all nodes in fan-in patterns
- layoutGraph produces correct node/edge counts for all patterns
</success_criteria>

<output>
After completion, create `.planning/phases/16-correctness-validation/16-02-SUMMARY.md`
</output>
