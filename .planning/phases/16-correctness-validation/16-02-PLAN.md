---
phase: 16-correctness-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-ui/src/__tests__/integration/correctness.test.ts
autonomous: true

must_haves:
  truths:
    - "Frontend correctly handles cycle patterns (both single-table and multi-table)"
    - "Frontend deduplicates nodes in diamond patterns"
    - "Frontend renders all nodes in fan-out patterns"
    - "Frontend renders all nodes in fan-in patterns"
    - "Single-table patterns produce 1 table node with multiple columns"
    - "Multi-table patterns produce multiple table nodes"
    - "layoutGraph produces correct node/edge counts for both scenarios"
  artifacts:
    - path: "lineage-ui/src/__tests__/integration/correctness.test.ts"
      provides: "Frontend graph correctness validation tests (single-table and multi-table)"
      min_lines: 350
  key_links:
    - from: "lineage-ui/src/__tests__/integration/correctness.test.ts"
      to: "lineage-ui/src/utils/graph/layoutEngine.ts"
      via: "layoutGraph function calls"
      pattern: "layoutGraph"
---

<objective>
Create frontend integration tests validating graph algorithm correctness with mock data

Purpose: Verify that layoutEngine and groupColumnsByTable correctly handle complex patterns from API responses
Scenarios: Tests both single-table patterns (matching database test data) and multi-table patterns (cross-table lineage)
Output: Vitest test file `lineage-ui/src/__tests__/integration/correctness.test.ts`
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-correctness-validation/16-RESEARCH.md
@lineage-ui/src/utils/graph/layoutEngine.ts
@lineage-ui/src/utils/graph/layoutEngine.test.ts
@lineage-ui/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration directory structure</name>
  <files>lineage-ui/src/__tests__/integration/correctness.test.ts</files>
  <action>
Create the integration test directory and test file:

```bash
mkdir -p lineage-ui/src/__tests__/integration
```

Create `lineage-ui/src/__tests__/integration/correctness.test.ts` with the test structure. This file tests that the frontend graph utilities correctly handle complex patterns.

**Test file structure:**
```typescript
import { describe, it, expect } from 'vitest';
import { layoutGraph, groupByTable } from '../../utils/graph/layoutEngine';
import type { LineageNode, LineageEdge } from '../../types';

/**
 * Phase 16: Correctness Validation Tests
 *
 * These tests validate that the frontend graph utilities correctly handle
 * complex patterns (cycles, diamonds, fans) that may come from the API.
 *
 * Tests TWO scenarios:
 * 1. Single-table patterns (matching database test data from Phase 15)
 * 2. Multi-table patterns (cross-table lineage scenarios)
 *
 * Requirements covered:
 * - CORRECT-VAL-01: Cycle detection (frontend handles cyclic edges)
 * - CORRECT-VAL-02: Diamond deduplication (no duplicate table nodes)
 * - CORRECT-VAL-03: Fan-out completeness (all targets rendered)
 * - CORRECT-VAL-04: Fan-in completeness (all sources rendered)
 * - CORRECT-VAL-06: Node count validation
 * - CORRECT-VAL-07: Edge count validation
 */

// Expected counts for SINGLE-TABLE patterns (matching insert_cte_test_data.py)
const SINGLE_TABLE_COUNTS = {
  CYCLE_2NODE: { columns: 2, edges: 2, tableNodes: 1 },
  CYCLE_5NODE: { columns: 5, edges: 5, tableNodes: 1 },
  DIAMOND_SIMPLE: { columns: 4, edges: 4, tableNodes: 1 },
  DIAMOND_WIDE: { columns: 6, edges: 8, tableNodes: 1 },
  FANOUT_5: { columns: 6, edges: 5, tableNodes: 1 },
  FANIN_5: { columns: 6, edges: 5, tableNodes: 1 },
};

// Expected counts for MULTI-TABLE patterns (cross-table lineage)
const MULTI_TABLE_COUNTS = {
  DIAMOND_SIMPLE: { columns: 4, edges: 4, tableNodes: 4 },
  DIAMOND_WIDE: { columns: 6, edges: 8, tableNodes: 6 },
  FANOUT_5: { columns: 6, edges: 5, tableNodes: 6 },
  FANIN_5: { columns: 6, edges: 5, tableNodes: 6 },
};
```

**Test Categories to implement:**

1. **Single-Table Cycle Tests** (CORRECT-VAL-01):
   - Test 2-node cycle within same table (A->B->A)
   - Test 5-node cycle within same table
   - Verify 1 table node with N columns
   - Verify no infinite loops

2. **Single-Table Diamond Tests** (CORRECT-VAL-02):
   - Test simple diamond within same table
   - Test wide diamond within same table
   - Verify 1 table node with all columns
   - Verify edges preserved

3. **Single-Table Fan Tests** (CORRECT-VAL-03, CORRECT-VAL-04):
   - Test fan-out within same table
   - Test fan-in within same table
   - Verify 1 table node with all source/target columns

4. **Multi-Table Diamond Tests** (CORRECT-VAL-02):
   - Test simple diamond across 4 tables
   - Test wide diamond across 6 tables
   - Verify unique table nodes (no duplicates)
   - Verify all edges preserved

5. **Multi-Table Fan Tests** (CORRECT-VAL-03, CORRECT-VAL-04):
   - Test fan-out across multiple tables
   - Test fan-in across multiple tables
   - Verify all source/target tables present

6. **Node/Edge Count Tests** (CORRECT-VAL-06, CORRECT-VAL-07):
   - For each pattern, assert exact counts
   - Verify no data loss through layout process
   - Test both single-table and multi-table scenarios
  </action>
  <verify>ls -la lineage-ui/src/__tests__/integration/</verify>
  <done>Integration test directory and file structure created</done>
</task>

<task type="auto">
  <name>Task 2: Implement correctness validation tests</name>
  <files>lineage-ui/src/__tests__/integration/correctness.test.ts</files>
  <action>
Implement the full test suite in `lineage-ui/src/__tests__/integration/correctness.test.ts`.

**Test Data Helpers:**
```typescript
// Helper to create node for a column
function createColumnNode(db: string, table: string, column: string): LineageNode {
  return {
    id: `${db}.${table}.${column}`,
    type: 'column',
    databaseName: db,
    tableName: table,
    columnName: column,
  };
}

// Helper to create edge
function createEdge(sourceId: string, targetId: string, transType = 'DIRECT'): LineageEdge {
  return {
    id: `e_${sourceId}_${targetId}`,
    source: sourceId,
    target: targetId,
    transformationType: transType,
  };
}
```

**Test Implementations:**

```typescript
// ============================================================================
// SINGLE-TABLE PATTERN TESTS (matching database test data)
// ============================================================================

describe('CORRECT-VAL-01: Single-Table Cycle Detection', () => {
  it('handles 2-node cycle without infinite loop', async () => {
    // A->B->A (same table)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'CYCLE_TEST', 'col_a'),
      createColumnNode('db', 'CYCLE_TEST', 'col_b'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.CYCLE_TEST.col_a', 'db.CYCLE_TEST.col_b'),
      createEdge('db.CYCLE_TEST.col_b', 'db.CYCLE_TEST.col_a'),
    ];

    // Should complete without timeout/error
    const result = await layoutGraph(nodes, edges);

    // Single table node with 2 columns
    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(2);
    // Both edges preserved (internal to same table)
    expect(result.edges).toHaveLength(2);
  });

  it('handles 5-node cycle without infinite loop', async () => {
    // A->B->C->D->E->A (same table)
    const columns = ['col_a', 'col_b', 'col_c', 'col_d', 'col_e'];
    const nodes = columns.map(c => createColumnNode('db', 'CYCLE5_TEST', c));
    const edges = columns.map((c, i) => {
      const next = columns[(i + 1) % columns.length];
      return createEdge(`db.CYCLE5_TEST.${c}`, `db.CYCLE5_TEST.${next}`);
    });

    const result = await layoutGraph(nodes, edges);

    expect(result.nodes).toHaveLength(1); // Single table
    expect(result.nodes[0].data.columns).toHaveLength(5);
    expect(result.edges).toHaveLength(5);
  });
});

describe('CORRECT-VAL-02: Single-Table Diamond Patterns', () => {
  it('simple diamond within same table produces 1 table node', async () => {
    // A->B->D, A->C->D (same table, matching DIAMOND test data)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'DIAMOND', 'col_a'),
      createColumnNode('db', 'DIAMOND', 'col_b'),
      createColumnNode('db', 'DIAMOND', 'col_c'),
      createColumnNode('db', 'DIAMOND', 'col_d'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.DIAMOND.col_a', 'db.DIAMOND.col_b'),
      createEdge('db.DIAMOND.col_a', 'db.DIAMOND.col_c'),
      createEdge('db.DIAMOND.col_b', 'db.DIAMOND.col_d'),
      createEdge('db.DIAMOND.col_c', 'db.DIAMOND.col_d'),
    ];

    const result = await layoutGraph(nodes, edges);

    // 1 table node with 4 columns
    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(4);
    // All 4 edges preserved (internal to table)
    expect(result.edges).toHaveLength(4);
  });

  it('wide diamond within same table produces 1 table node', async () => {
    // A->B,C,D,E->F (same table, matching WIDE_DIAMOND test data)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'WIDE_DIAMOND', 'col_a'),
      createColumnNode('db', 'WIDE_DIAMOND', 'col_b'),
      createColumnNode('db', 'WIDE_DIAMOND', 'col_c'),
      createColumnNode('db', 'WIDE_DIAMOND', 'col_d'),
      createColumnNode('db', 'WIDE_DIAMOND', 'col_e'),
      createColumnNode('db', 'WIDE_DIAMOND', 'col_f'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.WIDE_DIAMOND.col_a', 'db.WIDE_DIAMOND.col_b'),
      createEdge('db.WIDE_DIAMOND.col_a', 'db.WIDE_DIAMOND.col_c'),
      createEdge('db.WIDE_DIAMOND.col_a', 'db.WIDE_DIAMOND.col_d'),
      createEdge('db.WIDE_DIAMOND.col_a', 'db.WIDE_DIAMOND.col_e'),
      createEdge('db.WIDE_DIAMOND.col_b', 'db.WIDE_DIAMOND.col_f'),
      createEdge('db.WIDE_DIAMOND.col_c', 'db.WIDE_DIAMOND.col_f'),
      createEdge('db.WIDE_DIAMOND.col_d', 'db.WIDE_DIAMOND.col_f'),
      createEdge('db.WIDE_DIAMOND.col_e', 'db.WIDE_DIAMOND.col_f'),
    ];

    const result = await layoutGraph(nodes, edges);

    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(6);
    expect(result.edges).toHaveLength(8);
  });
});

describe('CORRECT-VAL-03: Single-Table Fan-out Patterns', () => {
  it('fan-out 5 within same table produces 1 table node', async () => {
    // 1 source -> 5 targets (same table, matching FANOUT5_TEST)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'FANOUT5_TEST', 'source'),
      createColumnNode('db', 'FANOUT5_TEST', 'target_1'),
      createColumnNode('db', 'FANOUT5_TEST', 'target_2'),
      createColumnNode('db', 'FANOUT5_TEST', 'target_3'),
      createColumnNode('db', 'FANOUT5_TEST', 'target_4'),
      createColumnNode('db', 'FANOUT5_TEST', 'target_5'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.FANOUT5_TEST.source', 'db.FANOUT5_TEST.target_1'),
      createEdge('db.FANOUT5_TEST.source', 'db.FANOUT5_TEST.target_2'),
      createEdge('db.FANOUT5_TEST.source', 'db.FANOUT5_TEST.target_3'),
      createEdge('db.FANOUT5_TEST.source', 'db.FANOUT5_TEST.target_4'),
      createEdge('db.FANOUT5_TEST.source', 'db.FANOUT5_TEST.target_5'),
    ];

    const result = await layoutGraph(nodes, edges);

    // 1 table node with 6 columns
    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(6);
    expect(result.edges).toHaveLength(5);
  });
});

describe('CORRECT-VAL-04: Single-Table Fan-in Patterns', () => {
  it('fan-in 5 within same table produces 1 table node', async () => {
    // 5 sources -> 1 target (same table, matching FANIN5_TEST)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'FANIN5_TEST', 'src_1'),
      createColumnNode('db', 'FANIN5_TEST', 'src_2'),
      createColumnNode('db', 'FANIN5_TEST', 'src_3'),
      createColumnNode('db', 'FANIN5_TEST', 'src_4'),
      createColumnNode('db', 'FANIN5_TEST', 'src_5'),
      createColumnNode('db', 'FANIN5_TEST', 'target'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.FANIN5_TEST.src_1', 'db.FANIN5_TEST.target'),
      createEdge('db.FANIN5_TEST.src_2', 'db.FANIN5_TEST.target'),
      createEdge('db.FANIN5_TEST.src_3', 'db.FANIN5_TEST.target'),
      createEdge('db.FANIN5_TEST.src_4', 'db.FANIN5_TEST.target'),
      createEdge('db.FANIN5_TEST.src_5', 'db.FANIN5_TEST.target'),
    ];

    const result = await layoutGraph(nodes, edges);

    // 1 table node with 6 columns
    expect(result.nodes).toHaveLength(1);
    expect(result.nodes[0].data.columns).toHaveLength(6);
    expect(result.edges).toHaveLength(5);
  });
});

// ============================================================================
// MULTI-TABLE PATTERN TESTS (cross-table lineage)
// ============================================================================

describe('CORRECT-VAL-02: Multi-Table Diamond Deduplication', () => {
  it('simple diamond across 4 tables produces 4 table nodes', async () => {
    // A->B->D, A->C->D (4 different tables)
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'col_a'),
      createColumnNode('db', 't2', 'col_b'),
      createColumnNode('db', 't3', 'col_c'),
      createColumnNode('db', 't4', 'col_d'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.t1.col_a', 'db.t2.col_b'),
      createEdge('db.t1.col_a', 'db.t3.col_c'),
      createEdge('db.t2.col_b', 'db.t4.col_d'),
      createEdge('db.t3.col_c', 'db.t4.col_d'),
    ];

    const result = await layoutGraph(nodes, edges);

    // 4 unique table nodes
    expect(result.nodes).toHaveLength(4);
    // All 4 edges preserved
    expect(result.edges).toHaveLength(4);

    // No duplicate IDs
    const nodeIds = result.nodes.map(n => n.id);
    expect(new Set(nodeIds).size).toBe(nodeIds.length);
  });

  it('wide diamond with 4 middle nodes produces correct counts', async () => {
    // A->B,C,D,E->F
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'col_a'),
      createColumnNode('db', 't2', 'col_b'),
      createColumnNode('db', 't3', 'col_c'),
      createColumnNode('db', 't4', 'col_d'),
      createColumnNode('db', 't5', 'col_e'),
      createColumnNode('db', 't6', 'col_f'),
    ];
    const edges: LineageEdge[] = [
      createEdge('db.t1.col_a', 'db.t2.col_b'),
      createEdge('db.t1.col_a', 'db.t3.col_c'),
      createEdge('db.t1.col_a', 'db.t4.col_d'),
      createEdge('db.t1.col_a', 'db.t5.col_e'),
      createEdge('db.t2.col_b', 'db.t6.col_f'),
      createEdge('db.t3.col_c', 'db.t6.col_f'),
      createEdge('db.t4.col_d', 'db.t6.col_f'),
      createEdge('db.t5.col_e', 'db.t6.col_f'),
    ];

    const result = await layoutGraph(nodes, edges);

    expect(result.nodes).toHaveLength(6);
    expect(result.edges).toHaveLength(8);
  });
});

describe('CORRECT-VAL-03: Multi-Table Fan-out Completeness', () => {
  it('fan-out 5 includes all 5 target nodes', async () => {
    // 1 source -> 5 targets (different tables)
    const nodes: LineageNode[] = [
      createColumnNode('db', 'src', 'source'),
      ...Array.from({ length: 5 }, (_, i) =>
        createColumnNode('db', `tgt${i + 1}`, `target_${i + 1}`)
      ),
    ];
    const edges = Array.from({ length: 5 }, (_, i) =>
      createEdge('db.src.source', `db.tgt${i + 1}.target_${i + 1}`)
    );

    const result = await layoutGraph(nodes, edges);

    // 6 table nodes (1 source + 5 targets)
    expect(result.nodes).toHaveLength(6);
    // 5 edges
    expect(result.edges).toHaveLength(5);

    // Verify all target tables present
    const tableIds = result.nodes.map(n => n.id);
    for (let i = 1; i <= 5; i++) {
      expect(tableIds).toContain(`db.tgt${i}`);
    }
  });
});

describe('CORRECT-VAL-04: Multi-Table Fan-in Completeness', () => {
  it('fan-in 5 includes all 5 source nodes', async () => {
    // 5 sources -> 1 target (different tables)
    const nodes: LineageNode[] = [
      ...Array.from({ length: 5 }, (_, i) =>
        createColumnNode('db', `src${i + 1}`, `source_${i + 1}`)
      ),
      createColumnNode('db', 'tgt', 'target'),
    ];
    const edges = Array.from({ length: 5 }, (_, i) =>
      createEdge(`db.src${i + 1}.source_${i + 1}`, 'db.tgt.target')
    );

    const result = await layoutGraph(nodes, edges);

    // 6 table nodes (5 sources + 1 target)
    expect(result.nodes).toHaveLength(6);
    // 5 edges
    expect(result.edges).toHaveLength(5);

    // Verify all source tables present
    const tableIds = result.nodes.map(n => n.id);
    for (let i = 1; i <= 5; i++) {
      expect(tableIds).toContain(`db.src${i}`);
    }
  });
});

describe('CORRECT-VAL-06 & CORRECT-VAL-07: Node/Edge Counts', () => {
  it('preserves all nodes through layout', async () => {
    // Complex graph with 10 nodes
    const nodes = Array.from({ length: 10 }, (_, i) =>
      createColumnNode('db', `t${i}`, `col${i}`)
    );
    const edges = [
      createEdge('db.t0.col0', 'db.t1.col1'),
      createEdge('db.t0.col0', 'db.t2.col2'),
      createEdge('db.t1.col1', 'db.t3.col3'),
      createEdge('db.t2.col2', 'db.t3.col3'),
      createEdge('db.t3.col3', 'db.t4.col4'),
      createEdge('db.t4.col4', 'db.t5.col5'),
      createEdge('db.t4.col4', 'db.t6.col6'),
      createEdge('db.t5.col5', 'db.t7.col7'),
      createEdge('db.t6.col6', 'db.t7.col7'),
      createEdge('db.t7.col7', 'db.t8.col8'),
      createEdge('db.t8.col8', 'db.t9.col9'),
    ];

    const result = await layoutGraph(nodes, edges);

    // All 10 nodes preserved
    expect(result.nodes).toHaveLength(10);
    // All 11 edges preserved
    expect(result.edges).toHaveLength(11);
  });

  it('groupByTable produces unique keys', () => {
    // Columns from 3 tables
    const nodes: LineageNode[] = [
      createColumnNode('db', 't1', 'a'),
      createColumnNode('db', 't1', 'b'),
      createColumnNode('db', 't2', 'c'),
      createColumnNode('db', 't3', 'd'),
      createColumnNode('db', 't3', 'e'),
      createColumnNode('db', 't3', 'f'),
    ];

    const groups = groupByTable(nodes);

    // 3 unique table groups
    expect(groups.size).toBe(3);
    expect(groups.get('db.t1')?.length).toBe(2);
    expect(groups.get('db.t2')?.length).toBe(1);
    expect(groups.get('db.t3')?.length).toBe(3);
  });
});
```
  </action>
  <verify>cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run src/__tests__/integration/correctness.test.ts 2>&1 | tail -30</verify>
  <done>All correctness tests pass with correct node/edge counts</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `lineage-ui/src/__tests__/integration/correctness.test.ts` exists
2. Running `npm test -- src/__tests__/integration/correctness.test.ts` passes
3. Test file covers requirements CORRECT-VAL-01 through CORRECT-VAL-07
4. No test timeouts or failures
</verification>

<success_criteria>
- Frontend correctly handles cycle patterns (single-table and multi-table)
- Single-table patterns produce 1 table node with N columns
- Multi-table patterns produce N table nodes with 1 column each
- Frontend deduplicates table nodes in diamond patterns
- Frontend renders all nodes in fan-out and fan-in patterns
- layoutGraph produces correct node/edge counts for both scenarios
- No infinite loops or data loss through layout process
</success_criteria>

<output>
After completion, create `.planning/phases/16-correctness-validation/16-02-SUMMARY.md`
</output>
