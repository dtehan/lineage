---
phase: 13-graph-loading-experience
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - lineage-ui/src/utils/graph/layoutEngine.ts
  - lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
autonomous: true

must_haves:
  truths:
    - "User sees progress indicator when lineage request starts"
    - "Progress advances through data fetch, layout, and render stages"
    - "Progress indicator disappears when graph is interactive"
    - "No frozen states during loading"
  artifacts:
    - path: "lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx"
      provides: "Integrated loading progress in graph component"
      contains: "LoadingProgress"
    - path: "lineage-ui/src/utils/graph/layoutEngine.ts"
      provides: "Layout function with progress callback"
      contains: "onProgress"
  key_links:
    - from: "LineageGraph.tsx"
      to: "useLoadingProgress"
      via: "hook manages loading state"
      pattern: "useLoadingProgress"
    - from: "LineageGraph.tsx"
      to: "layoutGraph"
      via: "passes progress callback"
      pattern: "onProgress"
    - from: "LineageGraph.tsx"
      to: "LoadingProgress"
      via: "renders progress component"
      pattern: "<LoadingProgress"
---

<objective>
Integrate the loading progress system into LineageGraph component, replacing the spinner with a progress bar that tracks all three loading stages.

Purpose: Users see visual feedback during graph loading with progress percentage and stage text, eliminating the perception of frozen or unresponsive states.

Output: LineageGraph shows LoadingProgress component that advances through "Loading data...", "Calculating layout...", and "Rendering..." stages with smooth progress bar transitions.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
@lineage-ui/src/utils/graph/layoutEngine.ts
@lineage-ui/src/hooks/useLoadingProgress.ts (from Plan 01)
@lineage-ui/src/components/common/LoadingProgress.tsx (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress callback to layoutGraph</name>
  <files>
    lineage-ui/src/utils/graph/layoutEngine.ts
  </files>
  <action>
Modify the layoutGraph function to accept an optional progress callback:

1. Add `onProgress?: (progress: number) => void` to the `LayoutOptions` interface

2. In `layoutGraph()` function, call the progress callback at key points:
   - After groupColumnsByTable: `onProgress?.(35)` (entered layout stage)
   - After transformToTableNodes: `onProgress?.(45)` (data transformed)
   - After building elkGraph but before elk.layout: `onProgress?.(55)` (graph built)
   - After elk.layout resolves: `onProgress?.(70)` (layout complete, entering render)

3. In `layoutSimpleNodes()` fallback function, add same callback pattern:
   - After building elkNodes: `onProgress?.(45)`
   - After elk.layout resolves: `onProgress?.(70)`

The callback is optional to maintain backward compatibility with existing callers.
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` - no TypeScript errors
  </verify>
  <done>
    layoutGraph accepts optional onProgress callback and reports progress at key computation points
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate loading progress into LineageGraph</name>
  <files>
    lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
  </files>
  <action>
Replace the simple LoadingSpinner with the new LoadingProgress system:

1. Import the new hook and component:
   - `import { useLoadingProgress } from '../../../hooks/useLoadingProgress';`
   - `import { LoadingProgress } from '../../common/LoadingProgress';`
   - Remove: `import { LoadingSpinner } from '../../common/LoadingSpinner';`

2. In `LineageGraphInner`, add the loading progress hook after existing hooks:
   ```typescript
   const { stage, progress, message, isLoading: isProgressLoading, setStage, setProgress, reset } = useLoadingProgress();
   ```

3. Coordinate loading stages:

   a) Data fetch stage - use useEffect to sync with TanStack Query:
   ```typescript
   useEffect(() => {
     if (isLoading) {
       setStage('fetching');
     }
   }, [isLoading, setStage]);
   ```

   b) Layout stage - modify the existing useEffect that calls layoutGraph (around line 133):
   ```typescript
   useEffect(() => {
     if (data?.graph) {
       setStage('layout');

       const { nodes: legacyNodes, edges: legacyEdges } = convertOpenLineageGraph(
         data.graph.nodes,
         data.graph.edges
       );

       layoutGraph(legacyNodes, legacyEdges, {
         onProgress: (layoutProgress) => setProgress(layoutProgress),
       })
         .then(({ nodes: layoutedNodes, edges: layoutedEdges }) => {
           setStage('rendering');
           setNodes(layoutedNodes);
           setEdges(layoutedEdges);
           setGraph(legacyNodes, legacyEdges);
           // Use requestAnimationFrame to detect render complete
           requestAnimationFrame(() => {
             requestAnimationFrame(() => {
               setStage('complete');
             });
           });
         })
         .catch((error) => {
           console.error('Layout error:', error);
           setGraph(legacyNodes, legacyEdges);
           setStage('complete');
         });
     }
   }, [data, setNodes, setEdges, setGraph, setStage, setProgress]);
   ```

4. Replace the loading spinner block (around line 298-304):

   Before:
   ```typescript
   if (isLoading) {
     return (
       <div className="flex items-center justify-center h-full">
         <LoadingSpinner size="lg" />
       </div>
     );
   }
   ```

   After:
   ```typescript
   // Show progress during any loading stage (fetching, layout, or rendering)
   const showProgress = isLoading || (stage !== 'idle' && stage !== 'complete');

   if (showProgress) {
     return (
       <div className="flex items-center justify-center h-full">
         <LoadingProgress progress={progress} message={message} size="lg" />
       </div>
     );
   }
   ```

5. Reset loading state when datasetId changes:
   ```typescript
   useEffect(() => {
     reset();
   }, [datasetId, reset]);
   ```

The key is coordinating the three stages:
- fetching: TanStack Query `isLoading` is true (0-30%)
- layout: Data received, ELK computing (30-70%)
- rendering: Layout done, React Flow updating (70-95%)
- complete: Graph interactive (100%, then hide)
  </action>
  <verify>
    Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm run dev` and navigate to a lineage graph - observe progress bar advancing through stages
  </verify>
  <done>
    LineageGraph shows LoadingProgress that advances through all three stages with smooth transitions
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors:
```bash
cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit
```

2. Manual verification - start dev server and test:
```bash
cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm run dev
```
- Navigate to any table's lineage view
- Observe: Progress bar appears immediately
- Observe: Stage text shows "Loading data..." then "Calculating layout..." then "Rendering..."
- Observe: Progress bar advances smoothly
- Observe: Progress indicator disappears when graph is interactive

3. Existing tests still pass:
```bash
cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run
```
</verification>

<success_criteria>
1. User sees progress bar (0-100%) during graph loading
2. User sees text indicating current stage (data fetch, layout calculation, rendering)
3. Progress indicator appears immediately when lineage request starts
4. Progress indicator disappears when graph is interactive
5. Loading experience feels responsive (no frozen states)
6. TypeScript compiles without errors
7. Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-graph-loading-experience/13-02-SUMMARY.md`
</output>
