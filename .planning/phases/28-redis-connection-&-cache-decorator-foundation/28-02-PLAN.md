---
phase: 28-redis-connection-cache-decorator-foundation
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
  - lineage-api/internal/domain/mocks/repositories.go
autonomous: true

must_haves:
  truths:
    - "A lineage graph query returns data from Redis cache on the second call without hitting the inner repository"
    - "A cache miss falls through to the inner Teradata repository and populates the cache"
    - "Cache errors (GET or SET) are logged and swallowed -- they never cause API errors"
    - "The decorator implements all 15 methods of domain.OpenLineageRepository"
    - "Uncached methods delegate directly to the inner repository with zero overhead"
    - "Cache key includes datasetID, fieldName, and direction but NOT depth"
    - "nil results from the inner repository are NOT cached"
    - "JSON round-trip preserves domain entity structure (nodes, edges, metadata)"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      provides: "CachedOpenLineageRepository decorator"
      exports: ["CachedOpenLineageRepository", "NewCachedOpenLineageRepository"]
      min_lines: 60
    - path: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go"
      provides: "Unit tests for cache decorator"
      min_lines: 100
    - path: "lineage-api/internal/domain/mocks/repositories.go"
      provides: "Updated MockCacheRepository with JSON round-trip support"
      contains: "json.Marshal"
  key_links:
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      to: "domain.OpenLineageRepository"
      via: "interface embedding"
      pattern: "domain\\.OpenLineageRepository"
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      to: "domain.CacheRepository"
      via: "cache.Get and cache.Set calls"
      pattern: "r\\.cache\\.(Get|Set)"
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go"
      to: "mocks.MockCacheRepository"
      via: "test setup with mock cache"
      pattern: "mocks\\.NewMockCacheRepository"
---

<objective>
Implement CachedOpenLineageRepository decorator with cache-aside pattern for GetColumnLineageGraph and GetDataset, plus comprehensive unit tests.

Purpose: This is the core caching logic. The decorator wraps the Teradata OpenLineageRepository, checks Redis before querying Teradata, and populates cache on miss. It implements all 15 methods of domain.OpenLineageRepository -- only GetColumnLineageGraph and GetDataset are cached, the other 13 delegate directly to the inner repository.

Output: New cached_openlineage_repo.go with decorator, new cached_openlineage_repo_test.go with tests, updated MockCacheRepository with JSON round-trip support for proper testing.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-redis-connection-&-cache-decorator-foundation/28-CONTEXT.md
@.planning/phases/28-redis-connection-&-cache-decorator-foundation/28-RESEARCH.md
@.planning/phases/28-redis-connection-&-cache-decorator-foundation/28-01-SUMMARY.md

Key source files:
@lineage-api/internal/domain/repository.go
@lineage-api/internal/domain/entities.go
@lineage-api/internal/adapter/outbound/redis/cache.go
@lineage-api/internal/domain/mocks/repositories.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade MockCacheRepository for JSON round-trip</name>
  <files>lineage-api/internal/domain/mocks/repositories.go</files>
  <action>
Update the `MockCacheRepository` in `internal/domain/mocks/repositories.go` to support real JSON marshal/unmarshal round-trips. The current implementation stores `[]byte("cached")` on Set and returns nil on Get (without actually deserializing data into `dest`). This is insufficient for testing the cache decorator because the decorator needs `cache.Get()` to populate the `dest` pointer with real domain data.

Changes to `MockCacheRepository`:

1. **`Set` method:** Replace `m.Data[key] = []byte("cached")` with actual JSON marshaling:
   ```go
   data, err := json.Marshal(value)
   if err != nil {
       return err
   }
   m.Data[key] = data
   ```

2. **`Get` method:** Replace the "just return nil if key exists" with actual JSON unmarshaling:
   ```go
   data, exists := m.Data[key]
   if !exists {
       return ErrCacheMiss
   }
   return json.Unmarshal(data, dest)
   ```

3. **Add import:** Add `"encoding/json"` to the import block.

Keep all other MockCacheRepository behavior unchanged: error injection fields, call tracking (GetCalls, SetCalls, DeleteCalls), mutex usage.

WHY this matters: Without real JSON round-trip, decorator tests cannot verify that cached data deserializes correctly. The research identified Pitfall 3 (JSON round-trip differences for map[string]any) which can only be caught with real serialization.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go vet ./internal/domain/mocks/...` -- must pass.
Existing tests that use MockCacheRepository must still pass: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/... -run TestNoOp -count=1` (NoOpCache tests are in the redis package, not using the mock, so they should be unaffected).
  </verify>
  <done>MockCacheRepository.Get deserializes JSON into dest. MockCacheRepository.Set serializes value as JSON. Existing tests unaffected.</done>
</task>

<task type="auto">
  <name>Task 2: Implement CachedOpenLineageRepository decorator</name>
  <files>lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go</files>
  <action>
Create `internal/adapter/outbound/redis/cached_openlineage_repo.go` implementing the cache-aside decorator.

**Structure:**
```go
package redis

import (
    "context"
    "fmt"
    "log/slog"

    "github.com/lineage-api/internal/domain"
)
```

**CachedOpenLineageRepository struct:**
- Embed `domain.OpenLineageRepository` (inner repo -- all 13 uncached methods auto-delegate)
- `cache domain.CacheRepository` field
- `ttl int` field (TTL in seconds)

**Compile-time interface check:**
```go
var _ domain.OpenLineageRepository = (*CachedOpenLineageRepository)(nil)
```

**Constructor:**
```go
func NewCachedOpenLineageRepository(
    inner domain.OpenLineageRepository,
    cache domain.CacheRepository,
    ttl int,
) *CachedOpenLineageRepository
```

**Cached method 1: GetColumnLineageGraph**

Cache-aside pattern:
1. Build cache key: `ol:lineage:graph:{datasetID}:{fieldName}:{direction}`
   - Depth is NOT in the key (per CONTEXT.md decision)
   - Direction IS in the key (upstream/downstream/both produce different graphs)
2. Try `r.cache.Get(ctx, key, &cached)` -- if err == nil, return cached (cache HIT)
3. On any error (cache miss OR Redis error): fall through to inner repo
   - Do NOT log cache misses at warn level (they are normal). Use Debug level.
4. Call `r.OpenLineageRepository.GetColumnLineageGraph(ctx, datasetID, fieldName, direction, maxDepth)`
5. If err != nil: return the error (do NOT cache errors)
6. If result is nil: return nil (do NOT cache nil results)
7. Call `r.cache.Set(ctx, key, graph, r.ttl)` -- if Set fails, log at Warn level and swallow the error
8. Return the graph

**Cached method 2: GetDataset**

Same cache-aside pattern:
1. Cache key: `ol:dataset:{datasetID}`
2. Try cache.Get -> fall through on error
3. Call inner repo -> return error if any -> skip nil results
4. cache.Set with fire-and-forget error handling
5. Return result

**Logging guidance:**
- Cache HIT: `slog.DebugContext(ctx, "cache hit", "key", key)`
- Cache MISS (Get returned error): `slog.DebugContext(ctx, "cache miss", "key", key)` -- do NOT log the error itself at debug level, it's just redis.Nil most of the time
- Cache SET success: `slog.DebugContext(ctx, "cache populated", "key", key, "ttl", r.ttl)`
- Cache SET failure: `slog.WarnContext(ctx, "cache set failed", "key", key, "error", setErr)`

**All other methods (13 total):** Do NOT override. The embedded `domain.OpenLineageRepository` handles them via Go's interface embedding delegation. This means GetNamespace, GetNamespaceByURI, ListNamespaces, ListDatasets, SearchDatasets, GetField, ListFields, GetJob, ListJobs, GetRun, ListRuns, GetColumnLineage, GetDatasetStatistics, GetDatasetDDL all pass through to the inner repo with zero caching overhead.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go vet ./internal/adapter/outbound/redis/...` -- must pass.
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./cmd/server/` -- must compile successfully (main.go from 28-01 references NewCachedOpenLineageRepository which now exists).
  </verify>
  <done>CachedOpenLineageRepository implements domain.OpenLineageRepository. GetColumnLineageGraph and GetDataset use cache-aside. 13 other methods delegate via embedding. Project compiles.</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for cache decorator</name>
  <files>lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go</files>
  <action>
Create `internal/adapter/outbound/redis/cached_openlineage_repo_test.go` with comprehensive tests using MockOpenLineageRepository and MockCacheRepository (both from `domain/mocks`).

**Test helper setup:**
Create a helper that returns `(*CachedOpenLineageRepository, *mocks.MockOpenLineageRepository, *mocks.MockCacheRepository)` for clean test setup.

**Required test cases for GetColumnLineageGraph:**

1. **TestCachedGetColumnLineageGraph_CacheMiss_PopulatesCache**
   - MockCache has no data for key
   - MockInner has graph data at `"42/customer_id"` key in GraphData map (matching how MockOpenLineageRepository.GetColumnLineageGraph looks up data: `datasetID + "/" + fieldName`)
   - Call decorator.GetColumnLineageGraph(ctx, "42", "customer_id", "both", 5)
   - Assert: result is not nil, has expected nodes/edges
   - Assert: MockCache.SetCalls has 1 entry with key "ol:lineage:graph:42:customer_id:both"
   - Assert: MockCache.GetCalls has 1 entry (the miss)

2. **TestCachedGetColumnLineageGraph_CacheHit_SkipsInner**
   - Pre-populate MockCache with a graph at key "ol:lineage:graph:42:customer_id:upstream"
   - Do NOT put any data in MockInner (to prove inner is not called)
   - Call decorator.GetColumnLineageGraph(ctx, "42", "customer_id", "upstream", 5)
   - Assert: result matches the pre-populated cached data
   - Assert: MockCache.GetCalls has 1 entry
   - Assert: MockCache.SetCalls is empty (no set on hit)

3. **TestCachedGetColumnLineageGraph_InnerError_NotCached**
   - Set MockInner.GetColumnLineageGraphErr to an error
   - Call decorator
   - Assert: error returned
   - Assert: MockCache.SetCalls is empty (errors not cached)

4. **TestCachedGetColumnLineageGraph_NilResult_NotCached**
   - MockInner returns nil graph (no data in GraphData map for the requested key -- but note MockOpenLineageRepository returns an empty graph `{Nodes: [], Edges: []}` by default, NOT nil. So to test nil caching, set a specific GraphData entry to nil: `mockInner.GraphData["42/customer_id"] = nil` -- BUT actually the mock returns the pointer from the map, so if you set it to nil, it returns nil. Alternatively, test that empty graphs ARE cached since the mock returns a non-nil empty graph.)
   - Revised approach: Test that a non-nil empty graph IS cached (because it's a valid result). Test that when inner returns nil (via setting GraphData key to nil), the nil is NOT cached.

5. **TestCachedGetColumnLineageGraph_CacheSetError_Swallowed**
   - Set MockCache.SetErr to an error
   - MockInner has valid graph data
   - Call decorator
   - Assert: result returned successfully (no error to caller)
   - Assert: MockCache.SetCalls has 1 entry (attempted)

6. **TestCachedGetColumnLineageGraph_CacheGetError_FallsThrough**
   - Set MockCache.GetErr to an error (simulates Redis being down for reads)
   - MockInner has valid graph data
   - Call decorator
   - Assert: result returned successfully from inner
   - Assert: cache.Set was called (to re-populate)

7. **TestCachedGetColumnLineageGraph_DepthNotInKey**
   - Call with depth=3 and depth=10 for same datasetID/fieldName/direction
   - Assert: both calls produce the same cache key (depth is excluded)

8. **TestCachedGetColumnLineageGraph_DirectionInKey**
   - Call with direction "upstream" vs "downstream" for same datasetID/fieldName
   - Assert: different cache keys produced

**Required test cases for GetDataset:**

9. **TestCachedGetDataset_CacheMiss_PopulatesCache**
   - Similar to graph test: miss -> inner -> set
   - Assert key format: "ol:dataset:42"

10. **TestCachedGetDataset_CacheHit_SkipsInner**
    - Pre-populate cache, verify inner not called

**Required test case for delegation:**

11. **TestCachedRepo_UncachedMethods_DelegateToInner**
    - Call ListNamespaces, ListDatasets, SearchDatasets on the decorator
    - Assert: results come from MockInner (proving delegation works)
    - Assert: no cache.Get or cache.Set calls (proving no caching)

**Required test case for JSON round-trip:**

12. **TestCachedGetColumnLineageGraph_JSONRoundTrip**
    - Create a graph with realistic data: nodes with Metadata map, edges with enum types, timestamps
    - Store via decorator (cache miss -> inner -> set)
    - Retrieve via decorator (cache hit -> get)
    - Assert: round-tripped graph matches original (use assert.Equal)
    - This validates that JSON serialization preserves the domain entity structure

**Test data pattern:**
```go
testGraph := &domain.OpenLineageGraph{
    Nodes: []domain.OpenLineageNode{
        {ID: "n1", Type: "field", Namespace: "teradata://host:1025", Dataset: "db.table1", Field: "col_a"},
        {ID: "n2", Type: "field", Namespace: "teradata://host:1025", Dataset: "db.table2", Field: "col_b"},
    },
    Edges: []domain.OpenLineageEdge{
        {ID: "e1", Source: "n1", Target: "n2", TransformationType: domain.TransformationDirect, TransformationSubtype: domain.SubtypeIdentity, ConfidenceScore: 0.95},
    },
}
```
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/outbound/redis/... -v -count=1` -- all tests must pass.
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/... -count=1` -- full test suite must pass (no regressions).
Run: `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./cmd/server/` -- project must compile.
  </verify>
  <done>12+ test cases covering cache hit, cache miss, error handling, key structure, JSON round-trip, and delegation. All tests pass. Full test suite has no regressions. Project compiles end-to-end.</done>
</task>

</tasks>

<verification>
1. `go build ./cmd/server/` compiles successfully -- main.go references NewCachedOpenLineageRepository which now exists
2. `go test ./internal/adapter/outbound/redis/... -v` -- all decorator tests pass
3. `go test ./internal/... -count=1` -- full test suite passes with no regressions
4. `go vet ./...` -- no issues
5. Cache key for lineage: `ol:lineage:graph:{datasetID}:{fieldName}:{direction}` (no depth)
6. Cache key for dataset: `ol:dataset:{datasetID}`
7. GetColumnLineageGraph and GetDataset use cache-aside pattern
8. 13 other OpenLineageRepository methods delegate directly (no caching)
9. Cache errors never propagate as return errors
10. nil results from inner repo are not cached
</verification>

<success_criteria>
1. CachedOpenLineageRepository exists and implements domain.OpenLineageRepository (compile-time check)
2. GetColumnLineageGraph returns cached data on second call without hitting inner repository
3. GetDataset returns cached data on second call without hitting inner repository
4. Cache errors are logged and swallowed -- never returned to callers
5. nil and error results from inner repo are not cached
6. Depth is not in cache key, direction is
7. MockCacheRepository supports JSON round-trip for realistic testing
8. 12+ unit tests pass covering hit/miss/error/delegation/round-trip scenarios
9. Full project compiles and all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/28-redis-connection-&-cache-decorator-foundation/28-02-SUMMARY.md`
</output>
