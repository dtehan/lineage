---
phase: 08-open-lineage-standard-alignment
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - database/populate_lineage.py
  - database/db_config.py
autonomous: true

must_haves:
  truths:
    - "populate_lineage.py can populate OL_* tables with --openlineage flag"
    - "Namespace is generated using teradata://{host}:{port} format from config"
    - "Dataset names follow database.table format"
    - "Field names match column_name from existing metadata"
    - "Transformation types are mapped to OpenLineage DIRECT/INDIRECT with subtypes"
    - "Existing LIN_* population still works without flags"
  artifacts:
    - path: "database/populate_lineage.py"
      provides: "OpenLineage data population logic"
      contains: "OL_COLUMN_LINEAGE"
    - path: "database/db_config.py"
      provides: "Host/port for namespace generation"
      contains: "TERADATA_HOST"
  key_links:
    - from: "database/populate_lineage.py"
      to: "OL_* tables"
      via: "INSERT statements"
      pattern: "INSERT INTO demo_user\\.OL_"
---

<objective>
Update populate_lineage.py to write lineage data to OpenLineage-aligned OL_* tables.

Purpose: Enable the data population pipeline to write to the new OpenLineage schema while maintaining backward compatibility with existing LIN_* tables.

Output: Updated populate_lineage.py with --openlineage flag that populates OL_NAMESPACE, OL_DATASET, OL_DATASET_FIELD, and OL_COLUMN_LINEAGE tables.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-open-lineage-standard-alignment/08-RESEARCH.md
@.planning/phases/08-open-lineage-standard-alignment/08-01-SUMMARY.md
@database/populate_lineage.py
@database/db_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add namespace generation utility</name>
  <files>database/db_config.py</files>
  <action>
Add a function to generate OpenLineage namespace URI from config:

```python
def get_openlineage_namespace():
    """Generate OpenLineage namespace URI from Teradata connection config.

    Format: teradata://{host}:{port}
    Example: teradata://demo.teradata.com:1025
    """
    host = CONFIG.get('host', 'localhost')
    # Default Teradata port is 1025
    port = CONFIG.get('port', 1025)
    return f"teradata://{host}:{port}"
```

Ensure the CONFIG dict includes the 'port' key (default 1025) if not already present.
  </action>
  <verify>Import db_config and call get_openlineage_namespace() to verify it returns a valid teradata:// URI.</verify>
  <done>get_openlineage_namespace() function exists and returns teradata://{host}:{port} format.</done>
</task>

<task type="auto">
  <name>Task 2: Add transformation type mapping</name>
  <files>database/populate_lineage.py</files>
  <action>
Add the OpenLineage transformation type mapping at module level:

```python
# OpenLineage transformation type mapping
# Maps current transformation types to (OL_type, OL_subtype)
OPENLINEAGE_TRANSFORMATION_MAPPING = {
    "DIRECT": ("DIRECT", "IDENTITY"),
    "CALCULATION": ("DIRECT", "TRANSFORMATION"),
    "AGGREGATION": ("DIRECT", "AGGREGATION"),
    "JOIN": ("INDIRECT", "JOIN"),
    "FILTER": ("INDIRECT", "FILTER"),
}

def map_transformation_type(current_type: str) -> tuple:
    """Map current transformation type to OpenLineage (type, subtype) tuple."""
    return OPENLINEAGE_TRANSFORMATION_MAPPING.get(
        current_type.upper(),
        ("DIRECT", "TRANSFORMATION")  # Default for unknown types
    )
```

Also update the import to include get_openlineage_namespace:
```python
from db_config import CONFIG, get_openlineage_namespace
```
  </action>
  <verify>Read the file and verify OPENLINEAGE_TRANSFORMATION_MAPPING dict and map_transformation_type function exist.</verify>
  <done>Transformation type mapping exists with all 5 current types mapped to OpenLineage equivalents.</done>
</task>

<task type="auto">
  <name>Task 3: Add OpenLineage data extraction functions</name>
  <files>database/populate_lineage.py</files>
  <action>
Add functions to extract and populate OL_* tables:

```python
def generate_namespace_id(namespace_uri: str) -> str:
    """Generate a stable namespace ID from URI."""
    return hashlib.md5(namespace_uri.encode()).hexdigest()[:16]

def generate_dataset_id(namespace_id: str, database: str, table: str) -> str:
    """Generate dataset ID in format: namespace_id/database.table"""
    return f"{namespace_id}/{database}.{table}"

def generate_field_id(dataset_id: str, field_name: str) -> str:
    """Generate field ID in format: dataset_id/field_name"""
    return f"{dataset_id}/{field_name}"

def populate_openlineage_namespace(cursor, namespace_uri: str):
    """Create or get the namespace entry."""
    namespace_id = generate_namespace_id(namespace_uri)

    # Check if exists
    cursor.execute("""
        SELECT namespace_id FROM demo_user.OL_NAMESPACE
        WHERE namespace_id = ?
    """, (namespace_id,))

    if not cursor.fetchone():
        cursor.execute("""
            INSERT INTO demo_user.OL_NAMESPACE
            (namespace_id, namespace_uri, description, spec_version, created_at)
            VALUES (?, ?, ?, '2-0-2', CURRENT_TIMESTAMP)
        """, (namespace_id, namespace_uri, f"Teradata instance at {namespace_uri}"))
        print(f"  Created namespace: {namespace_uri}")

    return namespace_id

def populate_openlineage_datasets(cursor, namespace_id: str):
    """Populate OL_DATASET from LIN_TABLE."""
    print("\n--- Populating OL_DATASET from tables ---")

    # Get distinct databases and tables from LIN_TABLE
    cursor.execute("""
        SELECT database_name, table_name, table_kind, comment_string, extracted_at
        FROM demo_user.LIN_TABLE
        WHERE is_active = 'Y'
    """)

    rows = cursor.fetchall()
    count = 0
    for row in rows:
        db_name, tbl_name, tbl_kind, comment, extracted_at = row
        dataset_name = f"{db_name}.{tbl_name}"
        dataset_id = generate_dataset_id(namespace_id, db_name, tbl_name)
        source_type = 'VIEW' if tbl_kind == 'V' else 'TABLE'

        try:
            cursor.execute("""
                INSERT INTO demo_user.OL_DATASET
                (dataset_id, namespace_id, name, description, source_type, created_at, updated_at, is_active)
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, 'Y')
            """, (dataset_id, namespace_id, dataset_name, comment, source_type, extracted_at))
            count += 1
        except Exception as e:
            if "duplicate" not in str(e).lower():
                print(f"  Warning: {dataset_name}: {e}")

    print(f"  Created {count} datasets")
    return count

def populate_openlineage_fields(cursor, namespace_id: str):
    """Populate OL_DATASET_FIELD from LIN_COLUMN."""
    print("\n--- Populating OL_DATASET_FIELD from columns ---")

    cursor.execute("""
        SELECT database_name, table_name, column_name, column_type,
               nullable, comment_string, column_position, extracted_at
        FROM demo_user.LIN_COLUMN
        WHERE is_active = 'Y'
    """)

    rows = cursor.fetchall()
    count = 0
    for row in rows:
        db_name, tbl_name, col_name, col_type, nullable, comment, position, extracted_at = row
        dataset_id = generate_dataset_id(namespace_id, db_name, tbl_name)
        field_id = generate_field_id(dataset_id, col_name)

        try:
            cursor.execute("""
                INSERT INTO demo_user.OL_DATASET_FIELD
                (field_id, dataset_id, field_name, field_type, field_description,
                 ordinal_position, nullable, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (field_id, dataset_id, col_name, col_type, comment, position, nullable, extracted_at))
            count += 1
        except Exception as e:
            if "duplicate" not in str(e).lower():
                pass  # Skip duplicate errors silently for fields

    print(f"  Created {count} fields")
    return count

def populate_openlineage_lineage(cursor, namespace_id: str, namespace_uri: str):
    """Populate OL_COLUMN_LINEAGE from manual mappings."""
    print("\n--- Populating OL_COLUMN_LINEAGE ---")

    insert_sql = """
        INSERT INTO demo_user.OL_COLUMN_LINEAGE
        (lineage_id, run_id, source_namespace, source_dataset, source_field,
         target_namespace, target_dataset, target_field,
         transformation_type, transformation_subtype, transformation_description,
         confidence_score, discovered_at, is_active)
        VALUES (?, NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, 'Y')
    """

    count = 0
    for src, tgt, trans_type, confidence in COLUMN_LINEAGE_MAPPINGS:
        src_parts = src.split(".")
        tgt_parts = tgt.split(".")

        lineage_id = generate_lineage_id(src, tgt)
        ol_type, ol_subtype = map_transformation_type(trans_type)

        source_dataset = f"{src_parts[0]}.{src_parts[1]}"
        target_dataset = f"{tgt_parts[0]}.{tgt_parts[1]}"

        try:
            cursor.execute(insert_sql, (
                lineage_id,
                namespace_uri,
                source_dataset,
                src_parts[2],  # source_field
                namespace_uri,
                target_dataset,
                tgt_parts[2],  # target_field
                ol_type,
                ol_subtype,
                f"Mapped from {trans_type}",
                confidence
            ))
            count += 1
        except Exception as e:
            if "duplicate" not in str(e).lower():
                print(f"  Warning: {src}->{tgt}: {e}")

    print(f"  Created {count} lineage records")
    return count
```
  </action>
  <verify>Read the file and verify all 6 functions exist: generate_namespace_id, generate_dataset_id, generate_field_id, populate_openlineage_namespace, populate_openlineage_datasets, populate_openlineage_fields, populate_openlineage_lineage.</verify>
  <done>All OpenLineage population functions exist with proper namespace, dataset, field, and lineage handling.</done>
</task>

<task type="auto">
  <name>Task 4: Update main() to support --openlineage flag</name>
  <files>database/populate_lineage.py</files>
  <action>
Update the argparse and main() function:

1. Add --openlineage flag:
```python
parser.add_argument(
    "--openlineage", "-o",
    action="store_true",
    help="Also populate OpenLineage OL_* tables"
)
```

2. After the existing LIN_* population, add OpenLineage population when flag is present:
```python
# Populate OpenLineage tables if flag is set
if args.openlineage:
    namespace_uri = get_openlineage_namespace()
    print(f"\n--- Populating OpenLineage tables ---")
    print(f"  Namespace: {namespace_uri}")

    namespace_id = populate_openlineage_namespace(cursor, namespace_uri)
    populate_openlineage_datasets(cursor, namespace_id)
    populate_openlineage_fields(cursor, namespace_id)
    populate_openlineage_lineage(cursor, namespace_id, namespace_uri)

    # Verify OL_* data
    print("\n--- Verifying OpenLineage data ---")
    for table in ["OL_NAMESPACE", "OL_DATASET", "OL_DATASET_FIELD", "OL_COLUMN_LINEAGE"]:
        try:
            cursor.execute(f"SELECT COUNT(*) FROM demo_user.{table}")
            count = cursor.fetchone()[0]
            print(f"  {table}: {count} rows")
        except Exception as e:
            print(f"  {table}: ERROR - {e}")
```

3. Update the mode display at start:
```python
if args.openlineage:
    print("  (with OpenLineage table population)")
```
  </action>
  <verify>Run `python database/populate_lineage.py --help` and verify --openlineage flag is documented.</verify>
  <done>populate_lineage.py accepts --openlineage flag and populates OL_* tables when used.</done>
</task>

</tasks>

<verification>
1. Syntax check: `python -m py_compile database/populate_lineage.py`
2. Syntax check: `python -m py_compile database/db_config.py`
3. Help check: `python database/populate_lineage.py --help` shows --openlineage flag
4. Code review: Verify transformation mapping covers all 5 types (DIRECT, CALCULATION, AGGREGATION, JOIN, FILTER)
5. Code review: Verify namespace URI format is teradata://{host}:{port}
</verification>

<success_criteria>
- populate_lineage.py compiles without syntax errors
- Running with --openlineage flag populates OL_* tables
- Namespace is generated in teradata://{host}:{port} format
- Transformation types are correctly mapped (e.g., CALCULATION -> DIRECT/TRANSFORMATION)
- Backward compatibility: Running without --openlineage still works
</success_criteria>

<output>
After completion, create `.planning/phases/08-open-lineage-standard-alignment/08-02-SUMMARY.md`
</output>
