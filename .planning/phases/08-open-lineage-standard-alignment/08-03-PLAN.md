---
phase: 08-open-lineage-standard-alignment
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - lineage-api/internal/domain/entities.go
  - lineage-api/internal/domain/repository.go
autonomous: true

must_haves:
  truths:
    - "OpenLineage domain entities exist (Namespace, Dataset, DatasetField, Job, Run)"
    - "ColumnLineage entity has OpenLineage-aligned fields (Type, Subtype, SourceNamespace, etc.)"
    - "Repository interfaces include methods for OL_* table queries"
    - "Transformation types use DIRECT/INDIRECT enum constants"
    - "Existing entities remain unchanged for backward compatibility"
  artifacts:
    - path: "lineage-api/internal/domain/entities.go"
      provides: "OpenLineage domain entities"
      contains: "OpenLineageNamespace"
    - path: "lineage-api/internal/domain/repository.go"
      provides: "OpenLineage repository interfaces"
      contains: "OpenLineageRepository"
  key_links:
    - from: "lineage-api/internal/domain/entities.go"
      to: "OL_* database tables"
      via: "db struct tags"
      pattern: "db:\".*_namespace\""
---

<objective>
Update Go domain layer to add OpenLineage-aligned entities and repository interfaces.

Purpose: Define the domain model that maps to the new OL_* database tables, enabling the backend to work with OpenLineage-compliant data structures.

Output: Updated entities.go with new entity types and repository.go with new interface methods.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-open-lineage-standard-alignment/08-RESEARCH.md
@.planning/phases/08-open-lineage-standard-alignment/08-01-SUMMARY.md
@lineage-api/internal/domain/entities.go
@lineage-api/internal/domain/repository.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OpenLineage entity types to entities.go</name>
  <files>lineage-api/internal/domain/entities.go</files>
  <action>
Add new entity types for OpenLineage-aligned tables. Place these after the existing entity types but before the Graph types:

```go
// OpenLineage transformation types
type TransformationType string

const (
    TransformationDirect   TransformationType = "DIRECT"
    TransformationIndirect TransformationType = "INDIRECT"
)

// OpenLineage transformation subtypes
type TransformationSubtype string

const (
    SubtypeIdentity       TransformationSubtype = "IDENTITY"
    SubtypeTransformation TransformationSubtype = "TRANSFORMATION"
    SubtypeAggregation    TransformationSubtype = "AGGREGATION"
    SubtypeJoin           TransformationSubtype = "JOIN"
    SubtypeFilter         TransformationSubtype = "FILTER"
    SubtypeGroupBy        TransformationSubtype = "GROUP_BY"
    SubtypeSort           TransformationSubtype = "SORT"
    SubtypeWindow         TransformationSubtype = "WINDOW"
    SubtypeConditional    TransformationSubtype = "CONDITIONAL"
)

// OpenLineageNamespace represents a data source namespace (e.g., teradata://host:port)
type OpenLineageNamespace struct {
    ID          string    `json:"id" db:"namespace_id"`
    URI         string    `json:"uri" db:"namespace_uri"`
    Description string    `json:"description,omitempty" db:"description"`
    SpecVersion string    `json:"specVersion" db:"spec_version"`
    CreatedAt   time.Time `json:"createdAt" db:"created_at"`
}

// OpenLineageDataset represents a dataset (table) in OpenLineage format
type OpenLineageDataset struct {
    ID          string    `json:"id" db:"dataset_id"`
    NamespaceID string    `json:"namespaceId" db:"namespace_id"`
    Name        string    `json:"name" db:"name"`          // Format: database.table
    Description string    `json:"description,omitempty" db:"description"`
    SourceType  string    `json:"sourceType,omitempty" db:"source_type"`  // TABLE, VIEW
    CreatedAt   time.Time `json:"createdAt" db:"created_at"`
    UpdatedAt   time.Time `json:"updatedAt" db:"updated_at"`
    IsActive    bool      `json:"isActive" db:"is_active"`
}

// OpenLineageField represents a field (column) in a dataset
type OpenLineageField struct {
    ID              string    `json:"id" db:"field_id"`
    DatasetID       string    `json:"datasetId" db:"dataset_id"`
    Name            string    `json:"name" db:"field_name"`
    Type            string    `json:"type,omitempty" db:"field_type"`
    Description     string    `json:"description,omitempty" db:"field_description"`
    OrdinalPosition int       `json:"ordinalPosition" db:"ordinal_position"`
    Nullable        bool      `json:"nullable" db:"nullable"`
    CreatedAt       time.Time `json:"createdAt" db:"created_at"`
}

// OpenLineageJob represents a job (ETL process)
type OpenLineageJob struct {
    ID          string    `json:"id" db:"job_id"`
    NamespaceID string    `json:"namespaceId" db:"namespace_id"`
    Name        string    `json:"name" db:"name"`
    Description string    `json:"description,omitempty" db:"description"`
    JobType     string    `json:"jobType,omitempty" db:"job_type"`
    CreatedAt   time.Time `json:"createdAt" db:"created_at"`
    UpdatedAt   time.Time `json:"updatedAt" db:"updated_at"`
}

// OpenLineageRun represents a job execution run
type OpenLineageRun struct {
    ID               string    `json:"id" db:"run_id"`
    JobID            string    `json:"jobId" db:"job_id"`
    EventType        string    `json:"eventType" db:"event_type"`       // START, RUNNING, COMPLETE, ABORT, FAIL
    EventTime        time.Time `json:"eventTime" db:"event_time"`
    NominalStartTime time.Time `json:"nominalStartTime,omitempty" db:"nominal_start_time"`
    NominalEndTime   time.Time `json:"nominalEndTime,omitempty" db:"nominal_end_time"`
    Producer         string    `json:"producer,omitempty" db:"producer"`
    SchemaURL        string    `json:"schemaUrl,omitempty" db:"schema_url"`
    CreatedAt        time.Time `json:"createdAt" db:"created_at"`
}

// OpenLineageColumnLineage represents column-level lineage in OpenLineage format
type OpenLineageColumnLineage struct {
    ID                        string                `json:"id" db:"lineage_id"`
    RunID                     string                `json:"runId,omitempty" db:"run_id"`
    SourceNamespace           string                `json:"sourceNamespace" db:"source_namespace"`
    SourceDataset             string                `json:"sourceDataset" db:"source_dataset"`
    SourceField               string                `json:"sourceField" db:"source_field"`
    TargetNamespace           string                `json:"targetNamespace" db:"target_namespace"`
    TargetDataset             string                `json:"targetDataset" db:"target_dataset"`
    TargetField               string                `json:"targetField" db:"target_field"`
    TransformationType        TransformationType    `json:"transformationType" db:"transformation_type"`
    TransformationSubtype     TransformationSubtype `json:"transformationSubtype" db:"transformation_subtype"`
    TransformationDescription string                `json:"transformationDescription,omitempty" db:"transformation_description"`
    Masking                   bool                  `json:"masking" db:"masking"`
    ConfidenceScore           float64               `json:"confidenceScore" db:"confidence_score"`
    DiscoveredAt              time.Time             `json:"discoveredAt" db:"discovered_at"`
    IsActive                  bool                  `json:"isActive" db:"is_active"`
    Depth                     int                   `json:"depth,omitempty"`  // For graph traversal
}

// OpenLineageGraph represents a lineage graph in OpenLineage format
type OpenLineageGraph struct {
    Nodes []OpenLineageNode `json:"nodes"`
    Edges []OpenLineageEdge `json:"edges"`
}

// OpenLineageNode represents a node in the OpenLineage graph
type OpenLineageNode struct {
    ID        string         `json:"id"`
    Type      string         `json:"type"`  // dataset, field
    Namespace string         `json:"namespace"`
    Dataset   string         `json:"dataset"`
    Field     string         `json:"field,omitempty"`
    Metadata  map[string]any `json:"metadata,omitempty"`
}

// OpenLineageEdge represents an edge in the OpenLineage graph
type OpenLineageEdge struct {
    ID                    string                `json:"id"`
    Source                string                `json:"source"`
    Target                string                `json:"target"`
    TransformationType    TransformationType    `json:"transformationType"`
    TransformationSubtype TransformationSubtype `json:"transformationSubtype"`
    ConfidenceScore       float64               `json:"confidenceScore,omitempty"`
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify entities compile.</verify>
  <done>All OpenLineage entity types exist with proper struct tags for JSON and database mapping.</done>
</task>

<task type="auto">
  <name>Task 2: Add OpenLineage repository interface</name>
  <files>lineage-api/internal/domain/repository.go</files>
  <action>
Add a new repository interface for OpenLineage operations. Place after existing interfaces:

```go
// OpenLineageRepository defines operations for OpenLineage-aligned data
type OpenLineageRepository interface {
    // Namespace operations
    GetNamespace(ctx context.Context, namespaceID string) (*OpenLineageNamespace, error)
    GetNamespaceByURI(ctx context.Context, uri string) (*OpenLineageNamespace, error)
    ListNamespaces(ctx context.Context) ([]OpenLineageNamespace, error)

    // Dataset operations
    GetDataset(ctx context.Context, datasetID string) (*OpenLineageDataset, error)
    ListDatasets(ctx context.Context, namespaceID string, limit, offset int) ([]OpenLineageDataset, int, error)
    SearchDatasets(ctx context.Context, query string, limit int) ([]OpenLineageDataset, error)

    // Field operations
    GetField(ctx context.Context, fieldID string) (*OpenLineageField, error)
    ListFields(ctx context.Context, datasetID string) ([]OpenLineageField, error)

    // Job operations
    GetJob(ctx context.Context, jobID string) (*OpenLineageJob, error)
    ListJobs(ctx context.Context, namespaceID string, limit, offset int) ([]OpenLineageJob, int, error)

    // Run operations
    GetRun(ctx context.Context, runID string) (*OpenLineageRun, error)
    ListRuns(ctx context.Context, jobID string, limit int) ([]OpenLineageRun, error)

    // Lineage operations (core)
    GetColumnLineage(ctx context.Context, datasetID, fieldName string, direction string, maxDepth int) ([]OpenLineageColumnLineage, error)
    GetColumnLineageGraph(ctx context.Context, datasetID, fieldName string, direction string, maxDepth int) (*OpenLineageGraph, error)
}
```

Note: Do not modify existing interfaces (AssetRepository, LineageRepository, SearchRepository) - they remain for backward compatibility.
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify repository interface compiles.</verify>
  <done>OpenLineageRepository interface exists with all required method signatures.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for new entity types</name>
  <files>lineage-api/internal/domain/entities_test.go</files>
  <action>
Create the test file if it doesn't exist, or add to the existing file. Add tests to verify OpenLineage entity types and constants:

```go
func TestTransformationTypes(t *testing.T) {
    tests := []struct {
        name     string
        typ      TransformationType
        expected string
    }{
        {"Direct", TransformationDirect, "DIRECT"},
        {"Indirect", TransformationIndirect, "INDIRECT"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if string(tt.typ) != tt.expected {
                t.Errorf("TransformationType %s = %s, want %s", tt.name, tt.typ, tt.expected)
            }
        })
    }
}

func TestTransformationSubtypes(t *testing.T) {
    subtypes := []struct {
        subtype  TransformationSubtype
        expected string
    }{
        {SubtypeIdentity, "IDENTITY"},
        {SubtypeTransformation, "TRANSFORMATION"},
        {SubtypeAggregation, "AGGREGATION"},
        {SubtypeJoin, "JOIN"},
        {SubtypeFilter, "FILTER"},
        {SubtypeGroupBy, "GROUP_BY"},
        {SubtypeSort, "SORT"},
        {SubtypeWindow, "WINDOW"},
        {SubtypeConditional, "CONDITIONAL"},
    }

    for _, tt := range subtypes {
        t.Run(tt.expected, func(t *testing.T) {
            if string(tt.subtype) != tt.expected {
                t.Errorf("TransformationSubtype = %s, want %s", tt.subtype, tt.expected)
            }
        })
    }
}

func TestOpenLineageColumnLineage(t *testing.T) {
    lineage := OpenLineageColumnLineage{
        ID:                    "test-lineage-id",
        SourceNamespace:       "teradata://host:1025",
        SourceDataset:         "demo_user.SRC_CUSTOMER",
        SourceField:           "customer_id",
        TargetNamespace:       "teradata://host:1025",
        TargetDataset:         "demo_user.STG_CUSTOMER",
        TargetField:           "customer_id",
        TransformationType:    TransformationDirect,
        TransformationSubtype: SubtypeIdentity,
        ConfidenceScore:       1.0,
        IsActive:              true,
    }

    if lineage.TransformationType != TransformationDirect {
        t.Errorf("TransformationType = %s, want DIRECT", lineage.TransformationType)
    }
    if lineage.TransformationSubtype != SubtypeIdentity {
        t.Errorf("TransformationSubtype = %s, want IDENTITY", lineage.TransformationSubtype)
    }
}
```
  </action>
  <verify>Run `go test ./internal/domain/...` from lineage-api directory to verify tests pass.</verify>
  <done>Unit tests exist for TransformationType, TransformationSubtype constants, and OpenLineageColumnLineage struct.</done>
</task>

</tasks>

<verification>
1. Build: `cd lineage-api && go build ./...`
2. Test: `cd lineage-api && go test ./internal/domain/...`
3. Code review: Verify TransformationType has DIRECT and INDIRECT constants
4. Code review: Verify TransformationSubtype has all 9 subtypes
5. Code review: Verify OpenLineageRepository interface has all required methods
</verification>

<success_criteria>
- Go code compiles without errors
- All domain tests pass
- OpenLineage entities have proper JSON and db struct tags
- TransformationType and TransformationSubtype constants match OpenLineage spec
- OpenLineageRepository interface defines all CRUD and lineage traversal methods
</success_criteria>

<output>
After completion, create `.planning/phases/08-open-lineage-standard-alignment/08-03-SUMMARY.md`
</output>
