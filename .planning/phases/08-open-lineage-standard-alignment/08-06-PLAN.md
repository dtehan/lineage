---
phase: 08-open-lineage-standard-alignment
plan: 06
type: execute
wave: 5
depends_on: ["08-05"]
files_modified:
  - lineage-ui/src/types/openlineage.ts
  - lineage-ui/src/api/hooks/useOpenLineage.ts
  - lineage-ui/src/api/client.ts
autonomous: true

must_haves:
  truths:
    - "OpenLineage TypeScript types exist matching API response format"
    - "useOpenLineage hooks exist for all v2 API endpoints"
    - "Hooks use TanStack Query with proper cache keys"
    - "API client has methods for v2 endpoints"
    - "Existing v1 types and hooks remain unchanged"
  artifacts:
    - path: "lineage-ui/src/types/openlineage.ts"
      provides: "OpenLineage TypeScript interfaces"
      contains: "OpenLineageDataset"
    - path: "lineage-ui/src/api/hooks/useOpenLineage.ts"
      provides: "React hooks for OpenLineage data fetching"
      contains: "useOpenLineageGraph"
    - path: "lineage-ui/src/api/client.ts"
      provides: "API client with v2 endpoints"
      contains: "/api/v2/openlineage"
  key_links:
    - from: "lineage-ui/src/api/hooks/useOpenLineage.ts"
      to: "lineage-ui/src/api/client.ts"
      via: "axios calls"
      pattern: "client\\.get"
---

<objective>
Create TypeScript types and React hooks for consuming the OpenLineage v2 API.

Purpose: Enable the frontend to consume the new OpenLineage-aligned API endpoints with type-safe data fetching.

Output: New TypeScript types, TanStack Query hooks, and API client methods for OpenLineage data.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-open-lineage-standard-alignment/08-RESEARCH.md
@.planning/phases/08-open-lineage-standard-alignment/08-05-SUMMARY.md
@lineage-ui/src/types/index.ts
@lineage-ui/src/api/client.ts
@lineage-ui/src/api/hooks/useLineage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenLineage TypeScript types</name>
  <files>lineage-ui/src/types/openlineage.ts</files>
  <action>
Create a new types file for OpenLineage data structures:

```typescript
// OpenLineage v2 API Types
// Aligned with OpenLineage spec v2-0-2

export interface OpenLineageNamespace {
  id: string;
  uri: string;
  description?: string;
  specVersion: string;
  createdAt: string;
}

export interface OpenLineageDataset {
  id: string;
  namespace: string;
  name: string;
  description?: string;
  sourceType?: string;
  fields?: OpenLineageField[];
  createdAt: string;
  updatedAt: string;
}

export interface OpenLineageField {
  id: string;
  name: string;
  type?: string;
  description?: string;
  ordinalPosition: number;
  nullable: boolean;
}

export interface OpenLineageTransformation {
  type: 'DIRECT' | 'INDIRECT';
  subtype: TransformationSubtype;
  description?: string;
}

export type TransformationSubtype =
  | 'IDENTITY'
  | 'TRANSFORMATION'
  | 'AGGREGATION'
  | 'JOIN'
  | 'FILTER'
  | 'GROUP_BY'
  | 'SORT'
  | 'WINDOW'
  | 'CONDITIONAL';

export interface OpenLineageNode {
  id: string;
  type: 'dataset' | 'field';
  namespace?: string;
  dataset: string;
  field?: string;
  metadata?: Record<string, unknown>;
}

export interface OpenLineageEdge {
  id: string;
  source: string;
  target: string;
  transformationType: 'DIRECT' | 'INDIRECT';
  transformationSubtype: TransformationSubtype;
  confidenceScore?: number;
}

export interface OpenLineageGraph {
  nodes: OpenLineageNode[];
  edges: OpenLineageEdge[];
}

export interface OpenLineageLineageResponse {
  datasetId: string;
  fieldName: string;
  direction: 'upstream' | 'downstream' | 'both';
  maxDepth: number;
  graph: OpenLineageGraph;
}

// API Response Types

export interface NamespacesResponse {
  namespaces: OpenLineageNamespace[];
}

export interface DatasetsResponse {
  datasets: OpenLineageDataset[];
  total: number;
  pagination?: {
    total_count: number;
    limit: number;
    offset: number;
    has_next: boolean;
  };
}

export interface DatasetSearchResponse {
  datasets: OpenLineageDataset[];
  query: string;
  count: number;
}

// Direction type for lineage queries
export type LineageDirection = 'upstream' | 'downstream' | 'both';

// Query parameters for lineage API
export interface LineageQueryParams {
  direction?: LineageDirection;
  maxDepth?: number;
}

// Pagination parameters
export interface OpenLineagePaginationParams {
  limit?: number;
  offset?: number;
}
```
  </action>
  <verify>Run `npm run type-check` or `npx tsc --noEmit` from lineage-ui directory to verify types compile.</verify>
  <done>OpenLineage TypeScript types created matching API response structures.</done>
</task>

<task type="auto">
  <name>Task 2: Add OpenLineage API client methods</name>
  <files>lineage-ui/src/api/client.ts</files>
  <action>
Add new API methods for OpenLineage v2 endpoints. Append to the existing client.ts file:

```typescript
import type {
  OpenLineageNamespace,
  OpenLineageDataset,
  OpenLineageLineageResponse,
  NamespacesResponse,
  DatasetsResponse,
  DatasetSearchResponse,
  OpenLineagePaginationParams,
  LineageQueryParams,
} from '../types/openlineage';

// OpenLineage v2 API methods

export const openLineageApi = {
  // Namespaces
  async getNamespaces(): Promise<NamespacesResponse> {
    const response = await client.get<NamespacesResponse>('/api/v2/openlineage/namespaces');
    return response.data;
  },

  async getNamespace(namespaceId: string): Promise<OpenLineageNamespace> {
    const response = await client.get<OpenLineageNamespace>(`/api/v2/openlineage/namespaces/${namespaceId}`);
    return response.data;
  },

  // Datasets
  async getDatasets(namespaceId: string, params?: OpenLineagePaginationParams): Promise<DatasetsResponse> {
    const response = await client.get<DatasetsResponse>(
      `/api/v2/openlineage/namespaces/${namespaceId}/datasets`,
      { params }
    );
    return response.data;
  },

  async getDataset(datasetId: string): Promise<OpenLineageDataset> {
    const response = await client.get<OpenLineageDataset>(`/api/v2/openlineage/datasets/${encodeURIComponent(datasetId)}`);
    return response.data;
  },

  async searchDatasets(query: string, limit?: number): Promise<DatasetSearchResponse> {
    const response = await client.get<DatasetSearchResponse>('/api/v2/openlineage/datasets/search', {
      params: { q: query, limit }
    });
    return response.data;
  },

  // Lineage
  async getLineageGraph(
    datasetId: string,
    fieldName: string,
    params?: LineageQueryParams
  ): Promise<OpenLineageLineageResponse> {
    const response = await client.get<OpenLineageLineageResponse>(
      `/api/v2/openlineage/lineage/${encodeURIComponent(datasetId)}/${encodeURIComponent(fieldName)}`,
      { params }
    );
    return response.data;
  },
};
```

Make sure to import the types at the top of the file if needed.
  </action>
  <verify>Run `npm run type-check` or `npx tsc --noEmit` from lineage-ui directory to verify client compiles.</verify>
  <done>OpenLineage API client methods added for all v2 endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Create OpenLineage React hooks</name>
  <files>lineage-ui/src/api/hooks/useOpenLineage.ts</files>
  <action>
Create a new hooks file for OpenLineage data fetching:

```typescript
import { useQuery, UseQueryOptions } from '@tanstack/react-query';
import { openLineageApi } from '../client';
import type {
  OpenLineageNamespace,
  OpenLineageDataset,
  OpenLineageLineageResponse,
  NamespacesResponse,
  DatasetsResponse,
  DatasetSearchResponse,
  OpenLineagePaginationParams,
  LineageDirection,
} from '../../types/openlineage';

// Query key factory for consistent cache keys
export const openLineageKeys = {
  all: ['openlineage'] as const,
  namespaces: () => [...openLineageKeys.all, 'namespaces'] as const,
  namespace: (id: string) => [...openLineageKeys.namespaces(), id] as const,
  datasets: (namespaceId: string) => [...openLineageKeys.all, 'datasets', namespaceId] as const,
  datasetsPaginated: (namespaceId: string, params: OpenLineagePaginationParams) =>
    [...openLineageKeys.datasets(namespaceId), params] as const,
  dataset: (id: string) => [...openLineageKeys.all, 'dataset', id] as const,
  datasetsSearch: (query: string) => [...openLineageKeys.all, 'datasets', 'search', query] as const,
  lineage: (datasetId: string, fieldName: string, direction: LineageDirection, maxDepth: number) =>
    [...openLineageKeys.all, 'lineage', datasetId, fieldName, direction, maxDepth] as const,
};

// Namespace hooks

export function useOpenLineageNamespaces(
  options?: Omit<UseQueryOptions<NamespacesResponse, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.namespaces(),
    queryFn: () => openLineageApi.getNamespaces(),
    ...options,
  });
}

export function useOpenLineageNamespace(
  namespaceId: string,
  options?: Omit<UseQueryOptions<OpenLineageNamespace, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.namespace(namespaceId),
    queryFn: () => openLineageApi.getNamespace(namespaceId),
    enabled: !!namespaceId,
    ...options,
  });
}

// Dataset hooks

export function useOpenLineageDatasets(
  namespaceId: string,
  params?: OpenLineagePaginationParams,
  options?: Omit<UseQueryOptions<DatasetsResponse, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.datasetsPaginated(namespaceId, params ?? {}),
    queryFn: () => openLineageApi.getDatasets(namespaceId, params),
    enabled: !!namespaceId,
    ...options,
  });
}

export function useOpenLineageDataset(
  datasetId: string,
  options?: Omit<UseQueryOptions<OpenLineageDataset, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.dataset(datasetId),
    queryFn: () => openLineageApi.getDataset(datasetId),
    enabled: !!datasetId,
    ...options,
  });
}

export function useOpenLineageDatasetSearch(
  query: string,
  limit?: number,
  options?: Omit<UseQueryOptions<DatasetSearchResponse, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.datasetsSearch(query),
    queryFn: () => openLineageApi.searchDatasets(query, limit),
    enabled: query.length > 0,
    ...options,
  });
}

// Lineage hooks

export function useOpenLineageGraph(
  datasetId: string,
  fieldName: string,
  direction: LineageDirection = 'both',
  maxDepth: number = 5,
  options?: Omit<UseQueryOptions<OpenLineageLineageResponse, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: openLineageKeys.lineage(datasetId, fieldName, direction, maxDepth),
    queryFn: () =>
      openLineageApi.getLineageGraph(datasetId, fieldName, { direction, maxDepth }),
    enabled: !!datasetId && !!fieldName,
    ...options,
  });
}

// Simplified hook for common use case
export function useOpenLineageFieldLineage(
  datasetId: string,
  fieldName: string,
  options?: {
    direction?: LineageDirection;
    maxDepth?: number;
  } & Omit<UseQueryOptions<OpenLineageLineageResponse, Error>, 'queryKey' | 'queryFn'>
) {
  const { direction = 'both', maxDepth = 5, ...queryOptions } = options ?? {};
  return useOpenLineageGraph(datasetId, fieldName, direction, maxDepth, queryOptions);
}
```
  </action>
  <verify>Run `npm run type-check` or `npx tsc --noEmit` from lineage-ui directory to verify hooks compile.</verify>
  <done>OpenLineage React hooks created with TanStack Query integration.</done>
</task>

<task type="auto">
  <name>Task 4: Export new types and hooks</name>
  <files>lineage-ui/src/types/index.ts</files>
  <action>
Add re-export for OpenLineage types at the bottom of the existing types/index.ts:

```typescript
// OpenLineage types
export * from './openlineage';
```

Also verify hooks are exported. Check if there's an index.ts in src/api/hooks/ and add:

```typescript
export * from './useOpenLineage';
```

If no index exists, the hooks can be imported directly from the file.
  </action>
  <verify>Run `npm run type-check` from lineage-ui directory to verify exports work correctly.</verify>
  <done>OpenLineage types and hooks are properly exported for use in components.</done>
</task>

</tasks>

<verification>
1. Type check: `cd lineage-ui && npm run type-check` or `npx tsc --noEmit`
2. Build: `cd lineage-ui && npm run build`
3. Code review: Verify types match API response format from 08-05 DTOs
4. Code review: Verify hooks use proper TanStack Query patterns
5. Code review: Verify query keys are structured for proper cache invalidation
6. Code review: Verify enabled flag prevents invalid requests
</verification>

<success_criteria>
- TypeScript compiles without errors
- Frontend builds successfully
- Types match backend DTO structure
- Hooks follow TanStack Query v5 patterns (keepPreviousData, enabled)
- Query keys are hierarchical for proper cache management
- Existing v1 types and hooks remain unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/08-open-lineage-standard-alignment/08-06-SUMMARY.md`
</output>
