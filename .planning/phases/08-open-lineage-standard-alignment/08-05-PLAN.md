---
phase: 08-open-lineage-standard-alignment
plan: 05
type: execute
wave: 4
depends_on: ["08-03", "08-04"]
files_modified:
  - lineage-api/internal/application/openlineage_service.go
  - lineage-api/internal/application/dto.go
  - lineage-api/internal/adapter/inbound/http/openlineage_handlers.go
  - lineage-api/internal/adapter/inbound/http/router.go
autonomous: true

must_haves:
  truths:
    - "OpenLineage service layer exists with business logic"
    - "DTOs exist for OpenLineage API responses"
    - "HTTP handlers exist for /api/v2/openlineage/* endpoints"
    - "Router registers new v2 OpenLineage endpoints"
    - "Existing v1 endpoints remain unchanged"
  artifacts:
    - path: "lineage-api/internal/application/openlineage_service.go"
      provides: "OpenLineage business logic"
      contains: "OpenLineageService"
    - path: "lineage-api/internal/adapter/inbound/http/openlineage_handlers.go"
      provides: "HTTP handlers for OpenLineage API"
      contains: "GetOpenLineageGraph"
    - path: "lineage-api/internal/adapter/inbound/http/router.go"
      provides: "Route registration"
      contains: "/api/v2/openlineage"
  key_links:
    - from: "lineage-api/internal/adapter/inbound/http/openlineage_handlers.go"
      to: "lineage-api/internal/application/openlineage_service.go"
      via: "service dependency"
      pattern: "OpenLineageService"
---

<objective>
Create the service layer and HTTP handlers for OpenLineage API endpoints.

Purpose: Expose the OpenLineage-aligned data through a new /api/v2/openlineage endpoint structure while maintaining backward compatibility with existing v1 endpoints.

Output: New service, DTOs, handlers, and router configuration for OpenLineage API.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-open-lineage-standard-alignment/08-RESEARCH.md
@.planning/phases/08-open-lineage-standard-alignment/08-03-SUMMARY.md
@.planning/phases/08-open-lineage-standard-alignment/08-04-SUMMARY.md
@lineage-api/internal/application/lineage_service.go
@lineage-api/internal/adapter/inbound/http/handlers.go
@lineage-api/internal/adapter/inbound/http/router.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OpenLineage DTOs to dto.go</name>
  <files>lineage-api/internal/application/dto.go</files>
  <action>
Add new DTOs for OpenLineage API responses. Append to the existing dto.go file:

```go
// OpenLineage API DTOs

// OpenLineageNamespaceResponse represents a namespace in API responses
type OpenLineageNamespaceResponse struct {
    ID          string    `json:"id"`
    URI         string    `json:"uri"`
    Description string    `json:"description,omitempty"`
    SpecVersion string    `json:"specVersion"`
    CreatedAt   time.Time `json:"createdAt"`
}

// OpenLineageDatasetResponse represents a dataset in API responses
type OpenLineageDatasetResponse struct {
    ID          string                        `json:"id"`
    Namespace   string                        `json:"namespace"`
    Name        string                        `json:"name"`
    Description string                        `json:"description,omitempty"`
    SourceType  string                        `json:"sourceType,omitempty"`
    Fields      []OpenLineageFieldResponse    `json:"fields,omitempty"`
    CreatedAt   time.Time                     `json:"createdAt"`
    UpdatedAt   time.Time                     `json:"updatedAt"`
}

// OpenLineageFieldResponse represents a field in API responses
type OpenLineageFieldResponse struct {
    ID              string `json:"id"`
    Name            string `json:"name"`
    Type            string `json:"type,omitempty"`
    Description     string `json:"description,omitempty"`
    OrdinalPosition int    `json:"ordinalPosition"`
    Nullable        bool   `json:"nullable"`
}

// OpenLineageLineageResponse represents lineage data in API responses
type OpenLineageLineageResponse struct {
    DatasetID string                      `json:"datasetId"`
    FieldName string                      `json:"fieldName"`
    Direction string                      `json:"direction"`
    MaxDepth  int                         `json:"maxDepth"`
    Graph     *OpenLineageGraphResponse   `json:"graph"`
}

// OpenLineageGraphResponse represents a lineage graph in API responses
type OpenLineageGraphResponse struct {
    Nodes []OpenLineageNodeResponse `json:"nodes"`
    Edges []OpenLineageEdgeResponse `json:"edges"`
}

// OpenLineageNodeResponse represents a node in the lineage graph
type OpenLineageNodeResponse struct {
    ID        string         `json:"id"`
    Type      string         `json:"type"`
    Namespace string         `json:"namespace,omitempty"`
    Dataset   string         `json:"dataset"`
    Field     string         `json:"field,omitempty"`
    Metadata  map[string]any `json:"metadata,omitempty"`
}

// OpenLineageEdgeResponse represents an edge in the lineage graph
type OpenLineageEdgeResponse struct {
    ID                    string  `json:"id"`
    Source                string  `json:"source"`
    Target                string  `json:"target"`
    TransformationType    string  `json:"transformationType"`
    TransformationSubtype string  `json:"transformationSubtype"`
    ConfidenceScore       float64 `json:"confidenceScore,omitempty"`
}

// PaginatedDatasetsResponse represents paginated datasets
type PaginatedDatasetsResponse struct {
    Datasets   []OpenLineageDatasetResponse `json:"datasets"`
    Total      int                          `json:"total"`
    Pagination *PaginationMeta              `json:"pagination,omitempty"`
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify DTOs compile.</verify>
  <done>OpenLineage DTOs added to dto.go with proper JSON tags.</done>
</task>

<task type="auto">
  <name>Task 2: Create OpenLineage service</name>
  <files>lineage-api/internal/application/openlineage_service.go</files>
  <action>
Create a new service file for OpenLineage business logic:

```go
package application

import (
    "context"

    "github.com/lineage-app/lineage-api/internal/domain"
)

// OpenLineageService provides business logic for OpenLineage operations
type OpenLineageService struct {
    repo domain.OpenLineageRepository
}

// NewOpenLineageService creates a new OpenLineage service
func NewOpenLineageService(repo domain.OpenLineageRepository) *OpenLineageService {
    return &OpenLineageService{repo: repo}
}

// ListNamespaces returns all namespaces
func (s *OpenLineageService) ListNamespaces(ctx context.Context) ([]OpenLineageNamespaceResponse, error) {
    namespaces, err := s.repo.ListNamespaces(ctx)
    if err != nil {
        return nil, err
    }

    responses := make([]OpenLineageNamespaceResponse, len(namespaces))
    for i, ns := range namespaces {
        responses[i] = OpenLineageNamespaceResponse{
            ID:          ns.ID,
            URI:         ns.URI,
            Description: ns.Description,
            SpecVersion: ns.SpecVersion,
            CreatedAt:   ns.CreatedAt,
        }
    }
    return responses, nil
}

// GetNamespace returns a specific namespace
func (s *OpenLineageService) GetNamespace(ctx context.Context, namespaceID string) (*OpenLineageNamespaceResponse, error) {
    ns, err := s.repo.GetNamespace(ctx, namespaceID)
    if err != nil {
        return nil, err
    }
    if ns == nil {
        return nil, nil
    }

    return &OpenLineageNamespaceResponse{
        ID:          ns.ID,
        URI:         ns.URI,
        Description: ns.Description,
        SpecVersion: ns.SpecVersion,
        CreatedAt:   ns.CreatedAt,
    }, nil
}

// ListDatasets returns datasets for a namespace with pagination
func (s *OpenLineageService) ListDatasets(ctx context.Context, namespaceID string, limit, offset int) (*PaginatedDatasetsResponse, error) {
    datasets, total, err := s.repo.ListDatasets(ctx, namespaceID, limit, offset)
    if err != nil {
        return nil, err
    }

    responses := make([]OpenLineageDatasetResponse, len(datasets))
    for i, ds := range datasets {
        responses[i] = s.datasetToResponse(ds)
    }

    hasNext := offset+limit < total
    return &PaginatedDatasetsResponse{
        Datasets: responses,
        Total:    total,
        Pagination: &PaginationMeta{
            TotalCount: total,
            Limit:      limit,
            Offset:     offset,
            HasNext:    hasNext,
        },
    }, nil
}

// GetDataset returns a specific dataset with its fields
func (s *OpenLineageService) GetDataset(ctx context.Context, datasetID string) (*OpenLineageDatasetResponse, error) {
    ds, err := s.repo.GetDataset(ctx, datasetID)
    if err != nil {
        return nil, err
    }
    if ds == nil {
        return nil, nil
    }

    response := s.datasetToResponse(*ds)

    // Get fields for this dataset
    fields, err := s.repo.ListFields(ctx, datasetID)
    if err != nil {
        return nil, err
    }

    response.Fields = make([]OpenLineageFieldResponse, len(fields))
    for i, f := range fields {
        response.Fields[i] = OpenLineageFieldResponse{
            ID:              f.ID,
            Name:            f.Name,
            Type:            f.Type,
            Description:     f.Description,
            OrdinalPosition: f.OrdinalPosition,
            Nullable:        f.Nullable,
        }
    }

    return &response, nil
}

// SearchDatasets searches datasets by name
func (s *OpenLineageService) SearchDatasets(ctx context.Context, query string, limit int) ([]OpenLineageDatasetResponse, error) {
    datasets, err := s.repo.SearchDatasets(ctx, query, limit)
    if err != nil {
        return nil, err
    }

    responses := make([]OpenLineageDatasetResponse, len(datasets))
    for i, ds := range datasets {
        responses[i] = s.datasetToResponse(ds)
    }
    return responses, nil
}

// GetLineageGraph returns the lineage graph for a field
func (s *OpenLineageService) GetLineageGraph(ctx context.Context, datasetID, fieldName, direction string, maxDepth int) (*OpenLineageLineageResponse, error) {
    // Validate and default direction
    if direction == "" {
        direction = "both"
    }

    // Get graph from repository
    graph, err := s.repo.GetColumnLineageGraph(ctx, datasetID, fieldName, direction, maxDepth)
    if err != nil {
        return nil, err
    }

    // Convert to response format
    response := &OpenLineageLineageResponse{
        DatasetID: datasetID,
        FieldName: fieldName,
        Direction: direction,
        MaxDepth:  maxDepth,
        Graph:     s.graphToResponse(graph),
    }

    return response, nil
}

// Helper methods

func (s *OpenLineageService) datasetToResponse(ds domain.OpenLineageDataset) OpenLineageDatasetResponse {
    return OpenLineageDatasetResponse{
        ID:          ds.ID,
        Namespace:   ds.NamespaceID,
        Name:        ds.Name,
        Description: ds.Description,
        SourceType:  ds.SourceType,
        CreatedAt:   ds.CreatedAt,
        UpdatedAt:   ds.UpdatedAt,
    }
}

func (s *OpenLineageService) graphToResponse(graph *domain.OpenLineageGraph) *OpenLineageGraphResponse {
    if graph == nil {
        return &OpenLineageGraphResponse{
            Nodes: []OpenLineageNodeResponse{},
            Edges: []OpenLineageEdgeResponse{},
        }
    }

    nodes := make([]OpenLineageNodeResponse, len(graph.Nodes))
    for i, n := range graph.Nodes {
        nodes[i] = OpenLineageNodeResponse{
            ID:        n.ID,
            Type:      n.Type,
            Namespace: n.Namespace,
            Dataset:   n.Dataset,
            Field:     n.Field,
            Metadata:  n.Metadata,
        }
    }

    edges := make([]OpenLineageEdgeResponse, len(graph.Edges))
    for i, e := range graph.Edges {
        edges[i] = OpenLineageEdgeResponse{
            ID:                    e.ID,
            Source:                e.Source,
            Target:                e.Target,
            TransformationType:    string(e.TransformationType),
            TransformationSubtype: string(e.TransformationSubtype),
            ConfidenceScore:       e.ConfidenceScore,
        }
    }

    return &OpenLineageGraphResponse{
        Nodes: nodes,
        Edges: edges,
    }
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify service compiles.</verify>
  <done>OpenLineage service created with all business logic methods.</done>
</task>

<task type="auto">
  <name>Task 3: Create OpenLineage HTTP handlers</name>
  <files>lineage-api/internal/adapter/inbound/http/openlineage_handlers.go</files>
  <action>
Create a new handler file for OpenLineage API endpoints:

```go
package http

import (
    "encoding/json"
    "net/http"
    "strconv"

    "github.com/go-chi/chi/v5"
    "github.com/lineage-app/lineage-api/internal/application"
    "github.com/lineage-app/lineage-api/internal/infrastructure/logging"
)

// OpenLineageHandlers handles OpenLineage API requests
type OpenLineageHandlers struct {
    service *application.OpenLineageService
}

// NewOpenLineageHandlers creates new OpenLineage handlers
func NewOpenLineageHandlers(service *application.OpenLineageService) *OpenLineageHandlers {
    return &OpenLineageHandlers{service: service}
}

// ListNamespaces handles GET /api/v2/openlineage/namespaces
func (h *OpenLineageHandlers) ListNamespaces(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)

    namespaces, err := h.service.ListNamespaces(ctx)
    if err != nil {
        logger.Error("failed to list namespaces", "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    WriteJSON(w, http.StatusOK, map[string]any{
        "namespaces": namespaces,
    })
}

// GetNamespace handles GET /api/v2/openlineage/namespaces/{namespaceId}
func (h *OpenLineageHandlers) GetNamespace(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)
    namespaceID := chi.URLParam(r, "namespaceId")

    ns, err := h.service.GetNamespace(ctx, namespaceID)
    if err != nil {
        logger.Error("failed to get namespace", "namespaceId", namespaceID, "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    if ns == nil {
        WriteError(w, r, http.StatusNotFound, "Namespace not found")
        return
    }

    WriteJSON(w, http.StatusOK, ns)
}

// ListDatasets handles GET /api/v2/openlineage/namespaces/{namespaceId}/datasets
func (h *OpenLineageHandlers) ListDatasets(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)
    namespaceID := chi.URLParam(r, "namespaceId")

    // Parse pagination params
    limit, offset := h.parsePagination(r)

    datasets, err := h.service.ListDatasets(ctx, namespaceID, limit, offset)
    if err != nil {
        logger.Error("failed to list datasets", "namespaceId", namespaceID, "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    WriteJSON(w, http.StatusOK, datasets)
}

// GetDataset handles GET /api/v2/openlineage/datasets/{datasetId}
func (h *OpenLineageHandlers) GetDataset(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)
    datasetID := chi.URLParam(r, "datasetId")

    ds, err := h.service.GetDataset(ctx, datasetID)
    if err != nil {
        logger.Error("failed to get dataset", "datasetId", datasetID, "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    if ds == nil {
        WriteError(w, r, http.StatusNotFound, "Dataset not found")
        return
    }

    WriteJSON(w, http.StatusOK, ds)
}

// SearchDatasets handles GET /api/v2/openlineage/datasets/search
func (h *OpenLineageHandlers) SearchDatasets(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)
    query := r.URL.Query().Get("q")

    if query == "" {
        WriteError(w, r, http.StatusBadRequest, "Query parameter 'q' is required")
        return
    }

    limit := 100 // Default search limit
    if l := r.URL.Query().Get("limit"); l != "" {
        if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= 500 {
            limit = parsed
        }
    }

    datasets, err := h.service.SearchDatasets(ctx, query, limit)
    if err != nil {
        logger.Error("failed to search datasets", "query", query, "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    WriteJSON(w, http.StatusOK, map[string]any{
        "datasets": datasets,
        "query":    query,
        "count":    len(datasets),
    })
}

// GetLineageGraph handles GET /api/v2/openlineage/lineage/{datasetId}/{fieldName}
func (h *OpenLineageHandlers) GetLineageGraph(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    logger := logging.FromContext(ctx)
    datasetID := chi.URLParam(r, "datasetId")
    fieldName := chi.URLParam(r, "fieldName")

    // Parse query params
    direction := r.URL.Query().Get("direction")
    if direction == "" {
        direction = "both"
    }
    if direction != "upstream" && direction != "downstream" && direction != "both" {
        WriteError(w, r, http.StatusBadRequest, "Invalid direction. Must be 'upstream', 'downstream', or 'both'")
        return
    }

    maxDepth := DefaultDepth
    if d := r.URL.Query().Get("maxDepth"); d != "" {
        if parsed, err := strconv.Atoi(d); err == nil {
            if parsed < MinDepth || parsed > MaxDepth {
                WriteError(w, r, http.StatusBadRequest, "maxDepth must be between 1 and 20")
                return
            }
            maxDepth = parsed
        }
    }

    lineage, err := h.service.GetLineageGraph(ctx, datasetID, fieldName, direction, maxDepth)
    if err != nil {
        logger.Error("failed to get lineage graph", "datasetId", datasetID, "fieldName", fieldName, "error", err)
        WriteError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    WriteJSON(w, http.StatusOK, lineage)
}

// Helper methods

func (h *OpenLineageHandlers) parsePagination(r *http.Request) (limit, offset int) {
    limit = DefaultLimit
    offset = 0

    if l := r.URL.Query().Get("limit"); l != "" {
        if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= MaxLimit {
            limit = parsed
        }
    }

    if o := r.URL.Query().Get("offset"); o != "" {
        if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
            offset = parsed
        }
    }

    return limit, offset
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify handlers compile.</verify>
  <done>OpenLineage HTTP handlers created for all API endpoints.</done>
</task>

<task type="auto">
  <name>Task 4: Update router to register OpenLineage endpoints</name>
  <files>lineage-api/internal/adapter/inbound/http/router.go</files>
  <action>
Update the router to register the new OpenLineage v2 endpoints. Add to the NewRouter function or equivalent:

1. Add parameter for OpenLineageHandlers:
```go
func NewRouter(
    assetHandlers *Handlers,
    // ... existing params
    olHandlers *OpenLineageHandlers, // Add this parameter
) chi.Router {
```

2. Add v2 OpenLineage routes (after existing v1 routes):
```go
// API v2 - OpenLineage aligned
r.Route("/api/v2/openlineage", func(r chi.Router) {
    // Namespaces
    r.Get("/namespaces", olHandlers.ListNamespaces)
    r.Get("/namespaces/{namespaceId}", olHandlers.GetNamespace)
    r.Get("/namespaces/{namespaceId}/datasets", olHandlers.ListDatasets)

    // Datasets
    r.Get("/datasets/{datasetId}", olHandlers.GetDataset)
    r.Get("/datasets/search", olHandlers.SearchDatasets)

    // Lineage
    r.Get("/lineage/{datasetId}/{fieldName}", olHandlers.GetLineageGraph)
})
```

If the router uses a different pattern (e.g., SetupRoutes function), adapt accordingly to add the v2 routes.

**Important:** Keep all existing v1 routes (`/api/v1/*`) unchanged for backward compatibility.
  </action>
  <verify>Run `go build ./...` from lineage-api directory. Optionally, start the server and verify `/api/v2/openlineage/namespaces` endpoint responds.</verify>
  <done>Router updated with v2 OpenLineage endpoints registered alongside existing v1 endpoints.</done>
</task>

</tasks>

<verification>
1. Build: `cd lineage-api && go build ./...`
2. Test: `cd lineage-api && go test ./...`
3. Code review: Verify DTOs have proper JSON tags
4. Code review: Verify service methods transform domain entities to DTOs correctly
5. Code review: Verify handlers use proper error handling pattern (log then generic error)
6. Code review: Verify router registers all 6 v2 endpoints
</verification>

<success_criteria>
- Go code compiles without errors
- All tests pass
- v2 endpoints follow RESTful patterns
- Error handling follows existing patterns (log server-side, return generic error)
- v1 endpoints remain unchanged
- Pagination parameters validated and applied
</success_criteria>

<output>
After completion, create `.planning/phases/08-open-lineage-standard-alignment/08-05-SUMMARY.md`
</output>
