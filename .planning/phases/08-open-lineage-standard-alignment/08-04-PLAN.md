---
phase: 08-open-lineage-standard-alignment
plan: 04
type: execute
wave: 3
depends_on: ["08-01", "08-03"]
files_modified:
  - lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go
  - lineage-api/internal/adapter/outbound/teradata/openlineage_repo_test.go
autonomous: true

must_haves:
  truths:
    - "OpenLineageRepository implementation queries OL_* tables"
    - "GetColumnLineage traverses OL_COLUMN_LINEAGE with recursive CTE"
    - "GetColumnLineageGraph builds graph from lineage records"
    - "Direction parameter filters upstream/downstream/both"
    - "MaxDepth parameter limits recursion depth"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go"
      provides: "Teradata OpenLineage repository implementation"
      contains: "OL_COLUMN_LINEAGE"
    - path: "lineage-api/internal/adapter/outbound/teradata/openlineage_repo_test.go"
      provides: "Repository tests"
      contains: "TestGetColumnLineage"
  key_links:
    - from: "lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go"
      to: "lineage-api/internal/domain/repository.go"
      via: "implements interface"
      pattern: "OpenLineageRepository"
---

<objective>
Implement the OpenLineageRepository interface for Teradata, querying the new OL_* tables.

Purpose: Create the data access layer that retrieves OpenLineage-aligned data from the database and supports lineage graph traversal using recursive CTEs.

Output: New openlineage_repo.go file implementing OpenLineageRepository with lineage traversal logic.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-open-lineage-standard-alignment/08-RESEARCH.md
@.planning/phases/08-open-lineage-standard-alignment/08-03-SUMMARY.md
@lineage-api/internal/domain/repository.go
@lineage-api/internal/adapter/outbound/teradata/lineage_repo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create openlineage_repo.go with basic CRUD operations</name>
  <files>lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go</files>
  <action>
Create a new file implementing the OpenLineageRepository interface. Start with the basic CRUD operations:

```go
package teradata

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "github.com/lineage-app/lineage-api/internal/domain"
)

type OpenLineageRepository struct {
    db *sql.DB
}

func NewOpenLineageRepository(db *sql.DB) *OpenLineageRepository {
    return &OpenLineageRepository{db: db}
}

// Ensure interface compliance
var _ domain.OpenLineageRepository = (*OpenLineageRepository)(nil)

// Namespace operations

func (r *OpenLineageRepository) GetNamespace(ctx context.Context, namespaceID string) (*domain.OpenLineageNamespace, error) {
    query := `
        SELECT namespace_id, namespace_uri, description, spec_version, created_at
        FROM demo_user.OL_NAMESPACE
        WHERE namespace_id = ?`

    var ns domain.OpenLineageNamespace
    var createdAt sql.NullTime
    var description sql.NullString

    err := r.db.QueryRowContext(ctx, query, namespaceID).Scan(
        &ns.ID, &ns.URI, &description, &ns.SpecVersion, &createdAt,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get namespace: %w", err)
    }

    ns.Description = description.String
    if createdAt.Valid {
        ns.CreatedAt = createdAt.Time
    }
    return &ns, nil
}

func (r *OpenLineageRepository) GetNamespaceByURI(ctx context.Context, uri string) (*domain.OpenLineageNamespace, error) {
    query := `
        SELECT namespace_id, namespace_uri, description, spec_version, created_at
        FROM demo_user.OL_NAMESPACE
        WHERE namespace_uri = ?`

    var ns domain.OpenLineageNamespace
    var createdAt sql.NullTime
    var description sql.NullString

    err := r.db.QueryRowContext(ctx, query, uri).Scan(
        &ns.ID, &ns.URI, &description, &ns.SpecVersion, &createdAt,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get namespace by URI: %w", err)
    }

    ns.Description = description.String
    if createdAt.Valid {
        ns.CreatedAt = createdAt.Time
    }
    return &ns, nil
}

func (r *OpenLineageRepository) ListNamespaces(ctx context.Context) ([]domain.OpenLineageNamespace, error) {
    query := `
        SELECT namespace_id, namespace_uri, description, spec_version, created_at
        FROM demo_user.OL_NAMESPACE
        ORDER BY created_at DESC`

    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("list namespaces: %w", err)
    }
    defer rows.Close()

    var namespaces []domain.OpenLineageNamespace
    for rows.Next() {
        var ns domain.OpenLineageNamespace
        var createdAt sql.NullTime
        var description sql.NullString

        if err := rows.Scan(&ns.ID, &ns.URI, &description, &ns.SpecVersion, &createdAt); err != nil {
            return nil, fmt.Errorf("scan namespace: %w", err)
        }
        ns.Description = description.String
        if createdAt.Valid {
            ns.CreatedAt = createdAt.Time
        }
        namespaces = append(namespaces, ns)
    }
    return namespaces, rows.Err()
}

// Dataset operations

func (r *OpenLineageRepository) GetDataset(ctx context.Context, datasetID string) (*domain.OpenLineageDataset, error) {
    query := `
        SELECT dataset_id, namespace_id, name, description, source_type, created_at, updated_at, is_active
        FROM demo_user.OL_DATASET
        WHERE dataset_id = ?`

    var ds domain.OpenLineageDataset
    var description, sourceType sql.NullString
    var createdAt, updatedAt sql.NullTime
    var isActive string

    err := r.db.QueryRowContext(ctx, query, datasetID).Scan(
        &ds.ID, &ds.NamespaceID, &ds.Name, &description, &sourceType,
        &createdAt, &updatedAt, &isActive,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get dataset: %w", err)
    }

    ds.Description = description.String
    ds.SourceType = sourceType.String
    ds.IsActive = isActive == "Y"
    if createdAt.Valid {
        ds.CreatedAt = createdAt.Time
    }
    if updatedAt.Valid {
        ds.UpdatedAt = updatedAt.Time
    }
    return &ds, nil
}

func (r *OpenLineageRepository) ListDatasets(ctx context.Context, namespaceID string, limit, offset int) ([]domain.OpenLineageDataset, int, error) {
    countQuery := `SELECT COUNT(*) FROM demo_user.OL_DATASET WHERE namespace_id = ? AND is_active = 'Y'`
    var total int
    if err := r.db.QueryRowContext(ctx, countQuery, namespaceID).Scan(&total); err != nil {
        return nil, 0, fmt.Errorf("count datasets: %w", err)
    }

    query := `
        SELECT dataset_id, namespace_id, name, description, source_type, created_at, updated_at, is_active
        FROM demo_user.OL_DATASET
        WHERE namespace_id = ? AND is_active = 'Y'
        ORDER BY name
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY`

    rows, err := r.db.QueryContext(ctx, query, namespaceID, offset, limit)
    if err != nil {
        return nil, 0, fmt.Errorf("list datasets: %w", err)
    }
    defer rows.Close()

    var datasets []domain.OpenLineageDataset
    for rows.Next() {
        var ds domain.OpenLineageDataset
        var description, sourceType sql.NullString
        var createdAt, updatedAt sql.NullTime
        var isActive string

        if err := rows.Scan(&ds.ID, &ds.NamespaceID, &ds.Name, &description, &sourceType,
            &createdAt, &updatedAt, &isActive); err != nil {
            return nil, 0, fmt.Errorf("scan dataset: %w", err)
        }
        ds.Description = description.String
        ds.SourceType = sourceType.String
        ds.IsActive = isActive == "Y"
        if createdAt.Valid {
            ds.CreatedAt = createdAt.Time
        }
        if updatedAt.Valid {
            ds.UpdatedAt = updatedAt.Time
        }
        datasets = append(datasets, ds)
    }
    return datasets, total, rows.Err()
}

func (r *OpenLineageRepository) SearchDatasets(ctx context.Context, query string, limit int) ([]domain.OpenLineageDataset, error) {
    sqlQuery := `
        SELECT dataset_id, namespace_id, name, description, source_type, created_at, updated_at, is_active
        FROM demo_user.OL_DATASET
        WHERE is_active = 'Y' AND UPPER(name) LIKE UPPER(?)
        ORDER BY name
        FETCH FIRST ? ROWS ONLY`

    rows, err := r.db.QueryContext(ctx, sqlQuery, "%"+query+"%", limit)
    if err != nil {
        return nil, fmt.Errorf("search datasets: %w", err)
    }
    defer rows.Close()

    var datasets []domain.OpenLineageDataset
    for rows.Next() {
        var ds domain.OpenLineageDataset
        var description, sourceType sql.NullString
        var createdAt, updatedAt sql.NullTime
        var isActive string

        if err := rows.Scan(&ds.ID, &ds.NamespaceID, &ds.Name, &description, &sourceType,
            &createdAt, &updatedAt, &isActive); err != nil {
            return nil, fmt.Errorf("scan dataset: %w", err)
        }
        ds.Description = description.String
        ds.SourceType = sourceType.String
        ds.IsActive = isActive == "Y"
        if createdAt.Valid {
            ds.CreatedAt = createdAt.Time
        }
        if updatedAt.Valid {
            ds.UpdatedAt = updatedAt.Time
        }
        datasets = append(datasets, ds)
    }
    return datasets, rows.Err()
}

// Field operations

func (r *OpenLineageRepository) GetField(ctx context.Context, fieldID string) (*domain.OpenLineageField, error) {
    query := `
        SELECT field_id, dataset_id, field_name, field_type, field_description, ordinal_position, nullable, created_at
        FROM demo_user.OL_DATASET_FIELD
        WHERE field_id = ?`

    var f domain.OpenLineageField
    var fieldType, description sql.NullString
    var createdAt sql.NullTime
    var nullable string

    err := r.db.QueryRowContext(ctx, query, fieldID).Scan(
        &f.ID, &f.DatasetID, &f.Name, &fieldType, &description,
        &f.OrdinalPosition, &nullable, &createdAt,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get field: %w", err)
    }

    f.Type = fieldType.String
    f.Description = description.String
    f.Nullable = nullable == "Y"
    if createdAt.Valid {
        f.CreatedAt = createdAt.Time
    }
    return &f, nil
}

func (r *OpenLineageRepository) ListFields(ctx context.Context, datasetID string) ([]domain.OpenLineageField, error) {
    query := `
        SELECT field_id, dataset_id, field_name, field_type, field_description, ordinal_position, nullable, created_at
        FROM demo_user.OL_DATASET_FIELD
        WHERE dataset_id = ?
        ORDER BY ordinal_position`

    rows, err := r.db.QueryContext(ctx, query, datasetID)
    if err != nil {
        return nil, fmt.Errorf("list fields: %w", err)
    }
    defer rows.Close()

    var fields []domain.OpenLineageField
    for rows.Next() {
        var f domain.OpenLineageField
        var fieldType, description sql.NullString
        var createdAt sql.NullTime
        var nullable string

        if err := rows.Scan(&f.ID, &f.DatasetID, &f.Name, &fieldType, &description,
            &f.OrdinalPosition, &nullable, &createdAt); err != nil {
            return nil, fmt.Errorf("scan field: %w", err)
        }
        f.Type = fieldType.String
        f.Description = description.String
        f.Nullable = nullable == "Y"
        if createdAt.Valid {
            f.CreatedAt = createdAt.Time
        }
        fields = append(fields, f)
    }
    return fields, rows.Err()
}

// Job operations

func (r *OpenLineageRepository) GetJob(ctx context.Context, jobID string) (*domain.OpenLineageJob, error) {
    query := `
        SELECT job_id, namespace_id, name, description, job_type, created_at, updated_at
        FROM demo_user.OL_JOB
        WHERE job_id = ?`

    var j domain.OpenLineageJob
    var description, jobType sql.NullString
    var createdAt, updatedAt sql.NullTime

    err := r.db.QueryRowContext(ctx, query, jobID).Scan(
        &j.ID, &j.NamespaceID, &j.Name, &description, &jobType, &createdAt, &updatedAt,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get job: %w", err)
    }

    j.Description = description.String
    j.JobType = jobType.String
    if createdAt.Valid {
        j.CreatedAt = createdAt.Time
    }
    if updatedAt.Valid {
        j.UpdatedAt = updatedAt.Time
    }
    return &j, nil
}

func (r *OpenLineageRepository) ListJobs(ctx context.Context, namespaceID string, limit, offset int) ([]domain.OpenLineageJob, int, error) {
    countQuery := `SELECT COUNT(*) FROM demo_user.OL_JOB WHERE namespace_id = ?`
    var total int
    if err := r.db.QueryRowContext(ctx, countQuery, namespaceID).Scan(&total); err != nil {
        return nil, 0, fmt.Errorf("count jobs: %w", err)
    }

    query := `
        SELECT job_id, namespace_id, name, description, job_type, created_at, updated_at
        FROM demo_user.OL_JOB
        WHERE namespace_id = ?
        ORDER BY name
        OFFSET ? ROWS FETCH NEXT ? ROWS ONLY`

    rows, err := r.db.QueryContext(ctx, query, namespaceID, offset, limit)
    if err != nil {
        return nil, 0, fmt.Errorf("list jobs: %w", err)
    }
    defer rows.Close()

    var jobs []domain.OpenLineageJob
    for rows.Next() {
        var j domain.OpenLineageJob
        var description, jobType sql.NullString
        var createdAt, updatedAt sql.NullTime

        if err := rows.Scan(&j.ID, &j.NamespaceID, &j.Name, &description, &jobType,
            &createdAt, &updatedAt); err != nil {
            return nil, 0, fmt.Errorf("scan job: %w", err)
        }
        j.Description = description.String
        j.JobType = jobType.String
        if createdAt.Valid {
            j.CreatedAt = createdAt.Time
        }
        if updatedAt.Valid {
            j.UpdatedAt = updatedAt.Time
        }
        jobs = append(jobs, j)
    }
    return jobs, total, rows.Err()
}

// Run operations

func (r *OpenLineageRepository) GetRun(ctx context.Context, runID string) (*domain.OpenLineageRun, error) {
    query := `
        SELECT run_id, job_id, event_type, event_time, nominal_start_time, nominal_end_time, producer, schema_url, created_at
        FROM demo_user.OL_RUN
        WHERE run_id = ?`

    var run domain.OpenLineageRun
    var eventType, producer, schemaURL sql.NullString
    var eventTime, nominalStart, nominalEnd, createdAt sql.NullTime

    err := r.db.QueryRowContext(ctx, query, runID).Scan(
        &run.ID, &run.JobID, &eventType, &eventTime,
        &nominalStart, &nominalEnd, &producer, &schemaURL, &createdAt,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get run: %w", err)
    }

    run.EventType = eventType.String
    run.Producer = producer.String
    run.SchemaURL = schemaURL.String
    if eventTime.Valid {
        run.EventTime = eventTime.Time
    }
    if nominalStart.Valid {
        run.NominalStartTime = nominalStart.Time
    }
    if nominalEnd.Valid {
        run.NominalEndTime = nominalEnd.Time
    }
    if createdAt.Valid {
        run.CreatedAt = createdAt.Time
    }
    return &run, nil
}

func (r *OpenLineageRepository) ListRuns(ctx context.Context, jobID string, limit int) ([]domain.OpenLineageRun, error) {
    query := `
        SELECT run_id, job_id, event_type, event_time, nominal_start_time, nominal_end_time, producer, schema_url, created_at
        FROM demo_user.OL_RUN
        WHERE job_id = ?
        ORDER BY event_time DESC
        FETCH FIRST ? ROWS ONLY`

    rows, err := r.db.QueryContext(ctx, query, jobID, limit)
    if err != nil {
        return nil, fmt.Errorf("list runs: %w", err)
    }
    defer rows.Close()

    var runs []domain.OpenLineageRun
    for rows.Next() {
        var run domain.OpenLineageRun
        var eventType, producer, schemaURL sql.NullString
        var eventTime, nominalStart, nominalEnd, createdAt sql.NullTime

        if err := rows.Scan(&run.ID, &run.JobID, &eventType, &eventTime,
            &nominalStart, &nominalEnd, &producer, &schemaURL, &createdAt); err != nil {
            return nil, fmt.Errorf("scan run: %w", err)
        }
        run.EventType = eventType.String
        run.Producer = producer.String
        run.SchemaURL = schemaURL.String
        if eventTime.Valid {
            run.EventTime = eventTime.Time
        }
        if nominalStart.Valid {
            run.NominalStartTime = nominalStart.Time
        }
        if nominalEnd.Valid {
            run.NominalEndTime = nominalEnd.Time
        }
        if createdAt.Valid {
            run.CreatedAt = createdAt.Time
        }
        runs = append(runs, run)
    }
    return runs, rows.Err()
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify code compiles.</verify>
  <done>openlineage_repo.go created with all basic CRUD operations for namespaces, datasets, fields, jobs, and runs.</done>
</task>

<task type="auto">
  <name>Task 2: Add lineage traversal methods</name>
  <files>lineage-api/internal/adapter/outbound/teradata/openlineage_repo.go</files>
  <action>
Add the lineage traversal methods using recursive CTEs. Append to the existing file:

```go
// Lineage operations

func (r *OpenLineageRepository) GetColumnLineage(ctx context.Context, datasetID, fieldName string, direction string, maxDepth int) ([]domain.OpenLineageColumnLineage, error) {
    // Build recursive CTE based on direction
    var query string
    switch direction {
    case "upstream":
        query = r.buildUpstreamQuery(maxDepth)
    case "downstream":
        query = r.buildDownstreamQuery(maxDepth)
    case "both":
        query = r.buildBidirectionalQuery(maxDepth)
    default:
        query = r.buildBidirectionalQuery(maxDepth)
    }

    rows, err := r.db.QueryContext(ctx, query, datasetID, fieldName)
    if err != nil {
        return nil, fmt.Errorf("get column lineage: %w", err)
    }
    defer rows.Close()

    var lineages []domain.OpenLineageColumnLineage
    for rows.Next() {
        var l domain.OpenLineageColumnLineage
        var runID, transDesc sql.NullString
        var transType, transSubtype string
        var masking, isActive string
        var confScore sql.NullFloat64
        var discoveredAt sql.NullTime
        var depth int

        if err := rows.Scan(
            &l.ID, &runID, &l.SourceNamespace, &l.SourceDataset, &l.SourceField,
            &l.TargetNamespace, &l.TargetDataset, &l.TargetField,
            &transType, &transSubtype, &transDesc, &masking, &confScore,
            &discoveredAt, &isActive, &depth,
        ); err != nil {
            return nil, fmt.Errorf("scan lineage: %w", err)
        }

        l.RunID = runID.String
        l.TransformationType = domain.TransformationType(transType)
        l.TransformationSubtype = domain.TransformationSubtype(transSubtype)
        l.TransformationDescription = transDesc.String
        l.Masking = masking == "Y"
        l.IsActive = isActive == "Y"
        l.Depth = depth
        if confScore.Valid {
            l.ConfidenceScore = confScore.Float64
        }
        if discoveredAt.Valid {
            l.DiscoveredAt = discoveredAt.Time
        }
        lineages = append(lineages, l)
    }
    return lineages, rows.Err()
}

func (r *OpenLineageRepository) buildUpstreamQuery(maxDepth int) string {
    return fmt.Sprintf(`
        WITH RECURSIVE lineage_path (
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth, path
        ) AS (
            -- Base case: direct upstream of target
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                1 AS depth,
                CAST(l.lineage_id AS VARCHAR(4000)) AS path
            FROM demo_user.OL_COLUMN_LINEAGE l
            WHERE l.target_dataset = ? AND l.target_field = ? AND l.is_active = 'Y'

            UNION ALL

            -- Recursive case: traverse upstream
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                lp.depth + 1,
                lp.path || ',' || l.lineage_id
            FROM demo_user.OL_COLUMN_LINEAGE l
            INNER JOIN lineage_path lp
                ON l.target_dataset = lp.source_dataset
                AND l.target_field = lp.source_field
            WHERE l.is_active = 'Y'
                AND lp.depth < %d
                AND POSITION(l.lineage_id IN lp.path) = 0
        )
        SELECT DISTINCT
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth
        FROM lineage_path
        ORDER BY depth`, maxDepth)
}

func (r *OpenLineageRepository) buildDownstreamQuery(maxDepth int) string {
    return fmt.Sprintf(`
        WITH RECURSIVE lineage_path (
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth, path
        ) AS (
            -- Base case: direct downstream of source
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                1 AS depth,
                CAST(l.lineage_id AS VARCHAR(4000)) AS path
            FROM demo_user.OL_COLUMN_LINEAGE l
            WHERE l.source_dataset = ? AND l.source_field = ? AND l.is_active = 'Y'

            UNION ALL

            -- Recursive case: traverse downstream
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                lp.depth + 1,
                lp.path || ',' || l.lineage_id
            FROM demo_user.OL_COLUMN_LINEAGE l
            INNER JOIN lineage_path lp
                ON l.source_dataset = lp.target_dataset
                AND l.source_field = lp.target_field
            WHERE l.is_active = 'Y'
                AND lp.depth < %d
                AND POSITION(l.lineage_id IN lp.path) = 0
        )
        SELECT DISTINCT
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth
        FROM lineage_path
        ORDER BY depth`, maxDepth)
}

func (r *OpenLineageRepository) buildBidirectionalQuery(maxDepth int) string {
    // For bidirectional, we combine upstream and downstream results
    return fmt.Sprintf(`
        WITH RECURSIVE upstream_path (
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth, path
        ) AS (
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                1 AS depth,
                CAST(l.lineage_id AS VARCHAR(4000)) AS path
            FROM demo_user.OL_COLUMN_LINEAGE l
            WHERE l.target_dataset = ? AND l.target_field = ? AND l.is_active = 'Y'
            UNION ALL
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                up.depth + 1,
                up.path || ',' || l.lineage_id
            FROM demo_user.OL_COLUMN_LINEAGE l
            INNER JOIN upstream_path up
                ON l.target_dataset = up.source_dataset
                AND l.target_field = up.source_field
            WHERE l.is_active = 'Y'
                AND up.depth < %d
                AND POSITION(l.lineage_id IN up.path) = 0
        ),
        downstream_path (
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth, path
        ) AS (
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                1 AS depth,
                CAST(l.lineage_id AS VARCHAR(4000)) AS path
            FROM demo_user.OL_COLUMN_LINEAGE l
            WHERE l.source_dataset = ? AND l.source_field = ? AND l.is_active = 'Y'
            UNION ALL
            SELECT
                l.lineage_id, l.run_id, l.source_namespace, l.source_dataset, l.source_field,
                l.target_namespace, l.target_dataset, l.target_field,
                l.transformation_type, l.transformation_subtype, l.transformation_description,
                l.masking, l.confidence_score, l.discovered_at, l.is_active,
                dp.depth + 1,
                dp.path || ',' || l.lineage_id
            FROM demo_user.OL_COLUMN_LINEAGE l
            INNER JOIN downstream_path dp
                ON l.source_dataset = dp.target_dataset
                AND l.source_field = dp.target_field
            WHERE l.is_active = 'Y'
                AND dp.depth < %d
                AND POSITION(l.lineage_id IN dp.path) = 0
        )
        SELECT DISTINCT
            lineage_id, run_id, source_namespace, source_dataset, source_field,
            target_namespace, target_dataset, target_field,
            transformation_type, transformation_subtype, transformation_description,
            masking, confidence_score, discovered_at, is_active, depth
        FROM (
            SELECT * FROM upstream_path
            UNION
            SELECT * FROM downstream_path
        ) combined
        ORDER BY depth`, maxDepth, maxDepth)
}

func (r *OpenLineageRepository) GetColumnLineageGraph(ctx context.Context, datasetID, fieldName string, direction string, maxDepth int) (*domain.OpenLineageGraph, error) {
    lineages, err := r.GetColumnLineage(ctx, datasetID, fieldName, direction, maxDepth)
    if err != nil {
        return nil, err
    }

    graph := &domain.OpenLineageGraph{
        Nodes: []domain.OpenLineageNode{},
        Edges: []domain.OpenLineageEdge{},
    }

    nodeMap := make(map[string]bool)

    // Add the seed node
    seedNodeID := fmt.Sprintf("%s/%s", datasetID, fieldName)
    graph.Nodes = append(graph.Nodes, domain.OpenLineageNode{
        ID:      seedNodeID,
        Type:    "field",
        Dataset: datasetID,
        Field:   fieldName,
    })
    nodeMap[seedNodeID] = true

    // Build nodes and edges from lineage records
    for _, l := range lineages {
        // Source node
        srcNodeID := fmt.Sprintf("%s/%s", l.SourceDataset, l.SourceField)
        if !nodeMap[srcNodeID] {
            graph.Nodes = append(graph.Nodes, domain.OpenLineageNode{
                ID:        srcNodeID,
                Type:      "field",
                Namespace: l.SourceNamespace,
                Dataset:   l.SourceDataset,
                Field:     l.SourceField,
            })
            nodeMap[srcNodeID] = true
        }

        // Target node
        tgtNodeID := fmt.Sprintf("%s/%s", l.TargetDataset, l.TargetField)
        if !nodeMap[tgtNodeID] {
            graph.Nodes = append(graph.Nodes, domain.OpenLineageNode{
                ID:        tgtNodeID,
                Type:      "field",
                Namespace: l.TargetNamespace,
                Dataset:   l.TargetDataset,
                Field:     l.TargetField,
            })
            nodeMap[tgtNodeID] = true
        }

        // Edge
        graph.Edges = append(graph.Edges, domain.OpenLineageEdge{
            ID:                    l.ID,
            Source:                srcNodeID,
            Target:                tgtNodeID,
            TransformationType:    l.TransformationType,
            TransformationSubtype: l.TransformationSubtype,
            ConfidenceScore:       l.ConfidenceScore,
        })
    }

    return graph, nil
}
```
  </action>
  <verify>Run `go build ./...` from lineage-api directory to verify code compiles.</verify>
  <done>Lineage traversal methods added with recursive CTEs for upstream, downstream, and bidirectional queries.</done>
</task>

<task type="auto">
  <name>Task 3: Add repository tests</name>
  <files>lineage-api/internal/adapter/outbound/teradata/openlineage_repo_test.go</files>
  <action>
Create a new test file with unit tests for the repository:

```go
package teradata

import (
    "testing"

    "github.com/lineage-app/lineage-api/internal/domain"
)

func TestNewOpenLineageRepository(t *testing.T) {
    repo := NewOpenLineageRepository(nil)
    if repo == nil {
        t.Error("NewOpenLineageRepository returned nil")
    }
}

func TestBuildUpstreamQuery(t *testing.T) {
    repo := &OpenLineageRepository{}
    query := repo.buildUpstreamQuery(5)

    // Verify query contains key elements
    if query == "" {
        t.Error("buildUpstreamQuery returned empty query")
    }

    // Check for recursive CTE structure
    expectedPatterns := []string{
        "WITH RECURSIVE",
        "lineage_path",
        "OL_COLUMN_LINEAGE",
        "target_dataset = ?",
        "target_field = ?",
        "depth + 1",
        "depth < 5",
    }

    for _, pattern := range expectedPatterns {
        if !containsString(query, pattern) {
            t.Errorf("buildUpstreamQuery missing pattern: %s", pattern)
        }
    }
}

func TestBuildDownstreamQuery(t *testing.T) {
    repo := &OpenLineageRepository{}
    query := repo.buildDownstreamQuery(10)

    expectedPatterns := []string{
        "WITH RECURSIVE",
        "source_dataset = ?",
        "source_field = ?",
        "depth < 10",
    }

    for _, pattern := range expectedPatterns {
        if !containsString(query, pattern) {
            t.Errorf("buildDownstreamQuery missing pattern: %s", pattern)
        }
    }
}

func TestBuildBidirectionalQuery(t *testing.T) {
    repo := &OpenLineageRepository{}
    query := repo.buildBidirectionalQuery(3)

    expectedPatterns := []string{
        "upstream_path",
        "downstream_path",
        "UNION",
        "depth < 3",
    }

    for _, pattern := range expectedPatterns {
        if !containsString(query, pattern) {
            t.Errorf("buildBidirectionalQuery missing pattern: %s", pattern)
        }
    }
}

func TestInterfaceCompliance(t *testing.T) {
    // Verify OpenLineageRepository implements domain.OpenLineageRepository
    var _ domain.OpenLineageRepository = (*OpenLineageRepository)(nil)
}

// Helper function
func containsString(s, substr string) bool {
    return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsStringSearch(s, substr))
}

func containsStringSearch(s, substr string) bool {
    for i := 0; i <= len(s)-len(substr); i++ {
        if s[i:i+len(substr)] == substr {
            return true
        }
    }
    return false
}
```
  </action>
  <verify>Run `go test ./internal/adapter/outbound/teradata/...` from lineage-api directory to verify tests pass.</verify>
  <done>Repository tests created verifying query construction and interface compliance.</done>
</task>

</tasks>

<verification>
1. Build: `cd lineage-api && go build ./...`
2. Test: `cd lineage-api && go test ./internal/adapter/outbound/teradata/...`
3. Code review: Verify recursive CTE includes cycle detection (path tracking)
4. Code review: Verify maxDepth is enforced in all query builders
5. Code review: Verify interface compliance check passes
</verification>

<success_criteria>
- Go code compiles without errors
- All repository tests pass
- Recursive CTEs include cycle detection via path tracking
- Direction parameter properly routes to correct query builder
- Graph building extracts unique nodes and creates proper edges
</success_criteria>

<output>
After completion, create `.planning/phases/08-open-lineage-standard-alignment/08-04-SUMMARY.md`
</output>
