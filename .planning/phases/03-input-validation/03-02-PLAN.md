---
phase: 03-input-validation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lineage-api/internal/adapter/inbound/http/handlers.go
  - lineage-api/cmd/server/main.go
  - lineage-api/internal/adapter/inbound/http/handlers_test.go
autonomous: true

must_haves:
  truths:
    - "API returns 400 Bad Request when maxDepth is less than 1 or greater than 20"
    - "API returns 400 Bad Request when direction is not upstream, downstream, or both"
    - "Validation error responses include error code, descriptive message, and request ID"
    - "Empty/omitted parameters use defaults (not errors)"
  artifacts:
    - path: "lineage-api/internal/adapter/inbound/http/handlers.go"
      provides: "Handlers with validation before service calls"
      contains: "parseAndValidateLineageParams"
    - path: "lineage-api/cmd/server/main.go"
      provides: "Validation config initialization at startup"
      contains: "SetValidationConfig"
    - path: "lineage-api/internal/adapter/inbound/http/handlers_test.go"
      provides: "Unit tests for validation edge cases"
      min_lines: 150
  key_links:
    - from: "lineage-api/internal/adapter/inbound/http/handlers.go"
      to: "validation.go"
      via: "validation function calls"
      pattern: "parseAndValidateLineageParams|respondValidationError"
    - from: "lineage-api/cmd/server/main.go"
      to: "http.SetValidationConfig"
      via: "initialization at startup"
      pattern: "SetValidationConfig"
---

<objective>
Integrate validation into handlers and add comprehensive unit tests for validation edge cases.

Purpose: Complete the input validation implementation by wiring validation into all relevant handlers (GetLineage, GetUpstreamLineage, GetDownstreamLineage, GetImpactAnalysis) and ensuring robust test coverage. This completes requirements VALID-01, VALID-02, VALID-03, and TEST-01.

Output:
- Updated `handlers.go` with validation calls before service invocation
- Updated `main.go` to initialize validation config at startup
- New/updated `handlers_test.go` with validation edge case tests
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-input-validation/03-RESEARCH.md
@.planning/phases/03-input-validation/03-01-SUMMARY.md

# Source files to modify
@lineage-api/internal/adapter/inbound/http/handlers.go
@lineage-api/internal/adapter/inbound/http/validation.go
@lineage-api/cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize validation config at startup</name>
  <files>lineage-api/cmd/server/main.go</files>
  <action>
Update `lineage-api/cmd/server/main.go` to initialize validation configuration at startup:

1. After config is loaded (after `cfg, err := config.Load()`), add:
```go
// Initialize validation configuration from loaded config
inboundhttp.SetValidationConfig(
    cfg.Validation.MinMaxDepth,
    cfg.Validation.MaxDepthLimit,
    cfg.Validation.DefaultMaxDepth,
)
```

2. Add import for the http package if not present:
```go
inboundhttp "github.com/lineage-api/internal/adapter/inbound/http"
```

Note: If the import alias `inboundhttp` conflicts with existing code, use a different alias like `httphandlers`. Check existing imports first.

This ensures validation bounds are set from environment variables before any requests are handled.
  </action>
  <verify>
Run `go build ./cmd/server/main.go` from lineage-api directory - compilation succeeds.
Verify SetValidationConfig call exists in main.go.
  </verify>
  <done>
- main.go calls SetValidationConfig with values from cfg.Validation
- Validation bounds initialized before HTTP server starts
  </done>
</task>

<task type="auto">
  <name>Task 2: Update handlers to use validation</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers.go</files>
  <action>
Update `lineage-api/internal/adapter/inbound/http/handlers.go` to add validation before service calls.

**Update GetLineage handler** (lines 81-111):
Replace the current parameter parsing (lines 85-96) with validation:
```go
func (h *Handler) GetLineage(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    assetID := chi.URLParam(r, "assetId")

    // Validate parameters - returns 400 if invalid
    direction, maxDepth, validationErrors := parseAndValidateLineageParams(r)
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    req := application.GetLineageRequest{
        AssetID:   assetID,
        Direction: direction,
        MaxDepth:  maxDepth,
    }

    response, err := h.lineageService.GetLineageGraph(ctx, req)
    if err != nil {
        respondError(w, http.StatusInternalServerError, err.Error())
        return
    }

    respondJSON(w, http.StatusOK, response)
}
```

**Update GetUpstreamLineage handler** (lines 113-132):
Replace parameter parsing with validation. Note: This uses defaultDepth of 10 currently.
```go
func (h *Handler) GetUpstreamLineage(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    assetID := chi.URLParam(r, "assetId")

    // Validate maxDepth - returns 400 if invalid
    maxDepth, validationErrors := parseAndValidateMaxDepth(r, 10) // Default 10 for upstream
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    response, err := h.lineageService.GetUpstreamLineage(ctx, assetID, maxDepth)
    if err != nil {
        respondError(w, http.StatusInternalServerError, err.Error())
        return
    }

    respondJSON(w, http.StatusOK, response)
}
```

**Update GetDownstreamLineage handler** (lines 134-153):
Same pattern as GetUpstreamLineage:
```go
func (h *Handler) GetDownstreamLineage(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    assetID := chi.URLParam(r, "assetId")

    // Validate maxDepth - returns 400 if invalid
    maxDepth, validationErrors := parseAndValidateMaxDepth(r, 10) // Default 10 for downstream
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    response, err := h.lineageService.GetDownstreamLineage(ctx, assetID, maxDepth)
    if err != nil {
        respondError(w, http.StatusInternalServerError, err.Error())
        return
    }

    respondJSON(w, http.StatusOK, response)
}
```

**Update GetImpactAnalysis handler** (lines 155-174):
Same pattern:
```go
func (h *Handler) GetImpactAnalysis(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    assetID := chi.URLParam(r, "assetId")

    // Validate maxDepth - returns 400 if invalid
    maxDepth, validationErrors := parseAndValidateMaxDepth(r, 10) // Default 10 for impact
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    response, err := h.lineageService.GetImpactAnalysis(ctx, assetID, maxDepth)
    if err != nil {
        respondError(w, http.StatusInternalServerError, err.Error())
        return
    }

    respondJSON(w, http.StatusOK, response)
}
```

**Do NOT modify the Search handler** - that will get pagination validation in Phase 4.

Remove the unused `strconv` import if no longer needed after changes.
  </action>
  <verify>
Run `go build ./...` from lineage-api directory - compilation succeeds.
Run quick manual test if Python server is available:
```bash
curl "http://localhost:8080/api/v1/lineage/col-001?maxDepth=-1"
# Should return 400 with validation error, not 200 with default
```
  </verify>
  <done>
- GetLineage uses parseAndValidateLineageParams (direction + maxDepth)
- GetUpstreamLineage, GetDownstreamLineage, GetImpactAnalysis use parseAndValidateMaxDepth
- Invalid parameters return 400 with ValidationErrorResponse
- Empty parameters use defaults (no error)
- strconv import removed if unused
  </done>
</task>

<task type="auto">
  <name>Task 3: Add validation unit tests</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers_test.go</files>
  <action>
Create or update `lineage-api/internal/adapter/inbound/http/handlers_test.go` with comprehensive validation tests.

**Test setup helper** (add if not exists):
```go
package http

import (
    "context"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/go-chi/chi/v5"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/lineage-api/internal/application"
    "github.com/lineage-api/internal/domain"
)

// Mock repository for testing
type mockLineageRepository struct {
    UpstreamData   map[string][]domain.ColumnLineage
    DownstreamData map[string][]domain.ColumnLineage
}

// ... implement mock methods as needed

// withChiURLParams adds chi URL parameters to a request for testing
func withChiURLParams(r *http.Request, params map[string]string) *http.Request {
    ctx := chi.NewRouteContext()
    for k, v := range params {
        ctx.URLParams.Add(k, v)
    }
    return r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
}
```

**TEST-01: maxDepth validation edge cases**:
```go
func TestGetLineage_MaxDepthValidation(t *testing.T) {
    // Setup - ensure validation config is set
    SetValidationConfig(1, 20, 5)

    tests := []struct {
        name          string
        maxDepthParam string
        expectStatus  int
        expectError   bool
    }{
        // Valid cases
        {"valid min boundary", "1", http.StatusOK, false},
        {"valid max boundary", "20", http.StatusOK, false},
        {"valid mid-range", "10", http.StatusOK, false},
        {"empty uses default", "", http.StatusOK, false},

        // Invalid: below minimum
        {"zero", "0", http.StatusBadRequest, true},
        {"negative", "-1", http.StatusBadRequest, true},
        {"large negative", "-999", http.StatusBadRequest, true},

        // Invalid: above maximum
        {"above max", "21", http.StatusBadRequest, true},
        {"way above max", "100", http.StatusBadRequest, true},
        {"extreme value", "999999", http.StatusBadRequest, true},

        // Invalid: non-integer
        {"string value", "abc", http.StatusBadRequest, true},
        {"float value", "5.5", http.StatusBadRequest, true},
        {"null string", "null", http.StatusBadRequest, true},
        {"special chars", "5; DROP TABLE", http.StatusBadRequest, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup handler with mock service
            handler := setupTestHandler()

            url := "/api/v1/lineage/col-001"
            if tt.maxDepthParam != "" {
                url += "?maxDepth=" + tt.maxDepthParam
            }

            req := httptest.NewRequest("GET", url, nil)
            req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
            w := httptest.NewRecorder()

            handler.GetLineage(w, req)

            assert.Equal(t, tt.expectStatus, w.Code, "status code mismatch")

            if tt.expectError {
                var response ValidationErrorResponse
                err := json.Unmarshal(w.Body.Bytes(), &response)
                require.NoError(t, err, "response should be valid JSON")
                assert.Equal(t, "VALIDATION_ERROR", response.Code)
                assert.Contains(t, w.Body.String(), "maxDepth")
            }
        })
    }
}
```

**TEST-01: direction validation edge cases**:
```go
func TestGetLineage_DirectionValidation(t *testing.T) {
    SetValidationConfig(1, 20, 5)

    tests := []struct {
        name         string
        direction    string
        expectStatus int
        expectError  bool
    }{
        // Valid cases
        {"upstream lowercase", "upstream", http.StatusOK, false},
        {"downstream lowercase", "downstream", http.StatusOK, false},
        {"both lowercase", "both", http.StatusOK, false},
        {"empty uses default both", "", http.StatusOK, false},

        // Invalid: wrong case
        {"wrong case UPSTREAM", "UPSTREAM", http.StatusBadRequest, true},
        {"wrong case Both", "Both", http.StatusBadRequest, true},
        {"wrong case Downstream", "Downstream", http.StatusBadRequest, true},

        // Invalid: unknown values
        {"invalid value", "invalid", http.StatusBadRequest, true},
        {"typo upsteam", "upsteam", http.StatusBadRequest, true},
        {"number", "1", http.StatusBadRequest, true},
        {"special chars", "up;stream", http.StatusBadRequest, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            handler := setupTestHandler()

            url := "/api/v1/lineage/col-001"
            if tt.direction != "" {
                url += "?direction=" + tt.direction
            }

            req := httptest.NewRequest("GET", url, nil)
            req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
            w := httptest.NewRecorder()

            handler.GetLineage(w, req)

            assert.Equal(t, tt.expectStatus, w.Code)

            if tt.expectError {
                var response ValidationErrorResponse
                err := json.Unmarshal(w.Body.Bytes(), &response)
                require.NoError(t, err)
                assert.Equal(t, "VALIDATION_ERROR", response.Code)
                assert.Contains(t, w.Body.String(), "direction")
            }
        })
    }
}
```

**VALID-03: Validation error response structure**:
```go
func TestValidationErrorResponse_Structure(t *testing.T) {
    SetValidationConfig(1, 20, 5)
    handler := setupTestHandler()

    // Send request with multiple validation errors
    req := httptest.NewRequest("GET", "/api/v1/lineage/col-001?maxDepth=-1&direction=invalid", nil)
    req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
    w := httptest.NewRecorder()

    handler.GetLineage(w, req)

    assert.Equal(t, http.StatusBadRequest, w.Code)
    assert.Equal(t, "application/json", w.Header().Get("Content-Type"))

    var response ValidationErrorResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    // VALID-03 requirements
    assert.Equal(t, "VALIDATION_ERROR", response.Code, "must include error code")
    assert.Equal(t, "Validation failed", response.Error, "must include error message")
    assert.NotEmpty(t, response.RequestID, "must include request ID")
    assert.GreaterOrEqual(t, len(response.Details), 2, "should report multiple field errors")

    // Verify field-level details
    fields := make(map[string]bool)
    for _, detail := range response.Details {
        fields[detail.Field] = true
        assert.NotEmpty(t, detail.Message, "each field error must have message")
    }
    assert.True(t, fields["maxDepth"], "should include maxDepth error")
    assert.True(t, fields["direction"], "should include direction error")
}
```

**Additional tests for other endpoints**:
```go
func TestGetUpstreamLineage_MaxDepthValidation(t *testing.T) {
    SetValidationConfig(1, 20, 5)
    handler := setupTestHandler()

    // Invalid maxDepth should return 400
    req := httptest.NewRequest("GET", "/api/v1/lineage/col-001/upstream?maxDepth=999", nil)
    req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
    w := httptest.NewRecorder()

    handler.GetUpstreamLineage(w, req)

    assert.Equal(t, http.StatusBadRequest, w.Code)
    assert.Contains(t, w.Body.String(), "maxDepth")
}

func TestGetDownstreamLineage_MaxDepthValidation(t *testing.T) {
    SetValidationConfig(1, 20, 5)
    handler := setupTestHandler()

    req := httptest.NewRequest("GET", "/api/v1/lineage/col-001/downstream?maxDepth=-5", nil)
    req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
    w := httptest.NewRecorder()

    handler.GetDownstreamLineage(w, req)

    assert.Equal(t, http.StatusBadRequest, w.Code)
}

func TestGetImpactAnalysis_MaxDepthValidation(t *testing.T) {
    SetValidationConfig(1, 20, 5)
    handler := setupTestHandler()

    req := httptest.NewRequest("GET", "/api/v1/lineage/col-001/impact?maxDepth=abc", nil)
    req = withChiURLParams(req, map[string]string{"assetId": "col-001"})
    w := httptest.NewRecorder()

    handler.GetImpactAnalysis(w, req)

    assert.Equal(t, http.StatusBadRequest, w.Code)
}
```

You will need to create a proper `setupTestHandler()` function that creates mock services. Check if there's existing test infrastructure in the codebase. If not, create minimal mocks that return empty successful responses for valid requests.

Note: The research provided detailed test cases - adapt them to match the actual test infrastructure in the project.
  </action>
  <verify>
Run `go test ./internal/adapter/inbound/http/...` from lineage-api directory - all tests pass.
Verify test count includes validation tests.
  </verify>
  <done>
- handlers_test.go has TestGetLineage_MaxDepthValidation with boundary tests
- handlers_test.go has TestGetLineage_DirectionValidation with allowlist tests
- handlers_test.go has TestValidationErrorResponse_Structure verifying VALID-03
- handlers_test.go has tests for upstream/downstream/impact validation
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./...` succeeds
2. `go test ./internal/adapter/inbound/http/...` passes
3. Manual verification (if server running):
   - `curl localhost:8080/api/v1/lineage/col-001?maxDepth=-1` returns 400
   - `curl localhost:8080/api/v1/lineage/col-001?direction=invalid` returns 400
   - `curl localhost:8080/api/v1/lineage/col-001` returns 200 (defaults work)
</verification>

<success_criteria>
- [x] main.go initializes validation config from environment variables at startup
- [x] GetLineage validates direction (VALID-02) and maxDepth (VALID-01)
- [x] GetUpstreamLineage, GetDownstreamLineage, GetImpactAnalysis validate maxDepth
- [x] Invalid parameters return HTTP 400 with VALIDATION_ERROR code (VALID-03)
- [x] Empty/omitted parameters use defaults (no error)
- [x] Unit tests cover: zero, negative, above max, non-integer, invalid direction (TEST-01)
- [x] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-validation/03-02-SUMMARY.md`
</output>
