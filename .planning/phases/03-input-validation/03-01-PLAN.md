---
phase: 03-input-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-api/internal/infrastructure/config/config.go
  - lineage-api/internal/adapter/inbound/http/validation.go
autonomous: true

must_haves:
  truths:
    - "Validation limits are loaded from environment variables at startup"
    - "Default validation values exist when env vars not set"
    - "Validation module provides reusable parsing/validation functions"
  artifacts:
    - path: "lineage-api/internal/infrastructure/config/config.go"
      provides: "ValidationConfig struct with MaxDepth limits"
      contains: "ValidationConfig"
    - path: "lineage-api/internal/adapter/inbound/http/validation.go"
      provides: "Validation types and functions"
      exports: ["ValidationErrorResponse", "FieldError", "parseAndValidateLineageParams"]
      min_lines: 60
  key_links:
    - from: "lineage-api/internal/infrastructure/config/config.go"
      to: "spf13/viper"
      via: "SetDefault and GetInt"
      pattern: "viper\\.SetDefault.*MAX_DEPTH"
    - from: "lineage-api/internal/adapter/inbound/http/validation.go"
      to: "config"
      via: "uses validation config values"
      pattern: "ValidDirections|MinMaxDepth|MaxMaxDepth"
---

<objective>
Create validation infrastructure: configurable validation limits and reusable validation functions for lineage query parameters.

Purpose: Establish configurable validation bounds (VALID-04) and a validation module that can be used by all handlers that accept maxDepth and direction parameters. This separates validation logic from handler code and ensures consistent error responses.

Output:
- Updated `config.go` with ValidationConfig struct and env var bindings
- New `validation.go` with ValidationErrorResponse, FieldError, and parsing functions
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-input-validation/03-RESEARCH.md

# Source files to modify/reference
@lineage-api/internal/infrastructure/config/config.go
@lineage-api/internal/adapter/inbound/http/response.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation configuration to config.go</name>
  <files>lineage-api/internal/infrastructure/config/config.go</files>
  <action>
Update `lineage-api/internal/infrastructure/config/config.go` to add validation configuration:

1. Add `ValidationConfig` struct:
```go
// ValidationConfig holds validation-specific configuration
type ValidationConfig struct {
    MaxDepthLimit   int // Upper bound for maxDepth parameter (default: 20)
    DefaultMaxDepth int // Default when not specified (default: 5)
    MinMaxDepth     int // Lower bound for maxDepth parameter (default: 1)
}
```

2. Add `Validation ValidationConfig` field to the main `Config` struct

3. In the `Load()` function, add defaults using Viper:
```go
viper.SetDefault("VALIDATION_MAX_DEPTH_LIMIT", 20)
viper.SetDefault("VALIDATION_DEFAULT_MAX_DEPTH", 5)
viper.SetDefault("VALIDATION_MIN_MAX_DEPTH", 1)
```

4. Populate the Validation field in the returned Config:
```go
Validation: ValidationConfig{
    MaxDepthLimit:   viper.GetInt("VALIDATION_MAX_DEPTH_LIMIT"),
    DefaultMaxDepth: viper.GetInt("VALIDATION_DEFAULT_MAX_DEPTH"),
    MinMaxDepth:     viper.GetInt("VALIDATION_MIN_MAX_DEPTH"),
},
```

5. Add validation of config values before returning (fail fast):
```go
// Validate configuration
if cfg.Validation.MinMaxDepth < 1 {
    return nil, fmt.Errorf("VALIDATION_MIN_MAX_DEPTH must be at least 1, got %d", cfg.Validation.MinMaxDepth)
}
if cfg.Validation.MaxDepthLimit < cfg.Validation.MinMaxDepth {
    return nil, fmt.Errorf("VALIDATION_MAX_DEPTH_LIMIT (%d) must be >= VALIDATION_MIN_MAX_DEPTH (%d)",
        cfg.Validation.MaxDepthLimit, cfg.Validation.MinMaxDepth)
}
if cfg.Validation.DefaultMaxDepth < cfg.Validation.MinMaxDepth ||
   cfg.Validation.DefaultMaxDepth > cfg.Validation.MaxDepthLimit {
    return nil, fmt.Errorf("VALIDATION_DEFAULT_MAX_DEPTH (%d) must be between %d and %d",
        cfg.Validation.DefaultMaxDepth, cfg.Validation.MinMaxDepth, cfg.Validation.MaxDepthLimit)
}
```

Add `"fmt"` to imports for the error formatting.

Note: Keep defaults matching current behavior (maxDepth defaults to 5 in handlers.go line 91, limit of 20 from project decision).
  </action>
  <verify>
Run `go build ./...` from lineage-api directory - compilation succeeds.
Verify ValidationConfig struct and fields exist in config.go.
  </verify>
  <done>
- ValidationConfig struct with MaxDepthLimit, DefaultMaxDepth, MinMaxDepth fields
- Environment variable bindings: VALIDATION_MAX_DEPTH_LIMIT, VALIDATION_DEFAULT_MAX_DEPTH, VALIDATION_MIN_MAX_DEPTH
- Configuration validation that fails fast on invalid combinations
- Default values: min=1, max=20, default=5
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation module</name>
  <files>lineage-api/internal/adapter/inbound/http/validation.go</files>
  <action>
Create new file `lineage-api/internal/adapter/inbound/http/validation.go` that provides:

1. **Validation error response types** (for VALID-03):
```go
package http

// ValidationErrorResponse is returned for all validation failures (HTTP 400)
type ValidationErrorResponse struct {
    Error     string       `json:"error"`      // Generic message: "Validation failed"
    Code      string       `json:"code"`       // Machine-readable: "VALIDATION_ERROR"
    RequestID string       `json:"request_id"` // For correlation with logs
    Details   []FieldError `json:"details"`    // Field-level errors
}

// FieldError describes a single field validation failure
type FieldError struct {
    Field   string `json:"field"`   // Parameter name: "maxDepth", "direction"
    Message string `json:"message"` // Human-readable: "must be between 1 and 20"
}
```

2. **Package-level validation configuration** (set by handler during init):
```go
// Validation bounds - set from config during handler initialization
var (
    MinMaxDepth     = 1  // Will be overridden from config
    MaxMaxDepth     = 20 // Will be overridden from config
    DefaultMaxDepth = 5  // Will be overridden from config
)

// ValidDirections contains the allowlist of accepted direction values
var ValidDirections = map[string]bool{
    "upstream":   true,
    "downstream": true,
    "both":       true,
}

// SetValidationConfig updates the validation bounds from application config
func SetValidationConfig(min, max, defaultVal int) {
    MinMaxDepth = min
    MaxMaxDepth = max
    DefaultMaxDepth = defaultVal
}
```

3. **respondValidationError function**:
```go
import (
    "encoding/json"
    "net/http"

    "github.com/go-chi/chi/v5/middleware"
)

// respondValidationError writes a 400 response with validation error details
func respondValidationError(w http.ResponseWriter, r *http.Request, details []FieldError) {
    requestID := middleware.GetReqID(r.Context())

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusBadRequest)
    json.NewEncoder(w).Encode(ValidationErrorResponse{
        Error:     "Validation failed",
        Code:      "VALIDATION_ERROR",
        RequestID: requestID,
        Details:   details,
    })
}
```

4. **parseAndValidateLineageParams function** for maxDepth and direction:
```go
import (
    "fmt"
    "net/http"
    "strconv"
)

// parseAndValidateLineageParams extracts and validates maxDepth and direction query parameters.
// Returns validated values and any validation errors. If errors is non-empty, the returned
// values should not be used.
func parseAndValidateLineageParams(r *http.Request) (direction string, maxDepth int, errors []FieldError) {
    // Parse direction with default
    direction = r.URL.Query().Get("direction")
    if direction == "" {
        direction = "both" // Default when not specified
    } else if !ValidDirections[direction] {
        errors = append(errors, FieldError{
            Field:   "direction",
            Message: "must be one of: upstream, downstream, both",
        })
    }

    // Parse maxDepth with default
    maxDepthStr := r.URL.Query().Get("maxDepth")
    if maxDepthStr == "" {
        maxDepth = DefaultMaxDepth // Default when not specified
    } else {
        d, err := strconv.Atoi(maxDepthStr)
        if err != nil {
            errors = append(errors, FieldError{
                Field:   "maxDepth",
                Message: "must be a valid integer",
            })
        } else if d < MinMaxDepth || d > MaxMaxDepth {
            errors = append(errors, FieldError{
                Field:   "maxDepth",
                Message: fmt.Sprintf("must be between %d and %d", MinMaxDepth, MaxMaxDepth),
            })
        } else {
            maxDepth = d
        }
    }

    return direction, maxDepth, errors
}
```

5. **parseAndValidateMaxDepth function** for endpoints that only have maxDepth (upstream, downstream, impact):
```go
// parseAndValidateMaxDepth extracts and validates the maxDepth query parameter only.
// Used by upstream/downstream/impact endpoints that don't have a direction parameter.
func parseAndValidateMaxDepth(r *http.Request, defaultDepth int) (maxDepth int, errors []FieldError) {
    maxDepthStr := r.URL.Query().Get("maxDepth")
    if maxDepthStr == "" {
        return defaultDepth, nil
    }

    d, err := strconv.Atoi(maxDepthStr)
    if err != nil {
        return 0, []FieldError{{
            Field:   "maxDepth",
            Message: "must be a valid integer",
        }}
    }

    if d < MinMaxDepth || d > MaxMaxDepth {
        return 0, []FieldError{{
            Field:   "maxDepth",
            Message: fmt.Sprintf("must be between %d and %d", MinMaxDepth, MaxMaxDepth),
        }}
    }

    return d, nil
}
```

Important: Do NOT use go-playground/validator here. The research recommended it but for this scope (2 parameters), manual validation is cleaner and avoids adding a dependency. The validator library would be worthwhile if we had many more parameters to validate.
  </action>
  <verify>
Run `go build ./...` from lineage-api directory - compilation succeeds.
Verify validation.go exists with exported types and functions.
  </verify>
  <done>
- validation.go created with ValidationErrorResponse, FieldError types
- SetValidationConfig function to initialize from config
- respondValidationError function returns 400 with structured JSON
- parseAndValidateLineageParams validates direction and maxDepth
- parseAndValidateMaxDepth validates maxDepth only (for upstream/downstream/impact endpoints)
- ValidDirections map restricts to upstream/downstream/both
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `go build ./...` from lineage-api directory succeeds
2. config.go has ValidationConfig with env var bindings
3. validation.go has validation types and functions
4. No changes to handlers yet (that's Plan 02)
</verification>

<success_criteria>
- [x] ValidationConfig added to config.go with env var support (VALID-04)
- [x] Defaults: min=1, max=20, default=5 (matches existing behavior + project decision)
- [x] validation.go provides reusable validation functions
- [x] ValidationErrorResponse struct with error, code, request_id, details (VALID-03 structure)
- [x] Direction validation restricts to upstream/downstream/both (VALID-02 prep)
- [x] MaxDepth validation enforces bounds (VALID-01 prep)
- [x] All files compile
</success_criteria>

<output>
After completion, create `.planning/phases/03-input-validation/03-01-SUMMARY.md`
</output>
