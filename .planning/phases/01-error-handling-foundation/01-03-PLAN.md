---
phase: 01-error-handling-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lineage-api/internal/adapter/inbound/http/handlers_test.go
autonomous: true

must_haves:
  truths:
    - "Integration tests verify error responses contain no database schema information"
    - "Tests confirm request_id is present in error responses"
    - "Tests verify generic error message for all internal errors"
  artifacts:
    - path: "lineage-api/internal/adapter/inbound/http/handlers_test.go"
      provides: "Error response security tests"
      contains: "TestErrorResponseNoSensitiveData"
      min_lines: 100
  key_links:
    - from: "lineage-api/internal/adapter/inbound/http/handlers_test.go"
      to: "lineage-api/internal/adapter/inbound/http/handlers.go"
      via: "handler method invocation"
      pattern: "handler\\.(ListDatabases|GetLineage)"
---

<objective>
Create integration tests that verify error responses never expose sensitive database information and always include request IDs.

Purpose: Ensure security requirements SEC-03 and SEC-04 are verified by tests (TEST-02). Tests provide regression protection against future changes that might accidentally leak internal details.

Output:
- New or updated `lineage-api/internal/adapter/inbound/http/handlers_test.go` with security tests
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-error-handling-foundation/01-RESEARCH.md
@.planning/phases/01-error-handling-foundation/01-01-SUMMARY.md

# Test file location
@lineage-api/internal/adapter/inbound/http/handlers_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock services and test infrastructure</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers_test.go</files>
  <action>
Create or update `lineage-api/internal/adapter/inbound/http/handlers_test.go` with test infrastructure for error response testing.

1. Add required imports:
```go
import (
    "context"
    "encoding/json"
    "errors"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)
```

2. Create mock implementations for the services that can return errors:
```go
type mockAssetService struct {
    ListDatabasesErr error
    ListTablesErr    error
    ListColumnsErr   error
    // Add fields for return values if needed (nil for error tests)
}

func (m *mockAssetService) ListDatabases(ctx context.Context) ([]Database, error) {
    return nil, m.ListDatabasesErr
}
// ... implement other methods similarly

type mockLineageService struct {
    GetLineageGraphErr      error
    GetUpstreamLineageErr   error
    GetDownstreamLineageErr error
    GetImpactAnalysisErr    error
}

// ... implement interface methods

type mockSearchService struct {
    SearchErr error
}

// ... implement interface methods
```

3. Implement test helper function:
```go
func setupTestHandler(assetSvc *mockAssetService, lineageSvc *mockLineageService, searchSvc *mockSearchService) *Handler {
    // Create handler with mock services
    return NewHandler(assetSvc, lineageSvc, searchSvc)
}

// Helper to create request with Chi context and request ID
func newTestRequest(method, path string) *http.Request {
    req := httptest.NewRequest(method, path, nil)
    rctx := chi.NewRouteContext()
    ctx := context.WithValue(req.Context(), chi.RouteCtxKey, rctx)
    ctx = context.WithValue(ctx, middleware.RequestIDKey, "test-request-id-123")
    return req.WithContext(ctx)
}
```

4. Define the sensitive data patterns to check against:
```go
var sensitivePatterns = []string{
    "teradatasql",
    "SQLState",
    "clearscape.teradata.com",
    "demo_user",
    "password",
    "LIN_",
    "SELECT",
    "FROM",
    "Connection refused",
    "connection refused",
}
```
  </action>
  <verify>
Verify test file exists and mock structures are defined:
```bash
grep -c "type mockAssetService struct" lineage-api/internal/adapter/inbound/http/handlers_test.go
grep -c "type mockLineageService struct" lineage-api/internal/adapter/inbound/http/handlers_test.go
grep -c "type mockSearchService struct" lineage-api/internal/adapter/inbound/http/handlers_test.go
grep -c "func setupTestHandler" lineage-api/internal/adapter/inbound/http/handlers_test.go
```
Each should return 1.
File compiles: `go build ./internal/adapter/inbound/http/...`
  </verify>
  <done>
- mockAssetService struct defined with error fields
- mockLineageService struct defined with error fields
- mockSearchService struct defined with error fields
- setupTestHandler helper function exists
- newTestRequest helper creates requests with Chi context
- sensitivePatterns slice defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Create security test functions</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers_test.go</files>
  <action>
Add the security test functions to handlers_test.go:

1. Create test `TestErrorResponseNoSensitiveData` that:
```go
func TestErrorResponseNoSensitiveData(t *testing.T) {
    // Create error with sensitive details (simulates database error)
    mockErr := errors.New(
        "teradatasql.Error: [SQLState HY000] [Version 17.20.0] " +
        "Failed to connect to 'test-host.env.clearscape.teradata.com:1025' " +
        "as user 'demo_user' password='****': Connection refused",
    )

    mockAsset := &mockAssetService{ListDatabasesErr: mockErr}
    handler := setupTestHandler(mockAsset, nil, nil)

    req := newTestRequest("GET", "/api/v1/assets/databases")
    rr := httptest.NewRecorder()

    handler.ListDatabases(rr, req)

    // Verify status
    assert.Equal(t, http.StatusInternalServerError, rr.Code)

    // Parse response
    var resp map[string]interface{}
    err := json.Unmarshal(rr.Body.Bytes(), &resp)
    require.NoError(t, err)

    // Verify generic message
    assert.Equal(t, "Internal server error", resp["error"])

    // Verify request_id present
    assert.NotEmpty(t, resp["request_id"])

    // Verify NO sensitive data in response body
    body := rr.Body.String()
    for _, pattern := range sensitivePatterns {
        assert.NotContains(t, body, pattern, "Response should not contain: %s", pattern)
    }
}
```

2. Create test `TestErrorResponseHasRequestID` that:
```go
func TestErrorResponseHasRequestID(t *testing.T) {
    mockAsset := &mockAssetService{ListDatabasesErr: errors.New("any error")}
    handler := setupTestHandler(mockAsset, nil, nil)

    req := newTestRequest("GET", "/api/v1/assets/databases")
    rr := httptest.NewRecorder()

    handler.ListDatabases(rr, req)

    var resp map[string]interface{}
    err := json.Unmarshal(rr.Body.Bytes(), &resp)
    require.NoError(t, err)

    // Verify request_id field exists and is non-empty string
    requestID, ok := resp["request_id"].(string)
    assert.True(t, ok, "request_id should be a string")
    assert.NotEmpty(t, requestID, "request_id should not be empty")
}
```

3. Create table-driven test `TestAllHandlersReturnGenericError`:
```go
func TestAllHandlersReturnGenericError(t *testing.T) {
    testErr := errors.New("internal database error with LIN_TABLE SELECT FROM")

    tests := []struct {
        name        string
        setupMocks  func() (*mockAssetService, *mockLineageService, *mockSearchService)
        method      string
        path        string
        handlerFunc func(h *Handler, w http.ResponseWriter, r *http.Request)
    }{
        {
            name: "ListDatabases",
            setupMocks: func() (*mockAssetService, *mockLineageService, *mockSearchService) {
                return &mockAssetService{ListDatabasesErr: testErr}, nil, nil
            },
            method: "GET",
            path:   "/api/v1/assets/databases",
            handlerFunc: func(h *Handler, w http.ResponseWriter, r *http.Request) {
                h.ListDatabases(w, r)
            },
        },
        // ... add remaining 7 handlers (ListTables, ListColumns, GetLineage, etc.)
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            assetSvc, lineageSvc, searchSvc := tt.setupMocks()
            handler := setupTestHandler(assetSvc, lineageSvc, searchSvc)

            req := newTestRequest(tt.method, tt.path)
            // Add URL params if needed for path parameters
            rr := httptest.NewRecorder()

            tt.handlerFunc(handler, rr, req)

            assert.Equal(t, http.StatusInternalServerError, rr.Code)

            var resp map[string]interface{}
            err := json.Unmarshal(rr.Body.Bytes(), &resp)
            require.NoError(t, err)

            assert.Equal(t, "Internal server error", resp["error"])
            assert.NotEmpty(t, resp["request_id"])

            // Verify no sensitive data
            body := rr.Body.String()
            assert.NotContains(t, body, "LIN_TABLE")
            assert.NotContains(t, body, "SELECT")
            assert.NotContains(t, body, "FROM")
        })
    }
}
```

Important: Implement ALL 8 test cases in the table (ListDatabases, ListTables, ListColumns, GetLineage, GetUpstreamLineage, GetDownstreamLineage, GetImpactAnalysis, Search).
  </action>
  <verify>
Verify all three test functions exist:
```bash
grep -c "func TestErrorResponseNoSensitiveData" lineage-api/internal/adapter/inbound/http/handlers_test.go
grep -c "func TestErrorResponseHasRequestID" lineage-api/internal/adapter/inbound/http/handlers_test.go
grep -c "func TestAllHandlersReturnGenericError" lineage-api/internal/adapter/inbound/http/handlers_test.go
```
Each should return exactly 1.

Run tests: `cd lineage-api && go test -v ./internal/adapter/inbound/http/... -run "TestErrorResponse|TestAllHandlers"`
All tests pass.
  </verify>
  <done>
- TestErrorResponseNoSensitiveData function exists and tests sensitive data exclusion
- TestErrorResponseHasRequestID function exists and tests request_id presence
- TestAllHandlersReturnGenericError function exists with 8 test cases
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify complete test coverage</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers_test.go</files>
  <action>
Ensure test coverage is complete for all error handling paths:

1. Verify the table-driven test covers all 8 handlers:
   - ListDatabases error path
   - ListTables error path (with database URL param)
   - ListColumns error path (with database and table URL params)
   - GetLineage error path (with assetId URL param)
   - GetUpstreamLineage error path (with assetId URL param)
   - GetDownstreamLineage error path (with assetId URL param)
   - GetImpactAnalysis error path (with assetId URL param)
   - Search error path (with query string param)

2. For handlers requiring URL parameters, set them on the Chi route context:
```go
rctx := chi.NewRouteContext()
rctx.URLParams.Add("database", "test_db")
rctx.URLParams.Add("table", "test_table")
rctx.URLParams.Add("assetId", "col:test_db:test_table:test_col")
```

3. Run coverage report:
```bash
go test -coverprofile=coverage.out ./internal/adapter/inbound/http/...
go tool cover -func=coverage.out | grep handlers.go
```

4. Verify all required imports are present

Target: Each handler's error path should be executed at least once by tests.
  </action>
  <verify>
Run full test suite: `cd lineage-api && go test -v ./internal/adapter/inbound/http/...`
All tests pass.

Run coverage: `go test -cover ./internal/adapter/inbound/http/...`
Coverage percentage shown.

Count test cases in table test:
```bash
grep -c "name:" lineage-api/internal/adapter/inbound/http/handlers_test.go | head -1
```
Should show at least 8 named test cases.
  </verify>
  <done>
- All 8 handlers have error path test coverage
- URL parameters properly set for path-based handlers
- Tests pass without failures
- Coverage report shows error handling paths covered
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `go test -v ./internal/adapter/inbound/http/...` passes with all tests green
2. Verify test functions exist:
   - `grep -c "func TestErrorResponseNoSensitiveData" handlers_test.go` = 1
   - `grep -c "func TestErrorResponseHasRequestID" handlers_test.go` = 1
   - `grep -c "func TestAllHandlersReturnGenericError" handlers_test.go` = 1
3. Error response tests verify no sensitive data leakage
4. Tests are table-driven for maintainability
5. Coverage includes all 8 handler error paths
</verification>

<success_criteria>
- [x] TestErrorResponseNoSensitiveData exists and passes
- [x] TestErrorResponseHasRequestID exists and passes
- [x] TestAllHandlersReturnGenericError exists with 8 test cases and passes
- [x] All 8 handlers have error path coverage
- [x] No sensitive data (SQL, table names, connection strings) appears in any error response
- [x] Tests use testify/assert for clear assertions
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-handling-foundation/01-03-SUMMARY.md`
</output>
