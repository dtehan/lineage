---
phase: 30-graceful-degradation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-api/cmd/server/main.go
  - lineage-api/internal/adapter/outbound/redis/cache.go
  - lineage-api/internal/adapter/outbound/redis/cache_test.go
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
autonomous: true

must_haves:
  truths:
    - "Application starts successfully and accepts API requests when Redis is not running"
    - "API endpoints return correct data when Redis is unavailable (NoOpCache always misses, Teradata queried directly)"
    - "Redis connection failure is logged at WARNING level, not ERROR or FATAL"
    - "When Redis connects successfully, an INFO log confirms cache is active"
    - "NoOpCache is automatically substituted when Redis connection fails at startup"
  artifacts:
    - path: "lineage-api/cmd/server/main.go"
      provides: "Try-connect-or-fallback Redis wiring"
      contains: "slog.Warn"
    - path: "lineage-api/internal/adapter/outbound/redis/cache.go"
      provides: "NoOpCache with Close() method"
      contains: "func (c *NoOpCache) Close()"
    - path: "lineage-api/internal/adapter/outbound/redis/cache_test.go"
      provides: "NoOpCache Close() test"
      contains: "TestNoOpCache_Close"
    - path: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go"
      provides: "Integration test proving all methods work with real NoOpCache"
      contains: "TestCachedRepoWithNoOpCache"
  key_links:
    - from: "lineage-api/cmd/server/main.go"
      to: "lineage-api/internal/adapter/outbound/redis/cache.go"
      via: "redisAdapter.NewNoOpCache() fallback on connection error"
      pattern: "NewNoOpCache"
    - from: "lineage-api/cmd/server/main.go"
      to: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      via: "CachedOpenLineageRepository receives either Redis or NoOp cache"
      pattern: "NewCachedOpenLineageRepository.*cache"
---

<objective>
Replace the fail-fast Redis connection behavior in main.go with graceful degradation: attempt Redis, log a warning on failure, and substitute NoOpCache so the application starts and serves all requests correctly without Redis.

Purpose: Fulfills DEGRADE-01 through DEGRADE-05 -- the application must never fail to start or return errors due to cache infrastructure unavailability.

Output: Modified main.go with try-connect-or-fallback pattern, NoOpCache with Close() method, and tests proving the fallback path works for all cached methods.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-graceful-degradation/30-RESEARCH.md

@lineage-api/cmd/server/main.go
@lineage-api/internal/adapter/outbound/redis/cache.go
@lineage-api/internal/adapter/outbound/redis/cache_test.go
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
@lineage-api/internal/domain/repository.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Close() to NoOpCache and replace fail-fast with graceful fallback in main.go</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cache.go
    lineage-api/cmd/server/main.go
  </files>
  <action>
**Step 1: Add Close() to NoOpCache in cache.go**

Add a `Close() error` method to the `NoOpCache` struct at the end of the NoOpCache method block (after the `Exists` method, around line 119). This method returns nil and satisfies `io.Closer` for uniform cleanup:

```go
// Close is a no-op (satisfies io.Closer for uniform cleanup).
func (c *NoOpCache) Close() error {
	return nil
}
```

**Step 2: Replace the Redis fail-fast block in main.go**

Replace lines 46-51 in main.go (the current fail-fast Redis block):

```go
// Redis cache -- fail fast if unavailable (Phase 30 adds graceful degradation)
cacheRepo, err := redisAdapter.NewCacheRepository(cfg.Redis)
if err != nil {
    log.Fatalf("Failed to connect to Redis: %v", err)
}
defer cacheRepo.Close()
```

With this try-connect-or-fallback pattern:

```go
// Redis cache -- graceful degradation when unavailable
var cache domain.CacheRepository
redisRepo, err := redisAdapter.NewCacheRepository(cfg.Redis)
if err != nil {
    slog.Warn("Redis unavailable, running without cache", "error", err)
    cache = redisAdapter.NewNoOpCache()
} else {
    slog.Info("Redis cache connected", "addr", cfg.Redis.Addr)
    cache = redisRepo
    defer redisRepo.Close()
}
```

Key design decisions:
- Use `domain.CacheRepository` as the variable type (both CacheRepository and NoOpCache satisfy this interface)
- `defer redisRepo.Close()` is inside the else block so it only runs when Redis actually connected
- `slog.Warn` (not `slog.Error` or `log.Fatalf`) for Redis unavailability per DEGRADE-04
- `slog.Info` on success so operators can confirm cache is active
- No Close() needed for NoOpCache path (it's a no-op, no resources to clean up)

**Step 3: Update the import block in main.go**

Add `"github.com/lineage-api/internal/domain"` to the import block if not already present. It's needed for the `domain.CacheRepository` type.

**Step 4: Update the CachedOpenLineageRepository wiring**

On line 68, change `cacheRepo` to `cache` in the NewCachedOpenLineageRepository call:

```go
cachedOLRepo := redisAdapter.NewCachedOpenLineageRepository(olRepo, cache, cfg.CacheTTL)
```

This variable was renamed from `cacheRepo` to `cache` in the new pattern.
  </action>
  <verify>
Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./cmd/server/` -- must compile with zero errors. Verify with `go vet ./...` for any issues.
  </verify>
  <done>
main.go compiles with the try-connect-or-fallback pattern. NoOpCache has a Close() method. The variable flows from Redis or NoOp to CachedOpenLineageRepository.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for NoOpCache Close() and NoOp-through-CachedRepo integration</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cache_test.go
    lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
  </files>
  <action>
**Step 1: Add NoOpCache Close() test in cache_test.go**

Add a new test case inside the existing `TestNoOpCache` function (after the "Exists always returns false" subtest, around line 49):

```go
// Test Close does nothing and returns nil
t.Run("Close does nothing and returns nil", func(t *testing.T) {
    // Access concrete type for Close() since domain.CacheRepository doesn't include it
    noopConcrete := &NoOpCache{}
    err := noopConcrete.Close()
    assert.NoError(t, err)
})
```

**Step 2: Add NoOp-through-CachedRepo integration test in cached_openlineage_repo_test.go**

Add this test at the end of the file. It uses the REAL NoOpCache (not the mock) with a mock inner repository to prove the full degradation path works for every cached method:

```go
// --- Graceful degradation integration test ---

// TestCachedRepoWithNoOpCache_AllMethodsReturnData proves the complete graceful
// degradation path: when the application starts without Redis, NoOpCache always
// returns cache miss, and every cached method falls through to the inner repository
// and returns correct data. This is the core guarantee of Phase 30.
func TestCachedRepoWithNoOpCache_AllMethodsReturnData(t *testing.T) {
	mockInner := mocks.NewMockOpenLineageRepository()
	noopCache := NewNoOpCache()
	ttls := CacheTTLConfig{LineageTTL: 300, AssetTTL: 300, StatisticsTTL: 300, DDLTTL: 300, SearchTTL: 300}

	repo := NewCachedOpenLineageRepository(mockInner, noopCache, ttls)
	ctx := context.Background()

	// Seed inner repo with representative data for all cached methods
	mockInner.Namespaces = []domain.OpenLineageNamespace{
		{ID: "1", URI: "teradata://host:1025"},
	}
	mockInner.Datasets = []domain.OpenLineageDataset{
		{ID: "42", NamespaceID: "1", Name: "demo_user.customers", SourceType: "TABLE", IsActive: true},
	}
	mockInner.Fields = []domain.OpenLineageField{
		{ID: "f1", DatasetID: "42", Name: "customer_id", Type: "INTEGER"},
	}
	mockInner.GraphData["42/customer_id"] = testGraph()
	rowCount := int64(1000)
	mockInner.Statistics["42"] = &domain.DatasetStatistics{
		DatasetID: "42", DatabaseName: "demo_user", TableName: "customers",
		SourceType: "TABLE", RowCount: &rowCount,
	}
	mockInner.DDLData["42"] = &domain.DatasetDDL{
		DatasetID: "42", DatabaseName: "demo_user", TableName: "customers",
		SourceType: "TABLE", TableDDL: "CREATE TABLE customers (id INTEGER)",
	}

	// 1. ListNamespaces
	t.Run("ListNamespaces", func(t *testing.T) {
		result, err := repo.ListNamespaces(ctx)
		require.NoError(t, err)
		assert.Len(t, result, 1)
		assert.Equal(t, "teradata://host:1025", result[0].URI)
	})

	// 2. GetNamespace
	t.Run("GetNamespace", func(t *testing.T) {
		result, err := repo.GetNamespace(ctx, "1")
		require.NoError(t, err)
		require.NotNil(t, result)
		assert.Equal(t, "1", result.ID)
	})

	// 3. ListDatasets
	t.Run("ListDatasets", func(t *testing.T) {
		datasets, total, err := repo.ListDatasets(ctx, "1", 10, 0)
		require.NoError(t, err)
		assert.Len(t, datasets, 1)
		assert.Equal(t, 1, total)
	})

	// 4. GetDataset
	t.Run("GetDataset", func(t *testing.T) {
		result, err := repo.GetDataset(ctx, "42")
		require.NoError(t, err)
		require.NotNil(t, result)
		assert.Equal(t, "demo_user.customers", result.Name)
	})

	// 5. SearchDatasets
	t.Run("SearchDatasets", func(t *testing.T) {
		results, err := repo.SearchDatasets(ctx, "customers", 10)
		require.NoError(t, err)
		assert.Len(t, results, 1)
	})

	// 6. ListFields
	t.Run("ListFields", func(t *testing.T) {
		result, err := repo.ListFields(ctx, "42")
		require.NoError(t, err)
		assert.Len(t, result, 1)
		assert.Equal(t, "customer_id", result[0].Name)
	})

	// 7. GetColumnLineageGraph
	t.Run("GetColumnLineageGraph", func(t *testing.T) {
		result, err := repo.GetColumnLineageGraph(ctx, "42", "customer_id", "both", 5)
		require.NoError(t, err)
		require.NotNil(t, result)
		assert.Len(t, result.Nodes, 2)
		assert.Len(t, result.Edges, 1)
	})

	// 8. GetDatasetStatistics
	t.Run("GetDatasetStatistics", func(t *testing.T) {
		result, err := repo.GetDatasetStatistics(ctx, "42")
		require.NoError(t, err)
		require.NotNil(t, result)
		assert.Equal(t, int64(1000), *result.RowCount)
	})

	// 9. GetDatasetDDL
	t.Run("GetDatasetDDL", func(t *testing.T) {
		result, err := repo.GetDatasetDDL(ctx, "42")
		require.NoError(t, err)
		require.NotNil(t, result)
		assert.Contains(t, result.TableDDL, "CREATE TABLE")
	})
}
```

This test is the core proof of Phase 30: every cached method works correctly when backed by NoOpCache instead of Redis.
  </action>
  <verify>
Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/outbound/redis/ -v -run "TestNoOpCache|TestCachedRepoWithNoOpCache"` -- all tests must pass. Then run the full test suite: `go test ./internal/adapter/outbound/redis/` to confirm no regressions.
  </verify>
  <done>
NoOpCache Close() test passes. Integration test proves all 9 cached methods return correct data when backed by NoOpCache. Full redis package test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `cd lineage-api && go build ./cmd/server/` compiles successfully
2. `cd lineage-api && go vet ./...` reports no issues
3. `cd lineage-api && go test ./internal/adapter/outbound/redis/ -v` -- all tests pass (existing + new)
4. Verify main.go no longer contains `log.Fatalf("Failed to connect to Redis")` -- grep confirms removal
5. Verify main.go contains `slog.Warn("Redis unavailable` -- grep confirms presence
6. Verify cache.go contains `func (c *NoOpCache) Close()` -- grep confirms presence
</verification>

<success_criteria>
- The `log.Fatalf` for Redis connection failure is replaced with `slog.Warn` + NoOpCache fallback
- main.go compiles and the application would start successfully whether Redis is available or not
- NoOpCache has a Close() method that returns nil
- Integration test proves all 9 cached repository methods work with real NoOpCache
- All existing tests continue to pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/30-graceful-degradation/30-01-SUMMARY.md`
</output>
