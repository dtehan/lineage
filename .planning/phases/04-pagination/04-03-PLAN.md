---
phase: 04-pagination
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lineage-ui/src/types/index.ts
  - lineage-ui/src/api/hooks/useAssets.ts
autonomous: true

must_haves:
  truths:
    - "useDatabases accepts optional limit and offset parameters"
    - "Hook returns pagination metadata alongside data"
    - "Page transitions use keepPreviousData for smooth UX"
    - "queryKey includes pagination params for correct caching"
  artifacts:
    - path: "lineage-ui/src/types/index.ts"
      provides: "PaginationMeta interface for API responses"
      contains: "total_count"
    - path: "lineage-ui/src/api/hooks/useAssets.ts"
      provides: "Paginated hooks with limit/offset params"
      contains: "keepPreviousData"
  key_links:
    - from: "useAssets.ts"
      to: "apiClient"
      via: "GET request with pagination query params"
      pattern: "limit.*offset"
---

<objective>
Update frontend hooks to support pagination parameters.

Purpose: Enable the frontend to request paginated data from the API and handle pagination metadata in responses. This allows the UI to load data incrementally and display pagination controls.

Output: Updated useAssets hooks with pagination parameter support and proper TanStack Query configuration.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pagination/04-RESEARCH.md

Source files to modify:
@lineage-ui/src/types/index.ts
@lineage-ui/src/api/hooks/useAssets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination types to index.ts</name>
  <files>lineage-ui/src/types/index.ts</files>
  <action>
Add pagination metadata type that matches the backend PaginationMeta structure.

Add after the existing PaginationInfo interface (around line 85):

```typescript
// API pagination metadata (matches backend PaginationMeta)
export interface ApiPaginationMeta {
  total_count: number;
  limit: number;
  offset: number;
  has_next: boolean;
}

// Paginated response wrapper for asset endpoints
export interface PaginatedDatabaseResponse {
  databases: Database[];
  total: number;
  pagination?: ApiPaginationMeta;
}

export interface PaginatedTableResponse {
  tables: Table[];
  total: number;
  pagination?: ApiPaginationMeta;
}

export interface PaginatedColumnResponse {
  columns: Column[];
  total: number;
  pagination?: ApiPaginationMeta;
}
```

Note: The `pagination` field is optional to maintain backward compatibility with responses that don't include it.
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` - should pass with no type errors</verify>
  <done>index.ts contains ApiPaginationMeta and paginated response interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Update useAssets hooks with pagination support</name>
  <files>lineage-ui/src/api/hooks/useAssets.ts</files>
  <action>
Update the hooks to accept pagination parameters and use keepPreviousData for smooth transitions.

Replace the entire file content:

```typescript
import { useQuery, keepPreviousData } from '@tanstack/react-query';
import { apiClient } from '../client';
import type {
  Database,
  Table,
  Column,
  PaginatedDatabaseResponse,
  PaginatedTableResponse,
  PaginatedColumnResponse,
  ApiPaginationMeta
} from '../../types';

// Pagination options interface
export interface PaginationOptions {
  limit?: number;
  offset?: number;
}

// Return type for paginated queries
export interface PaginatedResult<T> {
  data: T[];
  pagination?: ApiPaginationMeta;
}

export function useDatabases(options: PaginationOptions = {}) {
  const { limit = 100, offset = 0 } = options;

  return useQuery({
    queryKey: ['databases', { limit, offset }],
    queryFn: async (): Promise<PaginatedResult<Database>> => {
      const params = new URLSearchParams();
      params.set('limit', String(limit));
      params.set('offset', String(offset));

      const { data } = await apiClient.get<PaginatedDatabaseResponse>(
        `/assets/databases?${params}`
      );

      return {
        data: data.databases,
        pagination: data.pagination,
      };
    },
    placeholderData: keepPreviousData,
  });
}

export function useTables(databaseName: string, options: PaginationOptions = {}) {
  const { limit = 100, offset = 0 } = options;

  return useQuery({
    queryKey: ['tables', databaseName, { limit, offset }],
    queryFn: async (): Promise<PaginatedResult<Table>> => {
      const params = new URLSearchParams();
      params.set('limit', String(limit));
      params.set('offset', String(offset));

      const { data } = await apiClient.get<PaginatedTableResponse>(
        `/assets/databases/${encodeURIComponent(databaseName)}/tables?${params}`
      );

      return {
        data: data.tables,
        pagination: data.pagination,
      };
    },
    enabled: !!databaseName,
    placeholderData: keepPreviousData,
  });
}

export function useColumns(
  databaseName: string,
  tableName: string,
  options: PaginationOptions = {}
) {
  const { limit = 100, offset = 0 } = options;

  return useQuery({
    queryKey: ['columns', databaseName, tableName, { limit, offset }],
    queryFn: async (): Promise<PaginatedResult<Column>> => {
      const params = new URLSearchParams();
      params.set('limit', String(limit));
      params.set('offset', String(offset));

      const { data } = await apiClient.get<PaginatedColumnResponse>(
        `/assets/databases/${encodeURIComponent(databaseName)}/tables/${encodeURIComponent(tableName)}/columns?${params}`
      );

      return {
        data: data.columns,
        pagination: data.pagination,
      };
    },
    enabled: !!databaseName && !!tableName,
    placeholderData: keepPreviousData,
  });
}

// Convenience hooks that match the old API (return just the data array)
// These can be used by existing components that don't need pagination
export function useDatabasesSimple() {
  const query = useDatabases();
  return {
    ...query,
    data: query.data?.data,
  };
}

export function useTablesSimple(databaseName: string) {
  const query = useTables(databaseName);
  return {
    ...query,
    data: query.data?.data,
  };
}

export function useColumnsSimple(databaseName: string, tableName: string) {
  const query = useColumns(databaseName, tableName);
  return {
    ...query,
    data: query.data?.data,
  };
}
```

Key changes:
1. Import `keepPreviousData` from @tanstack/react-query (TanStack Query v5 pattern)
2. Accept pagination options with defaults (limit=100, offset=0)
3. Include limit/offset in queryKey for proper cache isolation
4. Use `placeholderData: keepPreviousData` for smooth page transitions
5. Return structured result with data array and pagination metadata
6. Add "Simple" variants for backward compatibility with existing components
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` - should pass with no type errors</verify>
  <done>useAssets.ts has paginated hooks with keepPreviousData, pagination params in queryKey, and backward-compatible simple variants</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd lineage-ui && npx tsc --noEmit`
2. Build succeeds: `cd lineage-ui && npm run build`
3. Unit tests pass: `cd lineage-ui && npm test` (if any exist for these hooks)
4. Manual verification: Start the app and check network requests include limit/offset params
</verification>

<success_criteria>
- useDatabases, useTables, useColumns accept optional PaginationOptions
- Hooks pass limit and offset as query parameters to API
- queryKey includes pagination params for correct caching
- placeholderData: keepPreviousData prevents UI flicker during page changes
- Types for paginated responses match backend structure
- Simple hook variants provide backward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/04-pagination/04-03-SUMMARY.md`
</output>
