---
phase: 04-pagination
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lineage-api/internal/adapter/outbound/teradata/asset_repo.go
  - lineage-api/internal/application/asset_service.go
  - lineage-api/internal/adapter/inbound/http/handlers.go
  - lineage-api/internal/adapter/inbound/http/handlers_test.go
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/assets/databases?limit=50&offset=100 returns paginated results"
    - "Response includes pagination.total_count, pagination.has_next"
    - "Invalid limit (0, -1, 501, 'abc') returns 400 VALIDATION_ERROR"
    - "Invalid offset (-1, 'abc') returns 400 VALIDATION_ERROR"
    - "Default limit=100 and offset=0 when not specified"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/teradata/asset_repo.go"
      provides: "Paginated queries with COUNT and LIMIT OFFSET"
      contains: "ListDatabasesPaginated"
    - path: "lineage-api/internal/application/asset_service.go"
      provides: "Service methods passing pagination to repository"
      contains: "ListDatabasesPaginated"
    - path: "lineage-api/internal/adapter/inbound/http/handlers.go"
      provides: "Handlers calling pagination validation and service"
      contains: "parseAndValidatePaginationParams"
    - path: "lineage-api/internal/adapter/inbound/http/handlers_test.go"
      provides: "Pagination validation tests"
      contains: "TestListDatabases_PaginationValidation"
  key_links:
    - from: "handlers.go"
      to: "asset_service.go"
      via: "ListDatabasesPaginated call"
      pattern: "ListDatabasesPaginated"
    - from: "asset_service.go"
      to: "asset_repo.go"
      via: "Repository pagination method"
      pattern: "assetRepo.ListDatabasesPaginated"
---

<objective>
Implement pagination in repository, service, and handlers with unit tests.

Purpose: Make asset listing endpoints return paginated results with total count and has_next metadata. This enables the frontend to load data incrementally and prevents large payload issues.

Output: Working paginated endpoints for databases, tables, and columns with validation tests.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pagination/04-RESEARCH.md
@.planning/phases/04-pagination/04-01-SUMMARY.md

Source files to modify:
@lineage-api/internal/adapter/outbound/teradata/asset_repo.go
@lineage-api/internal/application/asset_service.go
@lineage-api/internal/adapter/inbound/http/handlers.go
@lineage-api/internal/adapter/inbound/http/handlers_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement paginated repository methods</name>
  <files>lineage-api/internal/adapter/outbound/teradata/asset_repo.go</files>
  <action>
Add three paginated methods to AssetRepository. Each method:
1. Executes COUNT(*) query first to get total
2. Executes SELECT with ORDER BY, LIMIT, OFFSET
3. Returns (results, totalCount, error)

Add after existing ListColumns method:

```go
// ListDatabasesPaginated returns a paginated list of databases.
// Implements PAGE-04: LIMIT/OFFSET at database layer.
func (r *AssetRepository) ListDatabasesPaginated(ctx context.Context, limit, offset int) ([]domain.Database, int, error) {
    // Get total count
    countQuery := `SELECT COUNT(*) FROM demo_user.LIN_DATABASE WHERE is_active = 'Y'`
    var totalCount int
    if err := r.db.QueryRowContext(ctx, countQuery).Scan(&totalCount); err != nil {
        return nil, 0, fmt.Errorf("failed to count databases: %w", err)
    }

    // Get paginated results
    query := `
        SELECT
            database_id,
            database_name,
            owner_name,
            create_timestamp,
            comment_string
        FROM demo_user.LIN_DATABASE
        WHERE is_active = 'Y'
        ORDER BY database_name
        LIMIT ? OFFSET ?
    `

    rows, err := r.db.QueryContext(ctx, query, limit, offset)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to query databases: %w", err)
    }
    defer rows.Close()

    var databases []domain.Database
    for rows.Next() {
        var d domain.Database
        var ownerName, commentString sql.NullString
        var createTimestamp sql.NullTime

        err := rows.Scan(
            &d.ID,
            &d.Name,
            &ownerName,
            &createTimestamp,
            &commentString,
        )
        if err != nil {
            return nil, 0, fmt.Errorf("failed to scan database row: %w", err)
        }

        if ownerName.Valid {
            d.OwnerName = ownerName.String
        }
        if createTimestamp.Valid {
            d.CreateTimestamp = createTimestamp.Time
        }
        if commentString.Valid {
            d.CommentString = commentString.String
        }

        databases = append(databases, d)
    }

    return databases, totalCount, rows.Err()
}

// ListTablesPaginated returns a paginated list of tables for a database.
func (r *AssetRepository) ListTablesPaginated(ctx context.Context, databaseName string, limit, offset int) ([]domain.Table, int, error) {
    // Get total count
    countQuery := `
        SELECT COUNT(*)
        FROM demo_user.LIN_TABLE
        WHERE database_name = ?
          AND is_active = 'Y'
    `
    var totalCount int
    if err := r.db.QueryRowContext(ctx, countQuery, databaseName).Scan(&totalCount); err != nil {
        return nil, 0, fmt.Errorf("failed to count tables: %w", err)
    }

    // Get paginated results
    query := `
        SELECT
            table_id,
            database_name,
            table_name,
            table_kind,
            create_timestamp,
            comment_string
        FROM demo_user.LIN_TABLE
        WHERE database_name = ?
          AND is_active = 'Y'
        ORDER BY table_name
        LIMIT ? OFFSET ?
    `

    rows, err := r.db.QueryContext(ctx, query, databaseName, limit, offset)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to query tables: %w", err)
    }
    defer rows.Close()

    var tables []domain.Table
    for rows.Next() {
        var t domain.Table
        var commentString sql.NullString
        var createTimestamp sql.NullTime

        err := rows.Scan(
            &t.ID,
            &t.DatabaseName,
            &t.TableName,
            &t.TableKind,
            &createTimestamp,
            &commentString,
        )
        if err != nil {
            return nil, 0, fmt.Errorf("failed to scan table row: %w", err)
        }

        if createTimestamp.Valid {
            t.CreateTimestamp = createTimestamp.Time
        }
        if commentString.Valid {
            t.CommentString = commentString.String
        }

        tables = append(tables, t)
    }

    return tables, totalCount, rows.Err()
}

// ListColumnsPaginated returns a paginated list of columns for a table.
func (r *AssetRepository) ListColumnsPaginated(ctx context.Context, databaseName, tableName string, limit, offset int) ([]domain.Column, int, error) {
    // Get total count
    countQuery := `
        SELECT COUNT(*)
        FROM demo_user.LIN_COLUMN
        WHERE database_name = ?
          AND table_name = ?
          AND is_active = 'Y'
    `
    var totalCount int
    if err := r.db.QueryRowContext(ctx, countQuery, databaseName, tableName).Scan(&totalCount); err != nil {
        return nil, 0, fmt.Errorf("failed to count columns: %w", err)
    }

    // Get paginated results
    query := `
        SELECT
            column_id,
            database_name,
            table_name,
            column_name,
            column_type,
            column_length,
            nullable,
            comment_string,
            column_position
        FROM demo_user.LIN_COLUMN
        WHERE database_name = ?
          AND table_name = ?
          AND is_active = 'Y'
        ORDER BY column_position
        LIMIT ? OFFSET ?
    `

    rows, err := r.db.QueryContext(ctx, query, databaseName, tableName, limit, offset)
    if err != nil {
        return nil, 0, fmt.Errorf("failed to query columns: %w", err)
    }
    defer rows.Close()

    var columns []domain.Column
    for rows.Next() {
        var c domain.Column
        var commentString sql.NullString
        var columnLength sql.NullInt64
        var nullable string

        err := rows.Scan(
            &c.ID,
            &c.DatabaseName,
            &c.TableName,
            &c.ColumnName,
            &c.ColumnType,
            &columnLength,
            &nullable,
            &commentString,
            &c.ColumnPosition,
        )
        if err != nil {
            return nil, 0, fmt.Errorf("failed to scan column row: %w", err)
        }

        if columnLength.Valid {
            c.ColumnLength = int(columnLength.Int64)
        }
        c.Nullable = nullable == "Y"
        if commentString.Valid {
            c.CommentString = commentString.String
        }

        columns = append(columns, c)
    }

    return columns, totalCount, rows.Err()
}
```
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` - should compile without errors</verify>
  <done>asset_repo.go implements ListDatabasesPaginated, ListTablesPaginated, ListColumnsPaginated with COUNT and LIMIT OFFSET</done>
</task>

<task type="auto">
  <name>Task 2: Add paginated service methods and update handlers</name>
  <files>
    lineage-api/internal/application/asset_service.go
    lineage-api/internal/adapter/inbound/http/handlers.go
  </files>
  <action>
1. In asset_service.go, add paginated methods after existing methods:

```go
// ListDatabasesPaginated returns a paginated list of databases.
func (s *AssetService) ListDatabasesPaginated(ctx context.Context, limit, offset int) ([]domain.Database, int, error) {
    return s.assetRepo.ListDatabasesPaginated(ctx, limit, offset)
}

// ListTablesPaginated returns a paginated list of tables for a database.
func (s *AssetService) ListTablesPaginated(ctx context.Context, databaseName string, limit, offset int) ([]domain.Table, int, error) {
    return s.assetRepo.ListTablesPaginated(ctx, databaseName, limit, offset)
}

// ListColumnsPaginated returns a paginated list of columns for a table.
func (s *AssetService) ListColumnsPaginated(ctx context.Context, databaseName, tableName string, limit, offset int) ([]domain.Column, int, error) {
    return s.assetRepo.ListColumnsPaginated(ctx, databaseName, tableName, limit, offset)
}
```

2. In handlers.go, update ListDatabases, ListTables, ListColumns to use pagination.

Update ListDatabases:
```go
func (h *Handler) ListDatabases(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()

    // Validate pagination params
    limit, offset, validationErrors := parseAndValidatePaginationParams(r)
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    databases, totalCount, err := h.assetService.ListDatabasesPaginated(ctx, limit, offset)
    if err != nil {
        requestID := middleware.GetReqID(ctx)
        slog.ErrorContext(ctx, "failed to list databases",
            "request_id", requestID,
            "error", err,
            "stack", logging.CaptureStack(),
            "method", r.Method,
            "path", r.URL.Path,
        )
        respondError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    hasNext := offset+limit < totalCount

    respondJSON(w, http.StatusOK, application.DatabaseListResponse{
        Databases: databases,
        Total:     len(databases),
        Pagination: &application.PaginationMeta{
            TotalCount: totalCount,
            Limit:      limit,
            Offset:     offset,
            HasNext:    hasNext,
        },
    })
}
```

Update ListTables:
```go
func (h *Handler) ListTables(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    databaseName := chi.URLParam(r, "database")

    // Validate pagination params
    limit, offset, validationErrors := parseAndValidatePaginationParams(r)
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    tables, totalCount, err := h.assetService.ListTablesPaginated(ctx, databaseName, limit, offset)
    if err != nil {
        requestID := middleware.GetReqID(ctx)
        slog.ErrorContext(ctx, "failed to list tables",
            "request_id", requestID,
            "error", err,
            "stack", logging.CaptureStack(),
            "method", r.Method,
            "path", r.URL.Path,
            "database_name", databaseName,
        )
        respondError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    hasNext := offset+limit < totalCount

    respondJSON(w, http.StatusOK, application.TableListResponse{
        Tables: tables,
        Total:  len(tables),
        Pagination: &application.PaginationMeta{
            TotalCount: totalCount,
            Limit:      limit,
            Offset:     offset,
            HasNext:    hasNext,
        },
    })
}
```

Update ListColumns:
```go
func (h *Handler) ListColumns(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    databaseName := chi.URLParam(r, "database")
    tableName := chi.URLParam(r, "table")

    // Validate pagination params
    limit, offset, validationErrors := parseAndValidatePaginationParams(r)
    if len(validationErrors) > 0 {
        respondValidationError(w, r, validationErrors)
        return
    }

    columns, totalCount, err := h.assetService.ListColumnsPaginated(ctx, databaseName, tableName, limit, offset)
    if err != nil {
        requestID := middleware.GetReqID(ctx)
        slog.ErrorContext(ctx, "failed to list columns",
            "request_id", requestID,
            "error", err,
            "stack", logging.CaptureStack(),
            "method", r.Method,
            "path", r.URL.Path,
            "database_name", databaseName,
            "table_name", tableName,
        )
        respondError(w, r, http.StatusInternalServerError, "Internal server error")
        return
    }

    hasNext := offset+limit < totalCount

    respondJSON(w, http.StatusOK, application.ColumnListResponse{
        Columns: columns,
        Total:   len(columns),
        Pagination: &application.PaginationMeta{
            TotalCount: totalCount,
            Limit:      limit,
            Offset:     offset,
            HasNext:    hasNext,
        },
    })
}
```
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` - should compile</verify>
  <done>Handlers call parseAndValidatePaginationParams and use paginated service methods, responses include PaginationMeta</done>
</task>

<task type="auto">
  <name>Task 3: Add pagination validation tests</name>
  <files>lineage-api/internal/adapter/inbound/http/handlers_test.go</files>
  <action>
Add pagination validation tests after the existing validation tests section. Follow the table-driven test pattern used for maxDepth/direction validation.

Add at the end of handlers_test.go (after existing tests):

```go
// =============================================================================
// Pagination Validation Tests (PAGE-01, PAGE-02, TEST-04)
// =============================================================================

// TEST-04: pagination validation for ListDatabases
func TestListDatabases_PaginationValidation(t *testing.T) {
    SetPaginationConfig(1, 500, 100)

    tests := []struct {
        name         string
        limitParam   string
        offsetParam  string
        expectStatus int
        expectError  bool
    }{
        // Valid cases
        {"default values", "", "", http.StatusOK, false},
        {"valid limit", "50", "", http.StatusOK, false},
        {"valid limit and offset", "50", "100", http.StatusOK, false},
        {"min limit", "1", "0", http.StatusOK, false},
        {"max limit", "500", "0", http.StatusOK, false},
        {"large offset", "100", "1000", http.StatusOK, false},

        // Invalid limit
        {"limit zero", "0", "", http.StatusBadRequest, true},
        {"limit negative", "-1", "", http.StatusBadRequest, true},
        {"limit above max", "501", "", http.StatusBadRequest, true},
        {"limit way above max", "10000", "", http.StatusBadRequest, true},
        {"limit non-integer", "abc", "", http.StatusBadRequest, true},
        {"limit float", "50.5", "", http.StatusBadRequest, true},

        // Invalid offset
        {"offset negative", "100", "-1", http.StatusBadRequest, true},
        {"offset non-integer", "100", "abc", http.StatusBadRequest, true},
        {"offset float", "100", "10.5", http.StatusBadRequest, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            handler, assetRepo, _, _ := setupTestHandler()
            assetRepo.Databases = []domain.Database{{ID: "db-001", Name: "test"}}
            assetRepo.DatabaseCount = 1

            url := "/api/v1/assets/databases"
            params := []string{}
            if tt.limitParam != "" {
                params = append(params, "limit="+tt.limitParam)
            }
            if tt.offsetParam != "" {
                params = append(params, "offset="+tt.offsetParam)
            }
            if len(params) > 0 {
                url += "?" + strings.Join(params, "&")
            }

            req := newTestRequestWithRequestID("GET", url, nil)
            w := httptest.NewRecorder()

            handler.ListDatabases(w, req)

            assert.Equal(t, tt.expectStatus, w.Code, "status code mismatch for %s", tt.name)
            if tt.expectError {
                var response ValidationErrorResponse
                err := json.Unmarshal(w.Body.Bytes(), &response)
                require.NoError(t, err)
                assert.Equal(t, "VALIDATION_ERROR", response.Code)
            }
        })
    }
}

// TEST-04: pagination validation for ListTables
func TestListTables_PaginationValidation(t *testing.T) {
    SetPaginationConfig(1, 500, 100)

    tests := []struct {
        name         string
        limitParam   string
        offsetParam  string
        expectStatus int
        expectError  bool
    }{
        {"default values", "", "", http.StatusOK, false},
        {"valid params", "50", "100", http.StatusOK, false},
        {"limit zero", "0", "", http.StatusBadRequest, true},
        {"limit above max", "501", "", http.StatusBadRequest, true},
        {"offset negative", "100", "-1", http.StatusBadRequest, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            handler, assetRepo, _, _ := setupTestHandler()
            assetRepo.Tables = []domain.Table{{ID: "tbl-001", DatabaseName: "test_db", TableName: "users"}}
            assetRepo.TableCount = 1

            url := "/api/v1/assets/databases/test_db/tables"
            params := []string{}
            if tt.limitParam != "" {
                params = append(params, "limit="+tt.limitParam)
            }
            if tt.offsetParam != "" {
                params = append(params, "offset="+tt.offsetParam)
            }
            if len(params) > 0 {
                url += "?" + strings.Join(params, "&")
            }

            req := newTestRequestWithRequestID("GET", url, map[string]string{"database": "test_db"})
            w := httptest.NewRecorder()

            handler.ListTables(w, req)

            assert.Equal(t, tt.expectStatus, w.Code, "status code mismatch for %s", tt.name)
            if tt.expectError {
                assert.Contains(t, w.Body.String(), "VALIDATION_ERROR")
            }
        })
    }
}

// TEST-04: pagination validation for ListColumns
func TestListColumns_PaginationValidation(t *testing.T) {
    SetPaginationConfig(1, 500, 100)

    tests := []struct {
        name         string
        limitParam   string
        offsetParam  string
        expectStatus int
        expectError  bool
    }{
        {"default values", "", "", http.StatusOK, false},
        {"valid params", "50", "100", http.StatusOK, false},
        {"limit zero", "0", "", http.StatusBadRequest, true},
        {"offset negative", "100", "-1", http.StatusBadRequest, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            handler, assetRepo, _, _ := setupTestHandler()
            assetRepo.Columns = []domain.Column{{ID: "col-001", DatabaseName: "test_db", TableName: "users", ColumnName: "id"}}
            assetRepo.ColumnCount = 1

            url := "/api/v1/assets/databases/test_db/tables/users/columns"
            params := []string{}
            if tt.limitParam != "" {
                params = append(params, "limit="+tt.limitParam)
            }
            if tt.offsetParam != "" {
                params = append(params, "offset="+tt.offsetParam)
            }
            if len(params) > 0 {
                url += "?" + strings.Join(params, "&")
            }

            req := newTestRequestWithRequestID("GET", url, map[string]string{"database": "test_db", "table": "users"})
            w := httptest.NewRecorder()

            handler.ListColumns(w, req)

            assert.Equal(t, tt.expectStatus, w.Code, "status code mismatch for %s", tt.name)
            if tt.expectError {
                assert.Contains(t, w.Body.String(), "VALIDATION_ERROR")
            }
        })
    }
}

// PAGE-03: Pagination metadata in response
func TestListDatabases_PaginationMetadata(t *testing.T) {
    SetPaginationConfig(1, 500, 100)
    handler, assetRepo, _, _ := setupTestHandler()

    // Setup: 25 databases, request page with offset 10, limit 10
    for i := 0; i < 25; i++ {
        assetRepo.Databases = append(assetRepo.Databases, domain.Database{
            ID:   fmt.Sprintf("db-%03d", i),
            Name: fmt.Sprintf("database_%d", i),
        })
    }
    assetRepo.DatabaseCount = 25

    req := newTestRequestWithRequestID("GET", "/api/v1/assets/databases?limit=10&offset=10", nil)
    w := httptest.NewRecorder()

    handler.ListDatabases(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    var response application.DatabaseListResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    // Verify pagination metadata
    require.NotNil(t, response.Pagination, "pagination should be present")
    assert.Equal(t, 25, response.Pagination.TotalCount, "total_count should be 25")
    assert.Equal(t, 10, response.Pagination.Limit, "limit should be 10")
    assert.Equal(t, 10, response.Pagination.Offset, "offset should be 10")
    assert.True(t, response.Pagination.HasNext, "has_next should be true (10+10 < 25)")

    // Verify we got 10 items
    assert.Len(t, response.Databases, 10)
}

// PAGE-03: has_next is false on last page
func TestListDatabases_HasNextFalseOnLastPage(t *testing.T) {
    SetPaginationConfig(1, 500, 100)
    handler, assetRepo, _, _ := setupTestHandler()

    // Setup: 25 databases, request last page (offset 20, limit 10 = items 20-24)
    for i := 0; i < 25; i++ {
        assetRepo.Databases = append(assetRepo.Databases, domain.Database{
            ID:   fmt.Sprintf("db-%03d", i),
            Name: fmt.Sprintf("database_%d", i),
        })
    }
    assetRepo.DatabaseCount = 25

    req := newTestRequestWithRequestID("GET", "/api/v1/assets/databases?limit=10&offset=20", nil)
    w := httptest.NewRecorder()

    handler.ListDatabases(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    var response application.DatabaseListResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    require.NotNil(t, response.Pagination)
    assert.False(t, response.Pagination.HasNext, "has_next should be false on last page (20+10 >= 25)")
    assert.Len(t, response.Databases, 5, "should return remaining 5 items")
}

// PAGE-02: Default page size is 100
func TestListDatabases_DefaultPageSize(t *testing.T) {
    SetPaginationConfig(1, 500, 100)
    handler, assetRepo, _, _ := setupTestHandler()

    assetRepo.Databases = []domain.Database{{ID: "db-001", Name: "test"}}
    assetRepo.DatabaseCount = 1

    req := newTestRequestWithRequestID("GET", "/api/v1/assets/databases", nil)
    w := httptest.NewRecorder()

    handler.ListDatabases(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    var response application.DatabaseListResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    require.NotNil(t, response.Pagination)
    assert.Equal(t, 100, response.Pagination.Limit, "default limit should be 100")
    assert.Equal(t, 0, response.Pagination.Offset, "default offset should be 0")
}

// Verify multiple validation errors are reported
func TestListDatabases_MultipleValidationErrors(t *testing.T) {
    SetPaginationConfig(1, 500, 100)
    handler, _, _, _ := setupTestHandler()

    // Both limit and offset invalid
    req := newTestRequestWithRequestID("GET", "/api/v1/assets/databases?limit=abc&offset=-5", nil)
    w := httptest.NewRecorder()

    handler.ListDatabases(w, req)

    assert.Equal(t, http.StatusBadRequest, w.Code)

    var response ValidationErrorResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(t, err)

    assert.Equal(t, "VALIDATION_ERROR", response.Code)
    assert.GreaterOrEqual(t, len(response.Details), 2, "should report both errors")

    // Verify both fields are mentioned
    fields := make(map[string]bool)
    for _, detail := range response.Details {
        fields[detail.Field] = true
    }
    assert.True(t, fields["limit"], "should include limit error")
    assert.True(t, fields["offset"], "should include offset error")
}
```

Also add this import at the top of handlers_test.go if not present:
```go
import "strings"
```

And add fmt import if not present:
```go
import "fmt"
```
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go test ./internal/adapter/inbound/http/... -v` - all tests should pass</verify>
  <done>handlers_test.go contains comprehensive pagination validation tests for all three endpoints, pagination metadata tests, and edge case tests</done>
</task>

</tasks>

<verification>
1. All files compile: `cd lineage-api && go build ./...`
2. All tests pass: `cd lineage-api && go test ./... -v`
3. Pagination validation tests pass: `go test -run TestListDatabases_PaginationValidation -v`
4. Manual curl test (if server running): `curl "http://localhost:8080/api/v1/assets/databases?limit=10&offset=0"` returns pagination metadata
</verification>

<success_criteria>
- Repository implements paginated queries with COUNT and LIMIT OFFSET
- Service layer has paginated methods
- Handlers validate pagination params and return 400 for invalid values
- Responses include pagination.total_count, pagination.limit, pagination.offset, pagination.has_next
- All existing tests still pass (backward compatibility)
- New pagination tests cover validation edge cases (zero, negative, above max, non-integer)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pagination/04-02-SUMMARY.md`
</output>
