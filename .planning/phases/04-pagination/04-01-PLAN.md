---
phase: 04-pagination
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-api/internal/adapter/inbound/http/validation.go
  - lineage-api/internal/application/dto.go
  - lineage-api/internal/domain/repository.go
  - lineage-api/internal/domain/mocks/repositories.go
autonomous: true

must_haves:
  truths:
    - "Pagination validation accepts limit 1-500 and offset >= 0"
    - "Validation returns 400 with VALIDATION_ERROR for invalid pagination params"
    - "Default limit is 100 when not specified"
    - "PaginationMeta contains total_count, limit, offset, has_next"
  artifacts:
    - path: "lineage-api/internal/adapter/inbound/http/validation.go"
      provides: "parseAndValidatePaginationParams function, SetPaginationConfig"
      contains: "paginationDefaultLimit = 100"
    - path: "lineage-api/internal/application/dto.go"
      provides: "PaginationMeta struct, paginated response DTOs"
      contains: "PaginationMeta"
    - path: "lineage-api/internal/domain/repository.go"
      provides: "Paginated method signatures in AssetRepository interface"
      contains: "ListDatabasesPaginated"
    - path: "lineage-api/internal/domain/mocks/repositories.go"
      provides: "Mock implementations with pagination support"
      contains: "DatabaseCount"
  key_links:
    - from: "validation.go"
      to: "handlers.go"
      via: "parseAndValidatePaginationParams called by handlers"
      pattern: "parseAndValidatePaginationParams"
    - from: "dto.go"
      to: "handlers.go"
      via: "PaginationMeta used in responses"
      pattern: "PaginationMeta"
---

<objective>
Create pagination infrastructure for asset listing endpoints.

Purpose: Enable the backend to validate, process, and return paginated results with metadata. This plan creates the foundation (validation, DTOs, interfaces, mocks) that Plan 02 will use to implement the actual pagination logic.

Output: Validation functions for limit/offset, PaginationMeta DTO, repository interface with paginated method signatures, and updated mocks for testing.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pagination/04-RESEARCH.md

Source files to modify:
@lineage-api/internal/adapter/inbound/http/validation.go
@lineage-api/internal/application/dto.go
@lineage-api/internal/domain/repository.go
@lineage-api/internal/domain/mocks/repositories.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination validation to validation.go</name>
  <files>lineage-api/internal/adapter/inbound/http/validation.go</files>
  <action>
Add pagination validation following the existing Phase 3 pattern for maxDepth/direction.

1. Add package-level pagination config variables (after existing validation vars):
```go
var (
    paginationMinLimit     = 1
    paginationMaxLimit     = 500
    paginationDefaultLimit = 100
    paginationMinOffset    = 0
)
```

2. Add SetPaginationConfig function (after SetValidationConfig):
```go
// SetPaginationConfig initializes pagination bounds from configuration.
// Must be called at startup before handling any requests.
func SetPaginationConfig(minLimit, maxLimit, defaultLimit int) {
    paginationMinLimit = minLimit
    paginationMaxLimit = maxLimit
    paginationDefaultLimit = defaultLimit
}
```

3. Add parseAndValidatePaginationParams function (after parseAndValidateMaxDepth):
```go
// parseAndValidatePaginationParams validates limit and offset parameters.
// Returns the validated values and any field errors.
// Empty parameters use defaults: limit=100, offset=0.
func parseAndValidatePaginationParams(r *http.Request) (limit, offset int, errors []FieldError) {
    errors = make([]FieldError, 0)

    // Parse limit
    limitStr := r.URL.Query().Get("limit")
    if limitStr == "" {
        limit = paginationDefaultLimit
    } else {
        var err error
        limit, err = strconv.Atoi(limitStr)
        if err != nil {
            errors = append(errors, FieldError{
                Field:   "limit",
                Message: fmt.Sprintf("limit must be an integer (got: %q)", limitStr),
            })
        } else if limit < paginationMinLimit || limit > paginationMaxLimit {
            errors = append(errors, FieldError{
                Field:   "limit",
                Message: fmt.Sprintf("limit must be between %d and %d (got: %d)",
                    paginationMinLimit, paginationMaxLimit, limit),
            })
        }
    }

    // Parse offset
    offsetStr := r.URL.Query().Get("offset")
    if offsetStr == "" {
        offset = 0
    } else {
        var err error
        offset, err = strconv.Atoi(offsetStr)
        if err != nil {
            errors = append(errors, FieldError{
                Field:   "offset",
                Message: fmt.Sprintf("offset must be an integer (got: %q)", offsetStr),
            })
        } else if offset < paginationMinOffset {
            errors = append(errors, FieldError{
                Field:   "offset",
                Message: fmt.Sprintf("offset must be >= %d (got: %d)", paginationMinOffset, offset),
            })
        }
    }

    return limit, offset, errors
}
```
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` - should compile without errors</verify>
  <done>validation.go contains parseAndValidatePaginationParams with limit (1-500, default 100) and offset (>= 0) validation</done>
</task>

<task type="auto">
  <name>Task 2: Add PaginationMeta and paginated response DTOs</name>
  <files>lineage-api/internal/application/dto.go</files>
  <action>
Add pagination DTOs to dto.go after the existing response DTOs.

1. Add PaginationMeta struct:
```go
// PaginationMeta provides pagination information in list responses.
// Implements PAGE-03: total_count, has_next, and current page info.
type PaginationMeta struct {
    TotalCount int  `json:"total_count"`
    Limit      int  `json:"limit"`
    Offset     int  `json:"offset"`
    HasNext    bool `json:"has_next"`
}
```

2. Update existing response DTOs to include pagination (keeping Total for backwards compat):
- Change DatabaseListResponse to include Pagination field
- Change TableListResponse to include Pagination field
- Change ColumnListResponse to include Pagination field

Updated structs:
```go
type DatabaseListResponse struct {
    Databases  []domain.Database `json:"databases"`
    Total      int               `json:"total"`
    Pagination *PaginationMeta   `json:"pagination,omitempty"`
}

type TableListResponse struct {
    Tables     []domain.Table  `json:"tables"`
    Total      int             `json:"total"`
    Pagination *PaginationMeta `json:"pagination,omitempty"`
}

type ColumnListResponse struct {
    Columns    []domain.Column `json:"columns"`
    Total      int             `json:"total"`
    Pagination *PaginationMeta `json:"pagination,omitempty"`
}
```

Note: Using pointer with omitempty allows backward compatibility - existing tests expecting only `total` will still work, and pagination info is optional.
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` - should compile without errors</verify>
  <done>dto.go contains PaginationMeta struct and updated list response DTOs with optional Pagination field</done>
</task>

<task type="auto">
  <name>Task 3: Add paginated methods to repository interface and update mocks</name>
  <files>
    lineage-api/internal/domain/repository.go
    lineage-api/internal/domain/mocks/repositories.go
  </files>
  <action>
1. In repository.go, add paginated method signatures to AssetRepository interface:
```go
type AssetRepository interface {
    // Existing methods (keep these)
    ListDatabases(ctx context.Context) ([]Database, error)
    GetDatabase(ctx context.Context, name string) (*Database, error)
    ListTables(ctx context.Context, databaseName string) ([]Table, error)
    GetTable(ctx context.Context, databaseName, tableName string) (*Table, error)
    ListColumns(ctx context.Context, databaseName, tableName string) ([]Column, error)
    GetColumn(ctx context.Context, databaseName, tableName, columnName string) (*Column, error)

    // New paginated methods
    ListDatabasesPaginated(ctx context.Context, limit, offset int) ([]Database, int, error)
    ListTablesPaginated(ctx context.Context, databaseName string, limit, offset int) ([]Table, int, error)
    ListColumnsPaginated(ctx context.Context, databaseName, tableName string, limit, offset int) ([]Column, int, error)
}
```

2. In mocks/repositories.go, update MockAssetRepository:

Add count fields to the struct:
```go
type MockAssetRepository struct {
    mu         sync.RWMutex
    Databases  []domain.Database
    Tables     []domain.Table
    Columns    []domain.Column

    // Pagination support
    DatabaseCount int
    TableCount    int
    ColumnCount   int

    // Error injection (existing)
    ListDatabasesErr error
    GetDatabaseErr   error
    ListTablesErr    error
    GetTableErr      error
    ListColumnsErr   error
    GetColumnErr     error
}
```

Add paginated method implementations:
```go
// ListDatabasesPaginated returns paginated databases.
func (m *MockAssetRepository) ListDatabasesPaginated(ctx context.Context, limit, offset int) ([]domain.Database, int, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if m.ListDatabasesErr != nil {
        return nil, 0, m.ListDatabasesErr
    }

    total := m.DatabaseCount
    if total == 0 {
        total = len(m.Databases)
    }

    // Apply pagination
    start := offset
    if start > len(m.Databases) {
        return []domain.Database{}, total, nil
    }
    end := start + limit
    if end > len(m.Databases) {
        end = len(m.Databases)
    }

    return m.Databases[start:end], total, nil
}

// ListTablesPaginated returns paginated tables for a database.
func (m *MockAssetRepository) ListTablesPaginated(ctx context.Context, databaseName string, limit, offset int) ([]domain.Table, int, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if m.ListTablesErr != nil {
        return nil, 0, m.ListTablesErr
    }

    // Filter by database
    var filtered []domain.Table
    for _, t := range m.Tables {
        if t.DatabaseName == databaseName {
            filtered = append(filtered, t)
        }
    }

    total := m.TableCount
    if total == 0 {
        total = len(filtered)
    }

    // Apply pagination
    start := offset
    if start > len(filtered) {
        return []domain.Table{}, total, nil
    }
    end := start + limit
    if end > len(filtered) {
        end = len(filtered)
    }

    return filtered[start:end], total, nil
}

// ListColumnsPaginated returns paginated columns for a table.
func (m *MockAssetRepository) ListColumnsPaginated(ctx context.Context, databaseName, tableName string, limit, offset int) ([]domain.Column, int, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if m.ListColumnsErr != nil {
        return nil, 0, m.ListColumnsErr
    }

    // Filter by database and table
    var filtered []domain.Column
    for _, c := range m.Columns {
        if c.DatabaseName == databaseName && c.TableName == tableName {
            filtered = append(filtered, c)
        }
    }

    total := m.ColumnCount
    if total == 0 {
        total = len(filtered)
    }

    // Apply pagination
    start := offset
    if start > len(filtered) {
        return []domain.Column{}, total, nil
    }
    end := start + limit
    if end > len(filtered) {
        end = len(filtered)
    }

    return filtered[start:end], total, nil
}
```
  </action>
  <verify>Run `cd /Users/Daniel.Tehan/Code/lineage/lineage-api && go build ./...` - should compile. Run `go test ./internal/domain/mocks/...` - should pass</verify>
  <done>repository.go has paginated method signatures, mocks implement pagination with count fields and slice slicing</done>
</task>

</tasks>

<verification>
1. All files compile: `cd lineage-api && go build ./...`
2. Existing tests still pass: `cd lineage-api && go test ./...`
3. Manual code review: validation.go has parseAndValidatePaginationParams, dto.go has PaginationMeta, repository.go has paginated signatures
</verification>

<success_criteria>
- parseAndValidatePaginationParams validates limit (1-500) and offset (>= 0)
- PaginationMeta struct exists with total_count, limit, offset, has_next fields
- AssetRepository interface includes ListDatabasesPaginated, ListTablesPaginated, ListColumnsPaginated
- MockAssetRepository implements all paginated methods with count tracking
- All existing tests pass (backward compatibility maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pagination/04-01-SUMMARY.md`
</output>
