---
phase: 10-asset-browser-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
autonomous: true

must_haves:
  truths:
    - "User sees pagination controls below database list"
    - "User sees pagination controls below table list when database is expanded"
    - "Pagination displays 'Showing X-Y of Z' information"
    - "Clicking Next/Previous navigates between pages"
    - "Pagination resets to page 1 when switching to a different database"
  artifacts:
    - path: "lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx"
      provides: "AssetBrowser with pagination at database and table levels"
      contains: "Pagination"
  key_links:
    - from: "AssetBrowser.tsx"
      to: "Pagination component"
      via: "import and render"
      pattern: "import.*Pagination"
    - from: "AssetBrowser.tsx"
      to: "useOpenLineageDatasets"
      via: "pagination state (offset)"
      pattern: "useState.*offset"
---

<objective>
Add pagination controls to the AssetBrowser database list and table list sections.

Purpose: Enable users to navigate through large datasets in the asset browser without loading everything at once. Currently the AssetBrowser fetches with a hardcoded limit of 1000, which doesn't scale well.

Output: AssetBrowser component with working pagination at database and table levels.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-asset-browser-integration/10-CONTEXT.md
@.planning/phases/10-asset-browser-integration/10-RESEARCH.md
@.planning/phases/09-pagination-component/09-01-SUMMARY.md

@lineage-ui/src/components/common/Pagination.tsx
@lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
@lineage-ui/src/api/hooks/useOpenLineage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination state and controls to AssetBrowser</name>
  <files>lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx</files>
  <action>
Refactor AssetBrowser to add pagination at two levels:

**1. Import Pagination component:**
```typescript
import { Pagination } from '../../common/Pagination';
```

**2. Add pagination state to AssetBrowser component:**
```typescript
const [datasetOffset, setDatasetOffset] = useState(0);
const DATASETS_LIMIT = 100;
```

**3. Update useOpenLineageDatasets call:**
Replace the hardcoded `{ limit: 1000, offset: 0 }` with:
```typescript
const { data: datasetsData, isLoading: isLoadingDatasets, isFetching: isFetchingDatasets } = useOpenLineageDatasets(
  defaultNamespace?.id || '',
  { limit: DATASETS_LIMIT, offset: datasetOffset }
);
```
Note: Add `isFetching` to track background fetches for loading state.

**4. Add pagination controls below database list:**
After the `</ul>` that closes the database list, add:
```typescript
{/* Pagination - always visible per CONTEXT.md */}
<div className="mt-4 flex justify-center px-2">
  <Pagination
    totalCount={datasetsData?.pagination?.total_count || datasetsData?.total || datasets.length}
    limit={DATASETS_LIMIT}
    offset={datasetOffset}
    onPageChange={setDatasetOffset}
    isLoading={isFetchingDatasets}
    showFirstLast={true}
    showPageInfo={true}
  />
</div>
```

**5. Add pagination state per expanded database:**
The current implementation groups datasets by database name client-side. For table pagination within a database, we need per-database pagination state. Modify DatabaseItem to manage its own table pagination:

In DatabaseItem component:
```typescript
function DatabaseItem({ databaseName, datasets, isExpanded, onToggle, expandedDatasets, onToggleDataset }: DatabaseItemProps) {
  const navigate = useNavigate();
  const [tableOffset, setTableOffset] = useState(0);
  const TABLE_LIMIT = 100;

  // Reset pagination when database is collapsed or expanded to a different one
  // (implicit: tableOffset resets when component unmounts/remounts)

  // Paginate the datasets for this database
  const paginatedDatasets = datasets.slice(tableOffset, tableOffset + TABLE_LIMIT);
  const totalTables = datasets.length;
  // ... rest of component
```

**6. Add table pagination controls in DatabaseItem:**
After the table list `</ul>` inside the expanded section, add:
```typescript
{isExpanded && (
  <ul className="ml-4 mt-1 space-y-1">
    {paginatedDatasets.map((dataset) => (
      <DatasetItem ... />
    ))}
  </ul>
  {/* Table pagination - always visible per CONTEXT.md */}
  <div className="ml-4 mt-2 flex justify-center">
    <Pagination
      totalCount={totalTables}
      limit={TABLE_LIMIT}
      offset={tableOffset}
      onPageChange={setTableOffset}
      showFirstLast={true}
      showPageInfo={true}
    />
  </div>
)}
```

**7. Reset table pagination on database collapse:**
When database is collapsed, the component re-renders with tableOffset at 0 naturally since useState initializes to 0. But to satisfy ASSET-05 (reset when switching databases), we need to ensure the pagination resets. Since each DatabaseItem manages its own state and the list is keyed by `dbName`, React will preserve state. Add an effect to reset:
```typescript
// Reset pagination when database changes (component receives new databaseName)
useEffect(() => {
  setTableOffset(0);
}, [databaseName]);
```

**Key implementation notes:**
- Per CONTEXT.md: Pagination is ALWAYS visible, even with 1 page
- Per CONTEXT.md: Bottom placement only, centered
- Use `isFetching` (not `isLoading`) for Pagination's `isLoading` prop to show loading during page changes
- Defensive fallbacks for total count: `pagination?.total_count || total || datasets.length`
  </action>
  <verify>
1. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` - No TypeScript errors
2. Visual check: Pagination component appears below database list and below table list when expanded
  </verify>
  <done>
- Pagination component renders below database list (always visible)
- Pagination component renders below table list when database is expanded (always visible)
- Table pagination resets to page 1 when switching databases (useEffect reset)
- Next/Previous buttons navigate between pages
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify pagination integration works with existing tests</name>
  <files>lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx</files>
  <action>
Run existing AssetBrowser tests to verify the integration doesn't break existing functionality.

**Important context from research:**
The test file mocks v1 hooks (useDatabases, useTables, useColumns) but the component uses OpenLineage hooks. The tests will fail because the mocks don't match the implementation.

**Do NOT modify tests in this task.** The goal is to verify the component compiles and pagination logic is correct. Test alignment will be handled in Plan 02.

Run tests and document which tests pass/fail:
```bash
cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm test -- --run AssetBrowser
```

If tests fail due to hook mocking mismatch, that's expected. The key verification is:
1. Component compiles without TypeScript errors
2. Component renders pagination controls as expected (manual visual check or new test)
  </action>
  <verify>
1. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` passes
2. Document test results - failures due to hook mocking mismatch are expected and will be fixed in Plan 02
  </verify>
  <done>
- TypeScript compilation successful
- Test results documented (failures expected due to hook mocking)
- Component logic verified to be correct
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd lineage-ui && npx tsc --noEmit`
2. Start dev server and visually verify pagination appears:
   - Below database list (always visible)
   - Below table list when database expanded (always visible)
3. Test pagination navigation works (click Next, verify offset changes)
4. Test database switch resets table pagination
</verification>

<success_criteria>
1. Pagination component visible below database list
2. Pagination component visible below table list (when expanded)
3. "Showing X-Y of Z" displays correct counts
4. Next/Previous buttons change the displayed items
5. Switching databases resets table pagination to page 1
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-asset-browser-integration/10-01-SUMMARY.md`
</output>
