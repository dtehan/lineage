---
phase: 10-asset-browser-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
autonomous: true

must_haves:
  truths:
    - "User sees pagination controls below database list"
    - "User sees pagination controls below table list when database is expanded"
    - "Pagination displays 'Showing X-Y of Z' information"
    - "Clicking Next/Previous navigates between pages"
    - "Pagination resets to page 1 when switching to a different database"
    - "Pagination state persists when collapsing and re-expanding the same database"
  artifacts:
    - path: "lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx"
      provides: "AssetBrowser with pagination at database and table levels"
      contains: "Pagination"
  key_links:
    - from: "AssetBrowser.tsx"
      to: "Pagination component"
      via: "import and render"
      pattern: "import.*Pagination"
    - from: "DatabaseItem"
      to: "datasets.slice"
      via: "client-side pagination"
      pattern: "datasets\\.slice\\(tableOffset"
---

<objective>
Add pagination controls to the AssetBrowser database list and table list sections.

Purpose: Enable users to navigate through large datasets in the asset browser without loading everything at once. Currently the AssetBrowser fetches with a hardcoded limit of 1000, which doesn't scale well.

Output: AssetBrowser component with working pagination at database and table levels.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-asset-browser-integration/10-CONTEXT.md
@.planning/phases/10-asset-browser-integration/10-RESEARCH.md
@.planning/phases/09-pagination-component/09-01-SUMMARY.md

@lineage-ui/src/components/common/Pagination.tsx
@lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx
@lineage-ui/src/api/hooks/useOpenLineage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination state and controls to AssetBrowser</name>
  <files>lineage-ui/src/components/domain/AssetBrowser/AssetBrowser.tsx</files>
  <action>
Refactor AssetBrowser to add pagination at two levels. This implementation uses CLIENT-SIDE pagination because:
- The API returns datasets (not databases) - databases are derived by grouping datasets by prefix
- Server-side pagination of datasets doesn't map to "databases per page" (the grouping happens after fetch)
- Table pagination within a database is purely slicing the datasets array for that database

**PAGINATION ARCHITECTURE:**

1. **Database-level pagination:** Client-side slice of `databaseNames` array (after grouping datasets)
2. **Table-level pagination:** Client-side slice of `datasets` array within each DatabaseItem

**STATE PERSISTENCE NOTE:**
Per ASSET-02, pagination state persists when navigating away and returning. React's useState provides this automatically:
- Database pagination state is in AssetBrowser component (persists while component is mounted)
- Table pagination state is in each DatabaseItem component (persists while database is expanded)
- When user collapses and re-expands a database, the DatabaseItem remounts with offset=0, which is correct behavior (reset on collapse)
- When user navigates to lineage and returns, AssetBrowser remounts - we accept offset reset on navigation as acceptable UX

**1. Import Pagination component:**
```typescript
import { Pagination } from '../../common/Pagination';
```

**2. Add database pagination state to AssetBrowser component:**
```typescript
const [dbOffset, setDbOffset] = useState(0);
const DB_LIMIT = 100;
```

**3. Paginate the database list (NOT the API call):**
After `const databaseNames = Object.keys(datasetsByDatabase).sort();`, add:
```typescript
// Paginate database list (client-side - databases are derived from grouped datasets)
const totalDatabases = databaseNames.length;
const paginatedDatabaseNames = databaseNames.slice(dbOffset, dbOffset + DB_LIMIT);
```

Update the render to use `paginatedDatabaseNames` instead of `databaseNames`:
```typescript
{paginatedDatabaseNames.map((dbName) => (
  <DatabaseItem ... />
))}
```

**4. Add pagination controls below database list:**
After the `</ul>` that closes the database list, add:
```typescript
{/* Database pagination - always visible per CONTEXT.md */}
<div className="mt-4 flex justify-center px-2">
  <Pagination
    totalCount={totalDatabases}
    limit={DB_LIMIT}
    offset={dbOffset}
    onPageChange={setDbOffset}
    showFirstLast={true}
    showPageInfo={true}
  />
</div>
```

**5. Add table pagination state to DatabaseItem:**
```typescript
function DatabaseItem({ databaseName, datasets, isExpanded, onToggle, expandedDatasets, onToggleDataset }: DatabaseItemProps) {
  const navigate = useNavigate();
  const [tableOffset, setTableOffset] = useState(0);
  const TABLE_LIMIT = 100;

  // Paginate the datasets (tables) for this database (client-side slicing)
  const totalTables = datasets.length;
  const paginatedDatasets = datasets.slice(tableOffset, tableOffset + TABLE_LIMIT);
  // ... rest of component
```

**6. Reset table pagination when database changes (component identity):**
The DatabaseItem is keyed by `dbName`, so React will preserve component state for the same database. Add an effect to reset when the database identity changes:
```typescript
// Reset pagination if database name changes (shouldn't happen but defensive)
useEffect(() => {
  setTableOffset(0);
}, [databaseName]);
```

**7. Update table rendering to use paginated list:**
Replace `datasets.map((dataset) => ...)` with `paginatedDatasets.map((dataset) => ...)`.

**8. Add table pagination controls in DatabaseItem:**
After the table list `</ul>` inside the expanded section, add:
```typescript
{isExpanded && (
  <>
    <ul className="ml-4 mt-1 space-y-1">
      {paginatedDatasets.map((dataset) => (
        <DatasetItem ... />
      ))}
    </ul>
    {/* Table pagination - always visible per CONTEXT.md */}
    <div className="ml-4 mt-2 flex justify-center">
      <Pagination
        totalCount={totalTables}
        limit={TABLE_LIMIT}
        offset={tableOffset}
        onPageChange={setTableOffset}
        showFirstLast={true}
        showPageInfo={true}
      />
    </div>
  </>
)}
```

**Key implementation notes:**
- Per CONTEXT.md: Pagination is ALWAYS visible, even with 1 page
- Per CONTEXT.md: Bottom placement only, centered
- Both levels use CLIENT-SIDE pagination (slicing arrays) - the useOpenLineageDatasets call remains unchanged
- State persistence: React component state persists while mounted, resets on remount (acceptable UX)
  </action>
  <verify>
1. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npx tsc --noEmit` - No TypeScript errors
2. `cd /Users/Daniel.Tehan/Code/lineage/lineage-ui && npm run dev` - Start dev server
3. Visual check: Pagination component appears below database list and below table list when expanded
  </verify>
  <done>
- Pagination component renders below database list (always visible)
- Pagination component renders below table list when database is expanded (always visible)
- Table pagination resets to page 1 when switching databases (component remount with fresh state)
- Next/Previous buttons navigate between pages (client-side slice changes)
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd lineage-ui && npx tsc --noEmit`
2. Start dev server and visually verify pagination appears:
   - Below database list (always visible)
   - Below table list when database expanded (always visible)
3. Test pagination navigation works (click Next, verify displayed items change)
4. Test database switch: expand DB1, navigate tables, collapse DB1, expand DB2, verify table pagination is at page 1
5. Test same-database re-expand: expand DB1, navigate to page 2, collapse DB1, re-expand DB1, verify pagination resets to page 1 (component remount behavior)
</verification>

<success_criteria>
1. Pagination component visible below database list
2. Pagination component visible below table list (when expanded)
3. "Showing X-Y of Z" displays correct counts
4. Next/Previous buttons change the displayed items
5. Switching databases shows table pagination at page 1
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-asset-browser-integration/10-01-SUMMARY.md`
</output>
