---
phase: 18-frontend-rendering-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lineage-ui/src/__tests__/performance/fixtures/graphGenerators.ts
  - lineage-ui/src/__tests__/performance/layoutEngine.bench.ts
  - lineage-ui/src/__tests__/performance/graphRender.bench.ts
  - lineage-ui/src/utils/graph/layoutEngine.ts
  - lineage-ui/vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Developers can generate test graphs of 50, 100, and 200 nodes programmatically"
    - "Developers can run ELK layout benchmarks and see timing results"
    - "Developers can run React Flow render benchmarks and see timing results"
    - "layoutEngine returns timing metrics (prepTime, elkTime, transformTime)"
    - "Benchmark suite runs via npm script command"
  artifacts:
    - path: "lineage-ui/src/__tests__/performance/fixtures/graphGenerators.ts"
      provides: "Graph factory functions for 50/100/200 node test data"
      exports: ["generateGraph", "generateLayeredGraph"]
    - path: "lineage-ui/src/__tests__/performance/layoutEngine.bench.ts"
      provides: "ELK.js layout performance benchmarks"
      contains: "bench.*layout.*nodes"
    - path: "lineage-ui/src/__tests__/performance/graphRender.bench.ts"
      provides: "React Flow render performance benchmarks"
      contains: "bench.*render.*nodes"
    - path: "lineage-ui/src/utils/graph/layoutEngine.ts"
      provides: "Timing metrics in layout return value"
      contains: "LayoutMetrics"
  key_links:
    - from: "graphGenerators.ts"
      to: "layoutEngine.bench.ts"
      via: "import generateGraph"
      pattern: "import.*generateGraph.*graphGenerators"
    - from: "graphGenerators.ts"
      to: "graphRender.bench.ts"
      via: "import generateGraph"
      pattern: "import.*generateGraph.*graphGenerators"
    - from: "layoutEngine.ts"
      to: "benchmark files"
      via: "metrics return value"
      pattern: "metrics\\?\\."
---

<objective>
Create automated benchmark suite for measuring ELK.js layout and React Flow rendering performance with large graphs (50, 100, 200 nodes).

Purpose: Establish baseline performance measurements to identify bottlenecks and enable regression detection. This data drives optimization decisions in Plan 02.

Output:
- Graph generator utilities for consistent test data
- Vitest benchmark files for ELK layout timing
- Vitest benchmark files for React Flow render timing
- Enhanced layoutEngine with timing metrics
- npm script to run benchmarks
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-frontend-rendering-performance/18-RESEARCH.md

# Existing code to understand/modify
@lineage-ui/src/utils/graph/layoutEngine.ts
@lineage-ui/src/__tests__/integration/correctness.test.ts
@lineage-ui/vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph generator utilities and ELK benchmarks</name>
  <files>
    lineage-ui/src/__tests__/performance/fixtures/graphGenerators.ts
    lineage-ui/src/__tests__/performance/layoutEngine.bench.ts
    lineage-ui/src/utils/graph/layoutEngine.ts
  </files>
  <action>
1. Create `graphGenerators.ts` with factory functions:
   - `generateGraph(nodeCount: number)`: Creates multi-table lineage graph with specified total column count
     - Uses layer pattern (sqrt(nodeCount) layers, nodeCount/layers columns per layer)
     - Each column in separate table (cross-table edges to test both layout paths)
     - Returns `{ nodes: LineageNode[], edges: LineageEdge[], nodeCount, edgeCount }`
   - `generateLayeredGraph(depth: number, breadth: number)`: Creates graph with specific depth/breadth
     - Useful for testing deep vs wide graphs
   - Pattern: Match structure from correctness.test.ts helpers (createColumnNode, createEdge)

2. Add `LayoutMetrics` interface and return metrics from layoutEngine:
   - Add interface: `interface LayoutMetrics { prepTime: number; elkTime: number; transformTime: number; totalTime: number; }`
   - Update `layoutGraph` return type to include optional metrics: `Promise<{ nodes: Node[]; edges: Edge[]; metrics?: LayoutMetrics }>`
   - Add timing instrumentation using `performance.now()`:
     - prepTime: groupColumnsByTable + transformToTableNodes
     - elkTime: elk.layout() call
     - transformTime: mapping ELK results to React Flow format
   - Only collect metrics when not in production (check `process.env.NODE_ENV !== 'production'`)

3. Create `layoutEngine.bench.ts`:
   - Import from vitest: `bench`, `describe`
   - Import `layoutGraph` and `generateGraph`
   - Describe block: "ELK Layout Performance"
   - Three benchmarks: 50, 100, 200 nodes
   - Each benchmark: `bench('layout N nodes', async () => { await layoutGraph(graph.nodes, graph.edges); }, { time: 5000 })`
   - Generate graphs OUTSIDE bench function (in describe scope) to avoid measuring generation time
   - Include warm-up: Run one layout before benchmark starts (ELK WASM initialization)

Note: Follow Vitest bench API from research - use `time` option for benchmark duration.
  </action>
  <verify>
Run: `cd lineage-ui && npx vitest bench src/__tests__/performance/layoutEngine.bench.ts --run`
Expected: Benchmark completes without errors, shows timing for 50/100/200 node layouts.
  </verify>
  <done>
- graphGenerators.ts exports generateGraph and generateLayeredGraph functions
- layoutEngine.ts returns LayoutMetrics with prep/elk/transform/total times
- layoutEngine.bench.ts runs 3 benchmarks (50, 100, 200 nodes) and reports timing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React Flow render benchmarks and update Vitest config</name>
  <files>
    lineage-ui/src/__tests__/performance/graphRender.bench.ts
    lineage-ui/vitest.config.ts
    lineage-ui/package.json
  </files>
  <action>
1. Create `graphRender.bench.ts`:
   - Tests React Flow render time using React Testing Library
   - Import: `bench`, `describe` from vitest
   - Import: `render`, `cleanup` from @testing-library/react
   - Import: `ReactFlow`, `ReactFlowProvider` from @xyflow/react
   - Import: `generateGraph` from fixtures

   - For render benchmarks:
     ```typescript
     // Pre-generate and pre-layout graphs outside benchmark
     const graph50 = await prepareGraph(50);  // { nodes, edges } already layouted
     const graph100 = await prepareGraph(100);
     const graph200 = await prepareGraph(200);

     bench('render 50 nodes', () => {
       render(
         <ReactFlowProvider>
           <ReactFlow nodes={graph50.nodes} edges={graph50.edges} />
         </ReactFlowProvider>
       );
       cleanup();
     }, { time: 5000 });
     ```

   - For interaction responsiveness (zoom/pan):
     - Use `performance.now()` to measure time between interaction and render completion
     - Test viewport changes on 100-node graph
     - Target: <100ms for interaction response

2. Update `vitest.config.ts`:
   - Add benchmark configuration:
     ```typescript
     benchmark: {
       include: ['**/*.bench.ts'],
       reporters: ['default'],
     },
     ```
   - Keep test config separate (benchmarks don't run with regular tests)

3. Add npm script to package.json:
   - Add: `"bench": "vitest bench"`
   - Add: `"bench:run": "vitest bench --run"` (single run, no watch)

Note: React Flow render benchmarks may be slower due to JSDOM limitations. Document this in benchmark output comments. The primary value is relative comparison (50 vs 100 vs 200), not absolute numbers.
  </action>
  <verify>
Run: `cd lineage-ui && npm run bench:run`
Expected:
- Both layout and render benchmarks execute
- Results show timing for 50/100/200 node scenarios
- No test failures or errors
  </verify>
  <done>
- graphRender.bench.ts runs render benchmarks for 50/100/200 nodes
- vitest.config.ts includes benchmark configuration
- package.json has "bench" and "bench:run" scripts
- Running `npm run bench:run` executes all benchmarks and reports results
  </done>
</task>

</tasks>

<verification>
1. Run ELK benchmarks: `cd lineage-ui && npx vitest bench src/__tests__/performance/layoutEngine.bench.ts --run`
2. Run render benchmarks: `cd lineage-ui && npx vitest bench src/__tests__/performance/graphRender.bench.ts --run`
3. Run all benchmarks: `cd lineage-ui && npm run bench:run`
4. Verify layoutEngine returns metrics: Check that layoutGraph return value includes metrics object
5. Verify existing tests still pass: `cd lineage-ui && npm test -- --run`
</verification>

<success_criteria>
- [ ] graphGenerators.ts creates consistent test graphs of 50, 100, 200 nodes
- [ ] layoutEngine.ts returns LayoutMetrics with timing breakdown
- [ ] layoutEngine.bench.ts benchmarks ELK layout for 3 graph sizes
- [ ] graphRender.bench.ts benchmarks React Flow render for 3 graph sizes
- [ ] vitest.config.ts includes benchmark configuration
- [ ] package.json has bench scripts
- [ ] `npm run bench:run` executes all benchmarks successfully
- [ ] Existing unit tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-frontend-rendering-performance/18-01-SUMMARY.md`

Include benchmark results in summary:
- ELK layout times for 50/100/200 nodes
- React Flow render times for 50/100/200 nodes
- Identified bottleneck (layout vs render)
- Recommendations for Plan 02 optimizations
</output>
