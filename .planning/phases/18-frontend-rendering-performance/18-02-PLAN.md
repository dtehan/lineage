---
phase: 18-frontend-rendering-performance
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - lineage-ui/src/hooks/useLoadingProgress.ts
  - lineage-ui/src/components/common/LoadingProgress.tsx
  - lineage-ui/src/components/domain/LineageGraph/LargeGraphWarning.tsx
  - lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
autonomous: true

must_haves:
  truths:
    - "Users see time elapsed and ETA during large graph loads"
    - "Users see a warning before rendering graphs with 200+ nodes"
    - "Users see depth reduction suggestion when graphs are large"
    - "Zoom/pan interactions remain responsive with large graphs"
    - "onlyRenderVisibleElements threshold is verified or optimized based on benchmarks"
  artifacts:
    - path: "lineage-ui/src/hooks/useLoadingProgress.ts"
      provides: "ETA calculation and elapsed time tracking"
      contains: "estimatedTimeRemaining"
    - path: "lineage-ui/src/components/common/LoadingProgress.tsx"
      provides: "ETA display in progress bar"
      contains: "ETA"
    - path: "lineage-ui/src/components/domain/LineageGraph/LargeGraphWarning.tsx"
      provides: "Warning component for 200+ node graphs"
      exports: ["LargeGraphWarning"]
    - path: "lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx"
      provides: "Integration of warning and depth suggestion"
      contains: "LargeGraphWarning"
  key_links:
    - from: "useLoadingProgress.ts"
      to: "LoadingProgress.tsx"
      via: "elapsed/ETA props"
      pattern: "estimatedTimeRemaining|elapsedTime"
    - from: "LargeGraphWarning.tsx"
      to: "LineageGraph.tsx"
      via: "component import"
      pattern: "import.*LargeGraphWarning"
    - from: "LineageGraph.tsx"
      to: "depth reduction"
      via: "onDepthChange callback"
      pattern: "onDepthChange|setDepth"
---

<objective>
Enhance the large graph user experience with ETA progress display, 200+ node warnings, and depth reduction suggestions based on benchmark findings from Plan 01.

Purpose: Ensure users have good feedback and assistance when working with large graphs, implementing the UX decisions from CONTEXT.md (always render, provide helpful suggestions, show ETA).

Output:
- Enhanced progress bar with elapsed time and ETA
- Warning component for 200+ node graphs (non-blocking)
- Depth reduction suggestion UI
- Verified/optimized onlyRenderVisibleElements threshold
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-frontend-rendering-performance/18-CONTEXT.md
@.planning/phases/18-frontend-rendering-performance/18-01-SUMMARY.md

# Existing code to modify
@lineage-ui/src/hooks/useLoadingProgress.ts
@lineage-ui/src/components/common/LoadingProgress.tsx
@lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance progress UI with elapsed time and ETA</name>
  <files>
    lineage-ui/src/hooks/useLoadingProgress.ts
    lineage-ui/src/components/common/LoadingProgress.tsx
    lineage-ui/src/hooks/useLoadingProgress.test.ts
    lineage-ui/src/components/common/LoadingProgress.test.tsx
  </files>
  <action>
1. Update `useLoadingProgress.ts`:
   - Add `startTime` state (number | null) to track when loading began
   - Add `elapsedTime` derived state (ms since startTime, 0 if not loading)
   - Add `estimatedTimeRemaining` derived state (based on progress and elapsed)
   - Set startTime when stage transitions from 'idle' to 'fetching'
   - Clear startTime when stage transitions to 'complete' or 'idle'

   ETA calculation logic:
   ```typescript
   // Simple linear extrapolation
   const elapsedMs = startTime ? Date.now() - startTime : 0;
   const progressFraction = progress / 100;
   const estimatedTotal = progressFraction > 0.1
     ? elapsedMs / progressFraction
     : null; // Don't estimate until 10% progress
   const estimatedRemaining = estimatedTotal
     ? Math.max(0, estimatedTotal - elapsedMs)
     : null;
   ```

   - Update return type to include `elapsedTime: number` and `estimatedTimeRemaining: number | null`
   - Format helper: `formatDuration(ms: number): string` -> "5s", "1m 30s", etc.

2. Update `LoadingProgress.tsx`:
   - Add optional props: `elapsedTime?: number`, `estimatedTimeRemaining?: number | null`, `showTiming?: boolean`
   - When `showTiming` is true and values provided:
     - Display elapsed time below message: "Elapsed: 5s"
     - Display ETA when available: "ETA: ~10s"
   - Keep timing display subtle (smaller text, muted color)
   - ETA should feel helpful not anxiety-inducing (use "~" prefix to indicate estimate)

3. Update tests:
   - useLoadingProgress.test.ts: Test elapsed time tracking and ETA calculation
   - LoadingProgress.test.tsx: Test timing display rendering

Note: ETA accuracy will improve as more data is collected. Initial implementation uses simple linear extrapolation. Can be refined in future iterations if needed.
  </action>
  <verify>
Run: `cd lineage-ui && npm test -- useLoadingProgress --run && npm test -- LoadingProgress --run`
Expected: All tests pass, including new timing-related tests.
  </verify>
  <done>
- useLoadingProgress tracks elapsedTime and calculates estimatedTimeRemaining
- LoadingProgress displays timing when showTiming=true
- Timing display is subtle and uses "~" for estimates
- Tests validate timing functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Create large graph warning and depth suggestion UX</name>
  <files>
    lineage-ui/src/components/domain/LineageGraph/LargeGraphWarning.tsx
    lineage-ui/src/components/domain/LineageGraph/LargeGraphWarning.test.tsx
    lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
  </files>
  <action>
1. Create `LargeGraphWarning.tsx`:
   - Props interface:
     ```typescript
     interface LargeGraphWarningProps {
       nodeCount: number;
       currentDepth: number;
       suggestedDepth: number;
       onAcceptSuggestion: () => void;
       onDismiss: () => void;
     }
     ```
   - Render only when nodeCount >= 200
   - Display warning banner (yellow/amber background, not blocking):
     "Large graph detected: {nodeCount} nodes. This may take a moment to render."
   - Include depth suggestion if currentDepth > suggestedDepth:
     "Try reducing depth from {currentDepth} to {suggestedDepth} for faster rendering."
   - Quick-apply button: "Use depth {suggestedDepth}" -> calls onAcceptSuggestion
   - Dismiss button (X icon) -> calls onDismiss, sets localStorage flag to not show again for session
   - Style: Non-blocking banner at top of graph area, can be dismissed

2. Create `LargeGraphWarning.test.tsx`:
   - Test: Shows warning when nodeCount >= 200
   - Test: Hidden when nodeCount < 200
   - Test: Shows depth suggestion when currentDepth > suggestedDepth
   - Test: Calls onAcceptSuggestion when button clicked
   - Test: Calls onDismiss when X clicked

3. Integrate into `LineageGraph.tsx`:
   - Import LargeGraphWarning
   - Track node count from layouted graph
   - Calculate suggested depth: If nodes > 200, suggest depth that would give ~100 nodes
     - Simple heuristic: suggestedDepth = Math.max(3, currentDepth - 2)
   - Add state for warning dismissed
   - Render LargeGraphWarning above ReactFlow when conditions met
   - Wire onAcceptSuggestion to update depth (via existing depth change mechanism)

4. Verify/optimize onlyRenderVisibleElements threshold:
   - Based on Plan 01 benchmark results, determine if threshold should change from 50
   - If benchmarks show virtualization beneficial at lower threshold, adjust
   - If benchmarks show virtualization overhead not worth it until higher threshold, adjust
   - Document decision in code comment

Note per CONTEXT.md: Always render the graph, never block. Warning is informational, not a gate.
  </action>
  <verify>
Run: `cd lineage-ui && npm test -- LargeGraphWarning --run`
Run: `cd lineage-ui && npm test -- LineageGraph --run` (expect pre-existing failures to remain, no new failures)
Manual: Start app, load a graph with 200+ nodes (if test data supports), verify warning appears.
  </verify>
  <done>
- LargeGraphWarning component shows for 200+ node graphs
- Depth suggestion appears with quick-apply button
- Warning can be dismissed
- LineageGraph integrates warning and wires depth change
- onlyRenderVisibleElements threshold verified/optimized based on benchmarks
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire enhanced progress with timing to LineageGraph</name>
  <files>
    lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
  </files>
  <action>
1. Update LineageGraph to use enhanced loading progress:
   - Pass `showTiming={true}` when node count is known and > 50
   - Pass elapsedTime and estimatedTimeRemaining to LoadingProgress
   - Show timing info during layout stage (when ELK is running)

2. Update layoutEngine callback integration:
   - When layoutGraph returns metrics, log them for debugging:
     `console.debug('[LineageGraph] Layout metrics:', metrics);`
   - This enables developers to see timing breakdown in console

3. Final integration verification:
   - Ensure progress bar shows during all stages
   - Ensure timing appears for larger graphs
   - Ensure warning shows for 200+ nodes
   - Ensure depth suggestion is actionable

Note: Keep existing loading progress behavior for small graphs (no timing display needed).
  </action>
  <verify>
Run: `cd lineage-ui && npm test -- --run` (all tests)
Run: `cd lineage-ui && npm run build` (production build succeeds)
Manual: Test with dev server - load various graph sizes, verify UX flows.
  </verify>
  <done>
- LineageGraph shows timing during large graph loads
- Layout metrics logged to console for debugging
- All components integrated and working together
- Production build succeeds
  </done>
</task>

</tasks>

<verification>
1. Unit tests pass: `cd lineage-ui && npm test -- --run`
2. Benchmarks still run: `cd lineage-ui && npm run bench:run`
3. Production build: `cd lineage-ui && npm run build`
4. Manual verification with dev server:
   - Small graph (<50 nodes): Normal loading, no timing, no warning
   - Medium graph (50-199 nodes): Shows timing during load
   - Large graph (200+ nodes): Shows warning, shows depth suggestion, timing visible
</verification>

<success_criteria>
- [ ] useLoadingProgress tracks elapsed time and calculates ETA
- [ ] LoadingProgress displays timing when showTiming=true
- [ ] LargeGraphWarning shows for 200+ node graphs
- [ ] Depth suggestion with quick-apply button works
- [ ] Warning can be dismissed
- [ ] LineageGraph integrates all new components
- [ ] onlyRenderVisibleElements threshold documented/optimized
- [ ] All tests pass
- [ ] Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/18-frontend-rendering-performance/18-02-SUMMARY.md`

Include:
- Final benchmark results with optimizations applied
- onlyRenderVisibleElements threshold decision
- UX components created
- Performance comparison (before/after if applicable)
</output>
