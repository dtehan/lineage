---
phase: 05-dbql-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - database/extract_dbql_lineage.py
  - database/test_dbql_error_handling.py
autonomous: true

must_haves:
  truths:
    - "Malformed queries are logged and skipped without stopping extraction"
    - "Error logs include query_id, table_name, and error_type"
    - "Extraction prints summary with success/failure/skip counts at completion"
    - "Tests verify continue-on-failure behavior"
  artifacts:
    - path: "database/extract_dbql_lineage.py"
      provides: "Enhanced error handling and summary reporting"
      contains: "extraction_stats.record_failure"
    - path: "database/test_dbql_error_handling.py"
      provides: "Unit tests for DBQL error handling"
      contains: "class TestDBQLErrorHandling"
  key_links:
    - from: "database/extract_dbql_lineage.py"
      to: "ExtractionStats"
      via: "record_failure with query_id, table_name, error_type"
      pattern: "record_failure.*query_id.*table_name.*error_type"
---

<objective>
Implement continue-on-failure error handling, enhanced summary reporting, and tests for DBQL extraction.

Purpose: Make DBQL extraction resilient to individual query failures with detailed error context for debugging.
Output: Updated `extract_dbql_lineage.py` with robust error handling and comprehensive test suite.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dbql-error-handling/05-RESEARCH.md
@.planning/phases/05-dbql-error-handling/05-01-SUMMARY.md

@database/extract_dbql_lineage.py
@database/test_credential_validation.py (test pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace stats dict with ExtractionStats and implement continue-on-failure</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Update DBQLLineageExtractor to use ExtractionStats and implement continue-on-failure:

1. In `__init__`, replace the stats dict with ExtractionStats:
```python
# OLD:
self.stats = {
    'queries_processed': 0,
    'queries_with_lineage': 0,
    'table_lineage_inserted': 0,
    'column_lineage_inserted': 0,
}

# NEW:
self.extraction_stats = ExtractionStats()
self.table_lineage_count = 0
self.column_lineage_count = 0
```

2. In `extract_lineage()`, update the query processing loop (around line 274-322):
```python
for i, (query_id, stmt_type, query_text, query_time, default_database) in enumerate(queries):
    # Progress logging every 1000 queries
    if (i + 1) % 1000 == 0:
        logger.info("Progress: %d/%d queries (%.1f%%)", i + 1, len(queries), 100 * (i + 1) / len(queries))

    # Skip null query text
    if not query_text:
        self.extraction_stats.record_skip("null query_text")
        continue

    # Track latest query time for watermark
    if query_time and (latest_query_time is None or query_time > latest_query_time):
        latest_query_time = query_time

    try:
        # Set the default database context for this query
        if default_database:
            self.parser.default_database = default_database.strip()

        # Parse SQL and extract lineage
        records = self.parser.extract_column_lineage(query_text, stmt_type)

        if records:
            # Process records (existing logic for table_lineage_set and column_lineage_records)
            for rec in records:
                if rec['source_table'] == 'UNKNOWN':
                    continue

                source_tbl_id = f"{rec['source_database']}.{rec['source_table']}"
                target_tbl_id = f"{rec['target_database']}.{rec['target_table']}"

                table_lineage_set.add((
                    source_tbl_id, target_tbl_id,
                    rec['source_database'], rec['source_table'],
                    rec['target_database'], rec['target_table']
                ))

                column_lineage_records.append({
                    'query_id': str(query_id),
                    **rec
                })

            self.extraction_stats.record_success()
        else:
            # No lineage found is not a failure
            self.extraction_stats.record_success()

    except Exception as e:
        # Extract target table from query for context
        table_name = self._extract_target_table(query_text)
        error_type = type(e).__name__

        logger.warning(
            "Failed to extract lineage: query_id=%s, table=%s, error_type=%s, error=%s",
            query_id, table_name, error_type, str(e)[:200]
        )

        self.extraction_stats.record_failure(
            query_id=str(query_id),
            table_name=table_name,
            error_type=error_type,
            error_msg=str(e)
        )
        # Continue processing - don't stop on individual failures
```

3. Add helper method `_extract_target_table` to the class:
```python
def _extract_target_table(self, query_text: str) -> str:
    """Extract target table name from query text for error context."""
    if not query_text:
        return "UNKNOWN"
    import re
    # Try to match INSERT INTO or MERGE INTO
    match = re.search(r'(?:INSERT|MERGE)\s+INTO\s+(["\w]+(?:\.["\w]+)?)', query_text, re.IGNORECASE)
    if match:
        return match.group(1).replace('"', '')
    return "UNKNOWN"
```

4. Update references to old stats dict throughout the file:
- `self.stats['queries_processed']` -> removed (use extraction_stats.processed)
- `self.stats['queries_with_lineage']` -> removed (tracked in extraction_stats.succeeded)
- `self.stats['table_lineage_inserted']` -> `self.table_lineage_count`
- `self.stats['column_lineage_inserted']` -> `self.column_lineage_count`
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import DBQLLineageExtractor; e = DBQLLineageExtractor(); print('Has extraction_stats:', hasattr(e, 'extraction_stats'))"`
Should print: "Has extraction_stats: True"
  </verify>
  <done>
- DBQLLineageExtractor uses ExtractionStats instead of stats dict
- Query processing continues after individual failures
- Failures logged with query_id, table_name, error_type context
- _extract_target_table helper method added
  </done>
</task>

<task type="auto">
  <name>Task 2: Update print_summary with detailed success/failure/skip reporting</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Replace the `print_summary` method with enhanced version that reports extraction outcomes:

```python
def print_summary(self):
    """Print extraction summary with success/failure/skip breakdown."""
    print("\n" + "=" * 60)
    print("EXTRACTION SUMMARY")
    print("=" * 60)
    print(f"  Queries processed:     {self.extraction_stats.processed}")
    print(f"  Succeeded:             {self.extraction_stats.succeeded}")
    print(f"  Failed:                {self.extraction_stats.failed}")
    print(f"  Skipped:               {self.extraction_stats.skipped}")
    print(f"  Table lineage records: {self.table_lineage_count}")
    print(f"  Column lineage records:{self.column_lineage_count}")

    # Log summary for programmatic access
    logger.info("Extraction completed: %s", self.extraction_stats.summary())

    # Show failed query details in verbose mode
    if self.verbose and self.extraction_stats.errors:
        print("\n  Failed Query Details:")
        for i, err in enumerate(self.extraction_stats.errors[:10]):
            print(f"    {i+1}. Query {err['query_id']}: {err['error_type']} on {err['table_name']}")
        if len(self.extraction_stats.errors) > 10:
            print(f"    ... and {len(self.extraction_stats.errors) - 10} more")

    # Get totals from database
    if self.cursor:
        try:
            self.cursor.execute(f"SELECT COUNT(*) FROM {DB_NAME}.LIN_TABLE_LINEAGE")
            total_table = self.cursor.fetchone()[0]
            self.cursor.execute(f"SELECT COUNT(*) FROM {DB_NAME}.LIN_COLUMN_LINEAGE")
            total_column = self.cursor.fetchone()[0]
            print(f"\n  Total in LIN_TABLE_LINEAGE:  {total_table}")
            print(f"  Total in LIN_COLUMN_LINEAGE: {total_column}")
        except Exception:
            pass  # Ignore database errors in summary
```

Also update the insert loops to use the new counters:
- After table lineage insert success: `self.table_lineage_count += 1`
- After column lineage insert success: `self.column_lineage_count += 1`
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import DBQLLineageExtractor; e = DBQLLineageExtractor(verbose=True); e.extraction_stats.processed = 100; e.extraction_stats.succeeded = 95; e.extraction_stats.failed = 3; e.extraction_stats.skipped = 2; e.table_lineage_count = 50; e.column_lineage_count = 200; print('Testing print_summary...')"`
Should not error - verifies the method can access new attributes.
  </verify>
  <done>
- print_summary shows processed/succeeded/failed/skipped counts
- Verbose mode shows first 10 failed query details
- Summary logged via logger.info for programmatic access
- Table and column lineage counts displayed
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite for DBQL error handling</name>
  <files>database/test_dbql_error_handling.py</files>
  <action>
Create new test file `database/test_dbql_error_handling.py` with tests for all DBQL requirements:

```python
#!/usr/bin/env python3
"""
Tests for DBQL error handling in extract_dbql_lineage.py.

Tests verify:
- DBQL-01: Missing DBQL access provides clear fallback guidance
- DBQL-02: Malformed queries logged and skipped without stopping extraction
- DBQL-03: Error logs include query ID, table name, error type
- DBQL-04: Extraction reports summary with success/failure/skip counts
- TEST-05: Tests verify DBQL error handling scenarios
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime

# Import the module under test
from extract_dbql_lineage import (
    DBQLLineageExtractor,
    ExtractionStats,
    configure_logging,
)


class TestExtractionStats:
    """Test the ExtractionStats dataclass."""

    def test_initial_counts_are_zero(self):
        """Stats start at zero."""
        stats = ExtractionStats()
        assert stats.processed == 0
        assert stats.succeeded == 0
        assert stats.failed == 0
        assert stats.skipped == 0
        assert len(stats.errors) == 0

    def test_record_success_increments_counters(self):
        """record_success increments processed and succeeded."""
        stats = ExtractionStats()
        stats.record_success()
        assert stats.processed == 1
        assert stats.succeeded == 1

    def test_record_failure_increments_counters_and_stores_error(self):
        """record_failure increments counters and stores error context."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="12345",
            table_name="demo_user.TEST_TABLE",
            error_type="ParseError",
            error_msg="Unexpected token"
        )
        assert stats.processed == 1
        assert stats.failed == 1
        assert len(stats.errors) == 1
        assert stats.errors[0]['query_id'] == "12345"
        assert stats.errors[0]['table_name'] == "demo_user.TEST_TABLE"
        assert stats.errors[0]['error_type'] == "ParseError"

    def test_record_failure_truncates_long_messages(self):
        """Long error messages are truncated to 200 chars."""
        stats = ExtractionStats()
        long_msg = "x" * 500
        stats.record_failure("1", "tbl", "Error", long_msg)
        assert len(stats.errors[0]['error_message']) == 200

    def test_record_failure_limits_stored_errors(self):
        """Errors list is limited to 1000 to prevent memory issues."""
        stats = ExtractionStats()
        for i in range(1100):
            stats.record_failure(str(i), "tbl", "Error", "msg")
        assert len(stats.errors) == 1000
        assert stats.failed == 1100  # Counter still accurate

    def test_record_skip_increments_counters(self):
        """record_skip increments processed and skipped."""
        stats = ExtractionStats()
        stats.record_skip("null query_text")
        assert stats.processed == 1
        assert stats.skipped == 1

    def test_summary_returns_formatted_string(self):
        """summary() returns human-readable counts."""
        stats = ExtractionStats()
        stats.succeeded = 100
        stats.failed = 5
        stats.skipped = 2
        summary = stats.summary()
        assert "100 succeeded" in summary
        assert "5 failed" in summary
        assert "2 skipped" in summary


class TestCheckDbqlAccess:
    """Test DBQL access checking with actionable error messages (DBQL-01)."""

    def test_access_granted_returns_true(self):
        """When DBQL access works, returns (True, success_message)."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()
        extractor.cursor.execute.return_value = None  # Success

        has_access, message = extractor.check_dbql_access()

        assert has_access is True
        assert "confirmed" in message.lower()

    def test_access_denied_returns_fallback_guidance(self):
        """DBQL-01: Missing access provides clear fallback guidance."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()

        # Simulate Teradata error 3523 (access denied)
        import teradatasql
        extractor.cursor.execute.side_effect = teradatasql.DatabaseError(
            "[Error 3523] User does not have SELECT access to DBC.DBQLogTbl"
        )

        has_access, message = extractor.check_dbql_access()

        assert has_access is False
        # Must include fallback command
        assert "populate_lineage.py --manual" in message
        # Must include grant instructions
        assert "GRANT SELECT" in message

    def test_other_database_error_returns_error_message(self):
        """Non-access errors return the error message."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()

        import teradatasql
        extractor.cursor.execute.side_effect = teradatasql.DatabaseError(
            "[Error 2580] Table not found"
        )

        has_access, message = extractor.check_dbql_access()

        assert has_access is False
        assert "2580" in message or "Table not found" in message


class TestContinueOnFailure:
    """Test that extraction continues after individual query failures (DBQL-02)."""

    def test_malformed_query_does_not_stop_extraction(self):
        """DBQL-02: Malformed queries logged and skipped without failing extraction."""
        extractor = DBQLLineageExtractor(verbose=True)

        # Mock parser to fail on specific query
        mock_parser = Mock()
        def parse_side_effect(sql, stmt_type=None):
            if "INVALID" in sql:
                raise Exception("Parse error: unexpected token")
            return []  # No lineage for valid queries (simplified)

        mock_parser.extract_column_lineage.side_effect = parse_side_effect
        extractor.parser = mock_parser

        # Process queries directly (bypassing fetch_queries)
        queries = [
            (1, 'Insert', 'INSERT INTO t1 SELECT * FROM t2', datetime.now(), 'demo_user'),
            (2, 'Insert', 'INVALID SQL {{{{', datetime.now(), 'demo_user'),  # Will fail
            (3, 'Insert', 'INSERT INTO t3 SELECT * FROM t4', datetime.now(), 'demo_user'),
        ]

        # Manually process queries to test continue-on-failure
        for query_id, stmt_type, query_text, query_time, default_db in queries:
            try:
                extractor.parser.extract_column_lineage(query_text, stmt_type)
                extractor.extraction_stats.record_success()
            except Exception as e:
                extractor.extraction_stats.record_failure(
                    str(query_id), "UNKNOWN", type(e).__name__, str(e)
                )

        # All 3 queries should be processed
        assert extractor.extraction_stats.processed == 3
        # 1 should have failed
        assert extractor.extraction_stats.failed == 1
        # 2 should have succeeded
        assert extractor.extraction_stats.succeeded == 2


class TestErrorLogging:
    """Test that error logs include required context (DBQL-03)."""

    def test_error_includes_query_id(self):
        """DBQL-03: Error context includes query_id."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="ABC123",
            table_name="test_table",
            error_type="ParseError",
            error_msg="test error"
        )
        assert stats.errors[0]['query_id'] == "ABC123"

    def test_error_includes_table_name(self):
        """DBQL-03: Error context includes table_name."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="123",
            table_name="demo_user.MY_TABLE",
            error_type="ParseError",
            error_msg="test error"
        )
        assert stats.errors[0]['table_name'] == "demo_user.MY_TABLE"

    def test_error_includes_error_type(self):
        """DBQL-03: Error context includes error_type."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="123",
            table_name="tbl",
            error_type="ValidationError",
            error_msg="test error"
        )
        assert stats.errors[0]['error_type'] == "ValidationError"


class TestExtractTargetTable:
    """Test the _extract_target_table helper method."""

    def test_extracts_insert_into_table(self):
        """Extracts table from INSERT INTO statement."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("INSERT INTO demo_user.MY_TABLE SELECT * FROM src")
        assert table == "demo_user.MY_TABLE"

    def test_extracts_merge_into_table(self):
        """Extracts table from MERGE INTO statement."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("MERGE INTO target_tbl USING src ON ...")
        assert table == "target_tbl"

    def test_returns_unknown_for_unmatched(self):
        """Returns UNKNOWN when pattern doesn't match."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("SELECT * FROM something")
        assert table == "UNKNOWN"

    def test_handles_null_query(self):
        """Returns UNKNOWN for null/empty query."""
        extractor = DBQLLineageExtractor()
        assert extractor._extract_target_table(None) == "UNKNOWN"
        assert extractor._extract_target_table("") == "UNKNOWN"


class TestSummaryReporting:
    """Test extraction summary reporting (DBQL-04)."""

    def test_summary_includes_all_counts(self):
        """DBQL-04: Summary includes success/failure/skip counts."""
        stats = ExtractionStats()
        stats.succeeded = 100
        stats.failed = 5
        stats.skipped = 2
        stats.processed = 107

        summary = stats.summary()

        assert "100" in summary  # succeeded
        assert "5" in summary    # failed
        assert "2" in summary    # skipped


class TestLoggingConfiguration:
    """Test logging configuration."""

    def test_configure_logging_returns_logger(self):
        """configure_logging returns a configured logger."""
        logger = configure_logging(verbose=False)
        assert logger.name == 'dbql_extractor'

    def test_verbose_sets_debug_level(self):
        """Verbose mode sets DEBUG level."""
        import logging
        logger = configure_logging(verbose=True)
        assert logger.level == logging.DEBUG

    def test_non_verbose_sets_info_level(self):
        """Non-verbose mode sets INFO level."""
        import logging
        # Clear handlers from previous test
        logger = logging.getLogger('dbql_extractor')
        logger.handlers = []
        logger = configure_logging(verbose=False)
        assert logger.level == logging.INFO


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -m pytest test_dbql_error_handling.py -v --tb=short 2>&1 | head -50`
All tests should pass.
  </verify>
  <done>
- test_dbql_error_handling.py created with comprehensive test coverage
- Tests cover DBQL-01 (access guidance), DBQL-02 (continue-on-failure), DBQL-03 (error context), DBQL-04 (summary)
- Tests use pytest and mock patterns consistent with existing tests
- All tests pass
  </done>
</task>

</tasks>

<verification>
Run full test suite:

```bash
cd /Users/Daniel.Tehan/Code/lineage/database

# Run new DBQL error handling tests
python -m pytest test_dbql_error_handling.py -v

# Verify module still imports cleanly
python -c "import extract_dbql_lineage; print('Module imports OK')"

# Quick functional test of ExtractionStats
python -c "
from extract_dbql_lineage import ExtractionStats
s = ExtractionStats()
s.record_success()
s.record_failure('123', 'tbl', 'ParseError', 'test')
s.record_skip()
print('Stats:', s.summary())
assert s.processed == 3
assert s.succeeded == 1
assert s.failed == 1
assert s.skipped == 1
print('Functional test PASSED')
"
```

Expected: All tests pass, module imports cleanly, functional test passes.
</verification>

<success_criteria>
1. DBQL-01: check_dbql_access returns actionable guidance with "populate_lineage.py --manual"
2. DBQL-02: Query processing loop catches exceptions and continues via record_failure
3. DBQL-03: record_failure captures query_id, table_name, error_type
4. DBQL-04: print_summary displays processed/succeeded/failed/skipped counts
5. TEST-05: All tests in test_dbql_error_handling.py pass
6. Existing functionality preserved - no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-dbql-error-handling/05-02-SUMMARY.md`
</output>
