---
phase: 05-dbql-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - database/extract_dbql_lineage.py
  - database/test_dbql_error_handling.py
autonomous: true

must_haves:
  truths:
    - "Malformed queries are logged and skipped without stopping extraction"
    - "Extraction completes successfully even when individual queries fail"
    - "Error logs include query_id, table_name, and error_type"
    - "Extraction prints summary with success/failure/skip counts at completion"
    - "Extraction validates DBQL data completeness before processing"
    - "Tests verify continue-on-failure behavior"
  artifacts:
    - path: "database/extract_dbql_lineage.py"
      provides: "Enhanced error handling and summary reporting"
      contains: "extraction_stats.record_failure"
    - path: "database/test_dbql_error_handling.py"
      provides: "Unit tests for DBQL error handling"
      contains: "class TestDBQLErrorHandling"
  key_links:
    - from: "database/extract_dbql_lineage.py"
      to: "ExtractionStats"
      via: "record_failure with query_id, table_name, error_type"
      pattern: "record_failure.*query_id.*table_name.*error_type"
    - from: "extract_lineage"
      to: "validate_dbql_data"
      via: "data completeness check before processing"
      pattern: "validate_dbql_data"
---

<objective>
Implement continue-on-failure error handling, DBQL data validation, enhanced summary reporting, and tests for DBQL extraction.

Purpose: Make DBQL extraction resilient to individual query failures with detailed error context for debugging.
Output: Updated `extract_dbql_lineage.py` with robust error handling and comprehensive test suite.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dbql-error-handling/05-RESEARCH.md
@.planning/phases/05-dbql-error-handling/05-01-SUMMARY.md

@database/extract_dbql_lineage.py
@database/test_credential_validation.py (test pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Add _extract_target_table helper method and initialize counters</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Add helper method and update initialization in DBQLLineageExtractor:

1. In `__init__`, add lineage counters (keep backward compatible with existing stats dict):
```python
# After self.extraction_stats = ExtractionStats():
self.table_lineage_count = 0
self.column_lineage_count = 0
```

2. Add the `_extract_target_table` helper method to DBQLLineageExtractor class (after __init__, before connect):
```python
def _extract_target_table(self, query_text: str) -> str:
    """Extract target table name from query text for error context."""
    if not query_text:
        return "UNKNOWN"
    import re
    # Try to match INSERT INTO or MERGE INTO
    match = re.search(r'(?:INSERT|MERGE)\s+INTO\s+(["\w]+(?:\.["\w]+)?)', query_text, re.IGNORECASE)
    if match:
        return match.group(1).replace('"', '')
    return "UNKNOWN"
```

This sets up the foundation for Task 1b without modifying the complex query loop yet.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import DBQLLineageExtractor; e = DBQLLineageExtractor(); print('Has counters:', hasattr(e, 'table_lineage_count') and hasattr(e, 'column_lineage_count')); print('Has helper:', hasattr(e, '_extract_target_table')); print('Helper works:', e._extract_target_table('INSERT INTO demo.table1 SELECT * FROM src') == 'demo.table1')"`
Should print all True values.
  </verify>
  <done>
- DBQLLineageExtractor has table_lineage_count and column_lineage_count initialized to 0
- _extract_target_table helper method exists and correctly extracts table names
- Helper handles INSERT INTO and MERGE INTO patterns
- Helper returns "UNKNOWN" for null/empty/unmatched input
  </done>
</task>

<task type="auto">
  <name>Task 1b: Update query processing loop with continue-on-failure</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Update the query processing loop in `extract_lineage()` to use ExtractionStats and continue-on-failure:

**IMPORTANT:** First verify parser exists before accessing it. The parser attribute is set in __init__.

In `extract_lineage()`, update the query processing loop (around line 274-322):
```python
for i, (query_id, stmt_type, query_text, query_time, default_database) in enumerate(queries):
    # Progress logging every 1000 queries
    if (i + 1) % 1000 == 0:
        logger.info("Progress: %d/%d queries (%.1f%%)", i + 1, len(queries), 100 * (i + 1) / len(queries))

    # Skip null query text
    if not query_text:
        self.extraction_stats.record_skip("null query_text")
        continue

    # Track latest query time for watermark
    if query_time and (latest_query_time is None or query_time > latest_query_time):
        latest_query_time = query_time

    try:
        # Guard: verify parser exists (should be set in __init__)
        if not hasattr(self, 'parser') or self.parser is None:
            logger.error("Parser not initialized - cannot process queries")
            self.extraction_stats.record_failure(
                str(query_id), "UNKNOWN", "ConfigurationError", "Parser not initialized"
            )
            continue

        # Set the default database context for this query
        if default_database:
            self.parser.default_database = default_database.strip()

        # Parse SQL and extract lineage
        records = self.parser.extract_column_lineage(query_text, stmt_type)

        if records:
            # Process records (existing logic for table_lineage_set and column_lineage_records)
            for rec in records:
                if rec['source_table'] == 'UNKNOWN':
                    continue

                source_tbl_id = f"{rec['source_database']}.{rec['source_table']}"
                target_tbl_id = f"{rec['target_database']}.{rec['target_table']}"

                table_lineage_set.add((
                    source_tbl_id, target_tbl_id,
                    rec['source_database'], rec['source_table'],
                    rec['target_database'], rec['target_table']
                ))

                column_lineage_records.append({
                    'query_id': str(query_id),
                    **rec
                })

            self.extraction_stats.record_success()
        else:
            # No lineage found is not a failure
            self.extraction_stats.record_success()

    except Exception as e:
        # Extract target table from query for context
        table_name = self._extract_target_table(query_text)
        error_type = type(e).__name__

        logger.warning(
            "Failed to extract lineage: query_id=%s, table=%s, error_type=%s, error=%s",
            query_id, table_name, error_type, str(e)[:200]
        )

        self.extraction_stats.record_failure(
            query_id=str(query_id),
            table_name=table_name,
            error_type=error_type,
            error_msg=str(e)
        )
        # Continue processing - don't stop on individual failures
```

Also update insert loops to use new counters:
- After table lineage insert success: `self.table_lineage_count += 1`
- After column lineage insert success: `self.column_lineage_count += 1`
  </action>
  <verify>
Run continue-on-failure behavior test:
```bash
cd /Users/Daniel.Tehan/Code/lineage/database && python -c "
from extract_dbql_lineage import DBQLLineageExtractor

# Create extractor with mock parser that fails on specific input
e = DBQLLineageExtractor()

class MockParser:
    default_database = 'test'
    def extract_column_lineage(self, sql, stmt_type=None):
        if 'INVALID' in sql:
            raise Exception('Parse error: unexpected token')
        return []

e.parser = MockParser()

# Simulate processing loop with failure
queries = [
    ('q1', 'Insert', 'INSERT INTO t1 SELECT * FROM t2', None, 'demo'),
    ('q2', 'Insert', 'INVALID SQL', None, 'demo'),
    ('q3', 'Insert', 'INSERT INTO t3 SELECT * FROM t4', None, 'demo'),
]

for qid, stype, sql, qtime, db in queries:
    try:
        if hasattr(e, 'parser') and e.parser:
            e.parser.extract_column_lineage(sql, stype)
            e.extraction_stats.record_success()
    except Exception as ex:
        e.extraction_stats.record_failure(qid, 'UNKNOWN', type(ex).__name__, str(ex))

# Verify continue-on-failure: all 3 processed, 1 failed, 2 succeeded
assert e.extraction_stats.processed == 3, f'Expected 3 processed, got {e.extraction_stats.processed}'
assert e.extraction_stats.failed == 1, f'Expected 1 failed, got {e.extraction_stats.failed}'
assert e.extraction_stats.succeeded == 2, f'Expected 2 succeeded, got {e.extraction_stats.succeeded}'
print('Continue-on-failure: PASSED')
"
```
Should print: "Continue-on-failure: PASSED"
  </verify>
  <done>
- Query processing continues after individual failures (verified by test)
- Parser existence verified with hasattr check before use
- Failures logged with query_id, table_name, error_type context
- Progress logging every 1000 queries
- Skip null query_text with record_skip()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add validate_dbql_data method for DBQL-04 data completeness</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Add the `validate_dbql_data` method to DBQLLineageExtractor class for DBQL-04 requirement:

```python
def validate_dbql_data(self, queries: List[Tuple]) -> bool:
    """
    Validate DBQL data completeness and report anomalies (DBQL-04).

    Returns:
        True if data is valid for processing (empty is valid)
    """
    if not queries:
        logger.warning("No queries found in DBQL for the specified time range")
        return True  # Empty is valid, just nothing to process

    total = len(queries)

    # Check for null query text
    null_count = sum(1 for q in queries if not q[2])  # query_text is index 2
    if null_count > 0:
        null_pct = 100 * null_count / total
        logger.warning(
            "DBQL data anomaly: %d of %d queries have NULL query_text (%.1f%%)",
            null_count, total, null_pct
        )

    # Check for very short queries (likely truncated)
    short_count = sum(1 for q in queries if q[2] and len(q[2]) < 20)
    if short_count > total * 0.1:  # More than 10%
        logger.warning(
            "DBQL data anomaly: %d queries have very short query_text (<20 chars)",
            short_count
        )

    # Report row count for visibility
    logger.info("DBQL data validated: %d queries to process", total)

    return True
```

Call this method in `extract_lineage()` AFTER fetching queries, BEFORE processing:
```python
# After: queries = self.fetch_queries(since)
# Add:
self.validate_dbql_data(queries)
```
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import DBQLLineageExtractor; e = DBQLLineageExtractor(); print('Has validate_dbql_data:', hasattr(e, 'validate_dbql_data')); result = e.validate_dbql_data([(1, 'Insert', 'SELECT * FROM t', None, 'db')]); print('Returns True for valid data:', result)"`
Should print both True values.
  </verify>
  <done>
- validate_dbql_data method exists
- Reports NULL query_text count and percentage
- Reports short query anomalies (>10% under 20 chars)
- Logs total row count for visibility
- Called in extract_lineage() before processing loop
  </done>
</task>

<task type="auto">
  <name>Task 3: Update print_summary with detailed success/failure/skip reporting</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Replace the `print_summary` method with enhanced version that reports extraction outcomes:

```python
def print_summary(self):
    """Print extraction summary with success/failure/skip breakdown."""
    print("\n" + "=" * 60)
    print("EXTRACTION SUMMARY")
    print("=" * 60)
    print(f"  Queries processed:     {self.extraction_stats.processed}")
    print(f"  Succeeded:             {self.extraction_stats.succeeded}")
    print(f"  Failed:                {self.extraction_stats.failed}")
    print(f"  Skipped:               {self.extraction_stats.skipped}")
    print(f"  Table lineage records: {self.table_lineage_count}")
    print(f"  Column lineage records:{self.column_lineage_count}")

    # Log summary for programmatic access
    logger.info("Extraction completed: %s", self.extraction_stats.summary())

    # Show failed query details in verbose mode
    if self.verbose and self.extraction_stats.errors:
        print("\n  Failed Query Details:")
        for i, err in enumerate(self.extraction_stats.errors[:10]):
            print(f"    {i+1}. Query {err['query_id']}: {err['error_type']} on {err['table_name']}")
        if len(self.extraction_stats.errors) > 10:
            print(f"    ... and {len(self.extraction_stats.errors) - 10} more")

    # Get totals from database
    if self.cursor:
        try:
            self.cursor.execute(f"SELECT COUNT(*) FROM {DB_NAME}.LIN_TABLE_LINEAGE")
            total_table = self.cursor.fetchone()[0]
            self.cursor.execute(f"SELECT COUNT(*) FROM {DB_NAME}.LIN_COLUMN_LINEAGE")
            total_column = self.cursor.fetchone()[0]
            print(f"\n  Total in LIN_TABLE_LINEAGE:  {total_table}")
            print(f"  Total in LIN_COLUMN_LINEAGE: {total_column}")
        except Exception:
            pass  # Ignore database errors in summary
```
  </action>
  <verify>
Test that print_summary can run and access all required attributes (including when cursor is None):
```bash
cd /Users/Daniel.Tehan/Code/lineage/database && python -c "
from extract_dbql_lineage import DBQLLineageExtractor, ExtractionStats

# Create extractor and set up test data
e = DBQLLineageExtractor(verbose=True)
e.extraction_stats = ExtractionStats()
e.extraction_stats.processed = 100
e.extraction_stats.succeeded = 95
e.extraction_stats.failed = 3
e.extraction_stats.skipped = 2
e.extraction_stats.errors = [{'query_id': '123', 'error_type': 'ParseError', 'table_name': 'test_tbl', 'error_message': 'test'}]
e.table_lineage_count = 50
e.column_lineage_count = 200
e.cursor = None  # Simulate no DB connection

# Run print_summary - should complete without error
e.print_summary()
print('print_summary: PASSED')
"
```
Should print the summary output and "print_summary: PASSED" without errors.
  </verify>
  <done>
- print_summary shows processed/succeeded/failed/skipped counts
- Verbose mode shows first 10 failed query details
- Summary logged via logger.info for programmatic access
- Table and column lineage counts displayed
- Handles cursor=None gracefully
  </done>
</task>

<task type="auto">
  <name>Task 4: Create comprehensive test suite for DBQL error handling</name>
  <files>database/test_dbql_error_handling.py</files>
  <action>
Create new test file `database/test_dbql_error_handling.py` with tests for all DBQL requirements:

```python
#!/usr/bin/env python3
"""
Tests for DBQL error handling in extract_dbql_lineage.py.

Tests verify:
- DBQL-01: Missing DBQL access provides clear fallback guidance
- DBQL-02: Malformed queries logged and skipped without stopping extraction
- DBQL-03: Error logs include query ID, table name, error type
- DBQL-04: Extraction validates data completeness and reports summary
- TEST-05: Tests verify DBQL error handling scenarios
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime

# Import the module under test
from extract_dbql_lineage import (
    DBQLLineageExtractor,
    ExtractionStats,
    configure_logging,
)


class TestExtractionStats:
    """Test the ExtractionStats dataclass."""

    def test_initial_counts_are_zero(self):
        """Stats start at zero."""
        stats = ExtractionStats()
        assert stats.processed == 0
        assert stats.succeeded == 0
        assert stats.failed == 0
        assert stats.skipped == 0
        assert len(stats.errors) == 0

    def test_record_success_increments_counters(self):
        """record_success increments processed and succeeded."""
        stats = ExtractionStats()
        stats.record_success()
        assert stats.processed == 1
        assert stats.succeeded == 1

    def test_record_failure_increments_counters_and_stores_error(self):
        """record_failure increments counters and stores error context."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="12345",
            table_name="demo_user.TEST_TABLE",
            error_type="ParseError",
            error_msg="Unexpected token"
        )
        assert stats.processed == 1
        assert stats.failed == 1
        assert len(stats.errors) == 1
        assert stats.errors[0]['query_id'] == "12345"
        assert stats.errors[0]['table_name'] == "demo_user.TEST_TABLE"
        assert stats.errors[0]['error_type'] == "ParseError"

    def test_record_failure_truncates_long_messages(self):
        """Long error messages are truncated to 200 chars."""
        stats = ExtractionStats()
        long_msg = "x" * 500
        stats.record_failure("1", "tbl", "Error", long_msg)
        assert len(stats.errors[0]['error_message']) == 200

    def test_record_failure_limits_stored_errors(self):
        """Errors list is limited to 1000 to prevent memory issues."""
        stats = ExtractionStats()
        for i in range(1100):
            stats.record_failure(str(i), "tbl", "Error", "msg")
        assert len(stats.errors) == 1000
        assert stats.failed == 1100  # Counter still accurate

    def test_record_skip_increments_counters(self):
        """record_skip increments processed and skipped."""
        stats = ExtractionStats()
        stats.record_skip("null query_text")
        assert stats.processed == 1
        assert stats.skipped == 1

    def test_summary_returns_formatted_string(self):
        """summary() returns human-readable counts."""
        stats = ExtractionStats()
        stats.succeeded = 100
        stats.failed = 5
        stats.skipped = 2
        summary = stats.summary()
        assert "100 succeeded" in summary
        assert "5 failed" in summary
        assert "2 skipped" in summary


class TestCheckDbqlAccess:
    """Test DBQL access checking with actionable error messages (DBQL-01)."""

    def test_access_granted_returns_true(self):
        """When DBQL access works, returns (True, success_message)."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()
        extractor.cursor.execute.return_value = None  # Success

        has_access, message = extractor.check_dbql_access()

        assert has_access is True
        assert "confirmed" in message.lower()

    def test_access_denied_returns_fallback_guidance(self):
        """DBQL-01: Missing access provides clear fallback guidance."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()

        # Simulate Teradata error 3523 (access denied)
        import teradatasql
        extractor.cursor.execute.side_effect = teradatasql.DatabaseError(
            "[Error 3523] User does not have SELECT access to DBC.DBQLogTbl"
        )

        has_access, message = extractor.check_dbql_access()

        assert has_access is False
        # Must include fallback command
        assert "populate_lineage.py --manual" in message
        # Must include grant instructions
        assert "GRANT SELECT" in message

    def test_other_database_error_returns_error_message(self):
        """Non-access errors return the error message."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.cursor = Mock()

        import teradatasql
        extractor.cursor.execute.side_effect = teradatasql.DatabaseError(
            "[Error 2580] Table not found"
        )

        has_access, message = extractor.check_dbql_access()

        assert has_access is False
        assert "2580" in message or "Table not found" in message


class TestContinueOnFailure:
    """Test that extraction continues after individual query failures (DBQL-02)."""

    def test_malformed_query_does_not_stop_extraction(self):
        """DBQL-02: Malformed queries logged and skipped without failing extraction."""
        extractor = DBQLLineageExtractor(verbose=True)

        # Mock parser to fail on specific query
        mock_parser = Mock()
        def parse_side_effect(sql, stmt_type=None):
            if "INVALID" in sql:
                raise Exception("Parse error: unexpected token")
            return []  # No lineage for valid queries (simplified)

        mock_parser.extract_column_lineage.side_effect = parse_side_effect
        extractor.parser = mock_parser

        # Process queries directly (bypassing fetch_queries)
        queries = [
            (1, 'Insert', 'INSERT INTO t1 SELECT * FROM t2', datetime.now(), 'demo_user'),
            (2, 'Insert', 'INVALID SQL {{{{', datetime.now(), 'demo_user'),  # Will fail
            (3, 'Insert', 'INSERT INTO t3 SELECT * FROM t4', datetime.now(), 'demo_user'),
        ]

        # Manually process queries to test continue-on-failure
        for query_id, stmt_type, query_text, query_time, default_db in queries:
            try:
                extractor.parser.extract_column_lineage(query_text, stmt_type)
                extractor.extraction_stats.record_success()
            except Exception as e:
                extractor.extraction_stats.record_failure(
                    str(query_id), "UNKNOWN", type(e).__name__, str(e)
                )

        # All 3 queries should be processed
        assert extractor.extraction_stats.processed == 3
        # 1 should have failed
        assert extractor.extraction_stats.failed == 1
        # 2 should have succeeded
        assert extractor.extraction_stats.succeeded == 2

    def test_extraction_completes_with_failures(self):
        """Extraction completes successfully even when individual queries fail."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.extraction_stats.record_success()
        extractor.extraction_stats.record_failure("1", "tbl", "ParseError", "error")
        extractor.extraction_stats.record_success()

        # Verify extraction can report final stats (not stopped by failure)
        summary = extractor.extraction_stats.summary()
        assert "2 succeeded" in summary
        assert "1 failed" in summary


class TestErrorLogging:
    """Test that error logs include required context (DBQL-03)."""

    def test_error_includes_query_id(self):
        """DBQL-03: Error context includes query_id."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="ABC123",
            table_name="test_table",
            error_type="ParseError",
            error_msg="test error"
        )
        assert stats.errors[0]['query_id'] == "ABC123"

    def test_error_includes_table_name(self):
        """DBQL-03: Error context includes table_name."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="123",
            table_name="demo_user.MY_TABLE",
            error_type="ParseError",
            error_msg="test error"
        )
        assert stats.errors[0]['table_name'] == "demo_user.MY_TABLE"

    def test_error_includes_error_type(self):
        """DBQL-03: Error context includes error_type."""
        stats = ExtractionStats()
        stats.record_failure(
            query_id="123",
            table_name="tbl",
            error_type="ValidationError",
            error_msg="test error"
        )
        assert stats.errors[0]['error_type'] == "ValidationError"


class TestExtractTargetTable:
    """Test the _extract_target_table helper method."""

    def test_extracts_insert_into_table(self):
        """Extracts table from INSERT INTO statement."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("INSERT INTO demo_user.MY_TABLE SELECT * FROM src")
        assert table == "demo_user.MY_TABLE"

    def test_extracts_merge_into_table(self):
        """Extracts table from MERGE INTO statement."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("MERGE INTO target_tbl USING src ON ...")
        assert table == "target_tbl"

    def test_returns_unknown_for_unmatched(self):
        """Returns UNKNOWN when pattern doesn't match."""
        extractor = DBQLLineageExtractor()
        table = extractor._extract_target_table("SELECT * FROM something")
        assert table == "UNKNOWN"

    def test_handles_null_query(self):
        """Returns UNKNOWN for null/empty query."""
        extractor = DBQLLineageExtractor()
        assert extractor._extract_target_table(None) == "UNKNOWN"
        assert extractor._extract_target_table("") == "UNKNOWN"


class TestDataValidation:
    """Test DBQL data completeness validation (DBQL-04)."""

    def test_validate_dbql_data_returns_true_for_valid_data(self):
        """validate_dbql_data returns True for valid query data."""
        extractor = DBQLLineageExtractor()
        queries = [
            (1, 'Insert', 'INSERT INTO t1 SELECT * FROM t2', None, 'db'),
            (2, 'Insert', 'INSERT INTO t2 SELECT * FROM t3', None, 'db'),
        ]
        result = extractor.validate_dbql_data(queries)
        assert result is True

    def test_validate_dbql_data_returns_true_for_empty(self):
        """validate_dbql_data returns True for empty list (nothing to process)."""
        extractor = DBQLLineageExtractor()
        result = extractor.validate_dbql_data([])
        assert result is True

    def test_validate_dbql_data_warns_on_null_query_text(self):
        """validate_dbql_data logs warning for NULL query_text."""
        extractor = DBQLLineageExtractor()
        queries = [
            (1, 'Insert', None, None, 'db'),  # NULL query_text
            (2, 'Insert', 'INSERT INTO t1 SELECT * FROM t2', None, 'db'),
        ]
        # Should complete without error and return True
        result = extractor.validate_dbql_data(queries)
        assert result is True


class TestSummaryReporting:
    """Test extraction summary reporting (DBQL-04)."""

    def test_summary_includes_all_counts(self):
        """DBQL-04: Summary includes success/failure/skip counts."""
        stats = ExtractionStats()
        stats.succeeded = 100
        stats.failed = 5
        stats.skipped = 2
        stats.processed = 107

        summary = stats.summary()

        assert "100" in summary  # succeeded
        assert "5" in summary    # failed
        assert "2" in summary    # skipped

    def test_print_summary_runs_without_error(self):
        """print_summary can run with mock data and no DB connection."""
        extractor = DBQLLineageExtractor(verbose=True)
        extractor.extraction_stats.processed = 10
        extractor.extraction_stats.succeeded = 8
        extractor.extraction_stats.failed = 2
        extractor.table_lineage_count = 5
        extractor.column_lineage_count = 20
        extractor.cursor = None  # No DB connection

        # Should not raise any exception
        extractor.print_summary()


class TestLoggingConfiguration:
    """Test logging configuration."""

    def test_configure_logging_returns_logger(self):
        """configure_logging returns a configured logger."""
        logger = configure_logging(verbose=False)
        assert logger.name == 'dbql_extractor'

    def test_verbose_sets_debug_level(self):
        """Verbose mode sets DEBUG level."""
        import logging
        logger = configure_logging(verbose=True)
        assert logger.level == logging.DEBUG

    def test_non_verbose_sets_info_level(self):
        """Non-verbose mode sets INFO level."""
        import logging
        # Clear handlers from previous test
        logger = logging.getLogger('dbql_extractor')
        logger.handlers = []
        logger = configure_logging(verbose=False)
        assert logger.level == logging.INFO


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -m pytest test_dbql_error_handling.py -v --tb=short 2>&1 | head -60`
All tests should pass.
  </verify>
  <done>
- test_dbql_error_handling.py created with comprehensive test coverage
- Tests cover DBQL-01 (access guidance), DBQL-02 (continue-on-failure), DBQL-03 (error context), DBQL-04 (summary + validation)
- Tests use pytest and mock patterns consistent with existing tests
- All tests pass
  </done>
</task>

</tasks>

<verification>
Run full test suite:

```bash
cd /Users/Daniel.Tehan/Code/lineage/database

# Run new DBQL error handling tests
python -m pytest test_dbql_error_handling.py -v

# Verify module still imports cleanly
python -c "import extract_dbql_lineage; print('Module imports OK')"

# Quick functional test of ExtractionStats
python -c "
from extract_dbql_lineage import ExtractionStats
s = ExtractionStats()
s.record_success()
s.record_failure('123', 'tbl', 'ParseError', 'test')
s.record_skip()
print('Stats:', s.summary())
assert s.processed == 3
assert s.succeeded == 1
assert s.failed == 1
assert s.skipped == 1
print('Functional test PASSED')
"
```

Expected: All tests pass, module imports cleanly, functional test passes.
</verification>

<success_criteria>
1. DBQL-01: check_dbql_access returns actionable guidance with "populate_lineage.py --manual"
2. DBQL-02: Query processing loop catches exceptions and continues via record_failure
3. DBQL-03: record_failure captures query_id, table_name, error_type
4. DBQL-04: validate_dbql_data checks data completeness; print_summary displays counts
5. TEST-05: All tests in test_dbql_error_handling.py pass
6. Parser existence verified with hasattr before use
7. Extraction completes successfully even when individual queries fail
8. Existing functionality preserved - no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-dbql-error-handling/05-02-SUMMARY.md`
</output>
