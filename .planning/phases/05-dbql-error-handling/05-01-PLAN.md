---
phase: 05-dbql-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/extract_dbql_lineage.py
autonomous: true

must_haves:
  truths:
    - "Extraction logs messages with timestamps and severity levels"
    - "Extraction reports success/failure/skip breakdown at completion"
    - "check_dbql_access returns actionable error message with fallback guidance"
  artifacts:
    - path: "database/extract_dbql_lineage.py"
      provides: "Logging infrastructure and ExtractionStats class"
      contains: "class ExtractionStats"
  key_links:
    - from: "DBQLLineageExtractor.__init__"
      to: "ExtractionStats"
      via: "self.extraction_stats = ExtractionStats()"
      pattern: "self\\.extraction_stats\\s*=\\s*ExtractionStats"
    - from: "configure_logging"
      to: "main()"
      via: "configure_logging called in main()"
      pattern: "configure_logging\\(.*verbose"
---

<objective>
Add logging infrastructure and structured statistics tracking to DBQL extraction script.

Purpose: Establish the foundation for proper error reporting and progress tracking in batch extraction.
Output: Enhanced `extract_dbql_lineage.py` with logging module and ExtractionStats class.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dbql-error-handling/05-RESEARCH.md

@database/extract_dbql_lineage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add logging infrastructure and wire into main()</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Add Python logging configuration at module level AND wire it into main():

1. Import `logging` and `sys` at top of file

2. Add module-level logger configuration function AFTER imports, BEFORE classes:
```python
def configure_logging(verbose: bool = False) -> logging.Logger:
    """Configure logging for DBQL extraction."""
    logger = logging.getLogger('dbql_extractor')

    # Set level based on verbose flag
    level = logging.DEBUG if verbose else logging.INFO
    logger.setLevel(level)

    # Console handler with appropriate format
    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(level)

    # Format: timestamp - level - message
    formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)

    # Avoid duplicate handlers on repeated calls
    if not logger.handlers:
        logger.addHandler(handler)

    return logger

# Module-level logger (configured in main())
logger = logging.getLogger('dbql_extractor')
```

3. **CRITICAL WIRING:** In `main()`, add logger configuration BEFORE creating the extractor:
```python
def main():
    # ... argument parsing ...

    # Configure logging based on verbose flag
    configure_logging(verbose=args.verbose)

    # ... rest of main ...
```

This ensures the logger is active BEFORE any extraction work begins.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import configure_logging, logger; l = configure_logging(True); print('Logger configured:', l.name); print('Has handler:', len(l.handlers) > 0)"`
Should print: "Logger configured: dbql_extractor" and "Has handler: True"
  </verify>
  <done>
- `configure_logging()` function exists and returns configured logger
- Module-level `logger` variable exists
- Function handles verbose flag for DEBUG vs INFO level
- main() calls configure_logging() before creating extractor
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ExtractionStats class and wire into DBQLLineageExtractor</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Add ExtractionStats dataclass AFTER the configure_logging function, BEFORE DBQLLineageExtractor class:

```python
@dataclass
class ExtractionStats:
    """Track extraction outcomes for summary reporting."""
    processed: int = 0
    succeeded: int = 0
    failed: int = 0
    skipped: int = 0
    errors: List[Dict] = field(default_factory=list)

    def record_success(self):
        """Record a successfully processed query."""
        self.processed += 1
        self.succeeded += 1

    def record_failure(self, query_id: str, table_name: str, error_type: str, error_msg: str):
        """Record a failed query with error context."""
        self.processed += 1
        self.failed += 1
        # Limit stored errors to prevent memory issues
        if len(self.errors) < 1000:
            self.errors.append({
                'query_id': query_id,
                'table_name': table_name,
                'error_type': error_type,
                'error_message': error_msg[:200]  # Truncate long messages
            })

    def record_skip(self, reason: str = ""):
        """Record a skipped query."""
        self.processed += 1
        self.skipped += 1

    def summary(self) -> str:
        """Return summary string for logging."""
        return f"{self.succeeded} succeeded, {self.failed} failed, {self.skipped} skipped"
```

Also add these imports at the top of the file if not present:
- `from dataclasses import dataclass, field`

**CRITICAL WIRING:** In `DBQLLineageExtractor.__init__` (around line 67-72), add initialization of ExtractionStats:
```python
# In __init__, after self.verbose and before self.stats dict:
self.extraction_stats = ExtractionStats()
```

This wires the new class to the extractor. The existing `self.stats` dict remains for backward compatibility until Plan 02 replaces it.
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import ExtractionStats, DBQLLineageExtractor; s = ExtractionStats(); s.record_success(); s.record_failure('123', 'tbl', 'ParseError', 'msg'); s.record_skip(); print(s.summary()); e = DBQLLineageExtractor(); print('Wired:', hasattr(e, 'extraction_stats') and isinstance(e.extraction_stats, ExtractionStats))"`
Should print: "1 succeeded, 1 failed, 1 skipped" and "Wired: True"
  </verify>
  <done>
- ExtractionStats class exists with dataclass decorator
- record_success(), record_failure(), record_skip(), summary() methods work
- Errors list limited to 1000 entries to prevent memory issues
- Error messages truncated to 200 chars
- DBQLLineageExtractor.__init__ initializes self.extraction_stats = ExtractionStats()
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance check_dbql_access with actionable error message</name>
  <files>database/extract_dbql_lineage.py</files>
  <action>
Update the `check_dbql_access` method in DBQLLineageExtractor class to return a tuple with actionable guidance:

1. Change method signature to return `Tuple[bool, str]`:
```python
def check_dbql_access(self) -> Tuple[bool, str]:
```

2. Add `Tuple` to imports from typing if not present

3. Replace the method body with:
```python
def check_dbql_access(self) -> Tuple[bool, str]:
    """
    Verify access to DBQL tables.

    Returns:
        Tuple of (has_access: bool, message: str with guidance if no access)
    """
    logger.info("Checking DBQL access...")
    try:
        self.cursor.execute("SELECT TOP 1 1 FROM DBC.DBQLogTbl")
        logger.info("DBQL access confirmed")
        return True, "DBQL access confirmed"
    except teradatasql.DatabaseError as e:
        error_str = str(e)
        if "3523" in error_str or "access" in error_str.lower():
            message = (
                "No access to DBQL tables.\n\n"
                "This may indicate:\n"
                "  1. DBQL logging is not enabled on this Teradata system\n"
                "  2. Your user lacks SELECT privileges on DBC.DBQLogTbl\n"
                "  3. Your Teradata environment doesn't support DBQL\n\n"
                "Fallback: Use manual lineage mappings instead:\n"
                "  python populate_lineage.py --manual\n\n"
                "To enable DBQL access, contact your DBA to grant:\n"
                "  GRANT SELECT ON DBC.DBQLogTbl TO your_user;\n"
                "  GRANT SELECT ON DBC.DBQLSQLTbl TO your_user;"
            )
            logger.warning("No DBQL access: %s", e)
            return False, message
        else:
            logger.error("DBQL check failed: %s", e)
            return False, f"DBQL check failed: {e}"
```

4. Update the caller in `main()` to handle the new return type:
```python
# Old: if not extractor.check_dbql_access():
# New:
has_access, access_message = extractor.check_dbql_access()
if not has_access:
    print(access_message)
    return 1
```
  </action>
  <verify>
Run: `cd /Users/Daniel.Tehan/Code/lineage/database && python -c "from extract_dbql_lineage import DBQLLineageExtractor; print('check_dbql_access returns tuple:', 'Tuple' in str(DBQLLineageExtractor.check_dbql_access.__annotations__.get('return', '')))"`
Verify the method signature includes `-> Tuple[bool, str]` by checking the source.
  </verify>
  <done>
- check_dbql_access returns Tuple[bool, str]
- Error message includes "populate_lineage.py --manual" fallback guidance
- Error message includes GRANT statement examples
- Logger used for info/warning/error messages
- main() updated to handle tuple return
  </done>
</task>

</tasks>

<verification>
Run all verification commands:

```bash
cd /Users/Daniel.Tehan/Code/lineage/database

# Test 1: Logger configuration
python -c "from extract_dbql_lineage import configure_logging, logger; l = configure_logging(True); print('OK: Logger')"

# Test 2: ExtractionStats class
python -c "from extract_dbql_lineage import ExtractionStats; s = ExtractionStats(); s.record_success(); s.record_failure('123', 'tbl', 'ParseError', 'msg'); s.record_skip(); print('OK: Stats -', s.summary())"

# Test 3: Module imports cleanly
python -c "import extract_dbql_lineage; print('OK: Module imports')"
```

All should print OK messages without errors.
</verification>

<success_criteria>
1. `extract_dbql_lineage.py` imports `logging` and configures module-level logger
2. main() calls configure_logging() to wire the logger before extraction
3. `ExtractionStats` dataclass exists with record_success/failure/skip/summary methods
4. `check_dbql_access` returns tuple with actionable guidance message
5. Module imports without errors
6. No existing functionality broken (existing print statements still work)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dbql-error-handling/05-01-SUMMARY.md`
</output>
