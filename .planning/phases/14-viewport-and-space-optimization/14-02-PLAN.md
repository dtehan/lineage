---
phase: 14-viewport-and-space-optimization
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
  - lineage-ui/src/components/domain/LineageGraph/DatabaseLineageGraph.tsx
  - lineage-ui/src/components/domain/LineageGraph/AllDatabasesLineageGraph.tsx
autonomous: true

must_haves:
  truths:
    - "Graph initial viewport positioned at top-left showing root nodes"
    - "Small graphs zoom to readable text size"
    - "Large graphs fit more nodes on screen with smaller zoom"
    - "User can manually adjust zoom after initial fit"
  artifacts:
    - path: "lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx"
      provides: "Smart viewport positioning with size-aware zoom"
      contains: "setViewport|fitView"
    - path: "lineage-ui/src/components/domain/LineageGraph/DatabaseLineageGraph.tsx"
      provides: "Consistent viewport behavior"
      contains: "setViewport|fitView"
    - path: "lineage-ui/src/components/domain/LineageGraph/AllDatabasesLineageGraph.tsx"
      provides: "Consistent viewport behavior"
      contains: "setViewport|fitView"
  key_links:
    - from: "LineageGraph.tsx"
      to: "useReactFlow"
      via: "setViewport or fitView with minZoom/maxZoom"
      pattern: "(setViewport|fitView).*\\{"
---

<objective>
Implement smart viewport positioning that starts at top-left and applies size-aware zoom based on node count.

Purpose: Users see root/source nodes immediately without scrolling, and zoom level is optimized for the graph size.
Output: Updated LineageGraph components with custom viewport initialization.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-viewport-and-space-optimization/14-01-SUMMARY.md
@lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx
@lineage-ui/src/components/domain/LineageGraph/DatabaseLineageGraph.tsx
@lineage-ui/src/components/domain/LineageGraph/AllDatabasesLineageGraph.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSmartViewport hook for size-aware positioning</name>
  <files>lineage-ui/src/components/domain/LineageGraph/hooks/useSmartViewport.ts</files>
  <action>
Create a new hook `useSmartViewport` that calculates optimal initial viewport based on graph size:

```typescript
import { useCallback } from 'react';
import { useReactFlow, type Node } from '@xyflow/react';

interface SmartViewportOptions {
  /** Padding around the graph (0-1, where 0.1 = 10%) */
  padding?: number;
  /** Small graph threshold (nodes <= this zoom to readable size) */
  smallGraphThreshold?: number;
  /** Large graph threshold (nodes >= this use smaller zoom) */
  largeGraphThreshold?: number;
  /** Max zoom for small graphs */
  smallGraphZoom?: number;
  /** Max zoom for large graphs */
  largeGraphZoom?: number;
}

const DEFAULT_OPTIONS: Required<SmartViewportOptions> = {
  padding: 0.1,
  smallGraphThreshold: 20,
  largeGraphThreshold: 50,
  smallGraphZoom: 1.0,
  largeGraphZoom: 0.5,
};

/**
 * Hook that provides smart viewport positioning based on graph size.
 * - Positions viewport at top-left to show root/source nodes
 * - Applies size-aware zoom (larger zoom for small graphs, smaller for large)
 */
export function useSmartViewport(options: SmartViewportOptions = {}) {
  const { fitView, setViewport, getNodes } = useReactFlow();
  const opts = { ...DEFAULT_OPTIONS, ...options };

  const applySmartViewport = useCallback((nodes: Node[]) => {
    if (nodes.length === 0) return;

    const nodeCount = nodes.length;

    // Calculate zoom based on node count
    let targetZoom: number;
    if (nodeCount <= opts.smallGraphThreshold) {
      // Small graphs: zoom to readable size (up to smallGraphZoom)
      targetZoom = opts.smallGraphZoom;
    } else if (nodeCount >= opts.largeGraphThreshold) {
      // Large graphs: fit more nodes with smaller zoom
      targetZoom = opts.largeGraphZoom;
    } else {
      // Medium graphs: interpolate between thresholds
      const ratio = (nodeCount - opts.smallGraphThreshold) /
                    (opts.largeGraphThreshold - opts.smallGraphThreshold);
      targetZoom = opts.smallGraphZoom - ratio * (opts.smallGraphZoom - opts.largeGraphZoom);
    }

    // Find the bounds of all nodes
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;

    for (const node of nodes) {
      const x = node.position.x;
      const y = node.position.y;
      const width = node.measured?.width ?? node.width ?? 280;
      const height = node.measured?.height ?? node.height ?? 100;

      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + width);
      maxY = Math.max(maxY, y + height);
    }

    // Add padding
    const paddingX = (maxX - minX) * opts.padding;
    const paddingY = (maxY - minY) * opts.padding;

    // Position viewport at top-left of graph (with small offset for padding)
    // The viewport x/y are in screen coordinates, negative values shift the graph right/down
    setViewport({
      x: -minX * targetZoom + paddingX,
      y: -minY * targetZoom + paddingY,
      zoom: targetZoom,
    });
  }, [fitView, setViewport, opts]);

  return { applySmartViewport };
}
```

Key behaviors:
- Top-left positioning: Sets viewport so minX/minY of graph is at top-left with padding
- Size-aware zoom:
  - Small graphs (<=20 nodes): zoom=1.0 for readable text
  - Large graphs (>=50 nodes): zoom=0.5 to fit more nodes
  - Medium graphs: linear interpolation between thresholds
  </action>
  <verify>
Run TypeScript check:
```bash
cd lineage-ui && npx tsc --noEmit
```
No errors for the new hook file.
  </verify>
  <done>
- useSmartViewport hook created
- TypeScript compiles without errors
- Hook exports applySmartViewport function
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate smart viewport in LineageGraph components</name>
  <files>lineage-ui/src/components/domain/LineageGraph/LineageGraph.tsx, lineage-ui/src/components/domain/LineageGraph/DatabaseLineageGraph.tsx, lineage-ui/src/components/domain/LineageGraph/AllDatabasesLineageGraph.tsx</files>
  <action>
Update all three LineageGraph components to use smart viewport positioning:

**LineageGraph.tsx changes:**

1. Import the new hook:
```typescript
import { useSmartViewport } from './hooks/useSmartViewport';
```

2. Add the hook in LineageGraphInner (after useLineageExport):
```typescript
const { applySmartViewport } = useSmartViewport();
```

3. Remove the `fitView` prop from ReactFlow (line ~385):
```typescript
// Change from:
fitView
fitViewOptions={{ padding: 0.2 }}

// To: (remove these two lines entirely, we'll use our hook instead)
```

4. Add an onInit or useEffect to apply smart viewport after nodes are set:
After the existing useEffect that calls layoutGraph (around line 133-154), add:
```typescript
// Apply smart viewport after layout completes
useEffect(() => {
  if (nodes.length > 0) {
    // Small delay to ensure React Flow has measured node dimensions
    const timeoutId = setTimeout(() => {
      applySmartViewport(nodes);
    }, 50);
    return () => clearTimeout(timeoutId);
  }
}, [nodes, applySmartViewport]);
```

5. Update handleFitView to still work (user-triggered fit view):
```typescript
const handleFitView = useCallback(() => {
  // When user clicks fit view, use standard fitView behavior (centered)
  reactFlowInstance.fitView({ padding: 0.2 });
}, [reactFlowInstance]);
```

**DatabaseLineageGraph.tsx and AllDatabasesLineageGraph.tsx changes:**
Apply the same pattern:
1. Import useSmartViewport
2. Call the hook
3. Remove fitView/fitViewOptions props from ReactFlow
4. Add useEffect to apply smart viewport after nodes change
5. Keep handleFitView for manual centering

Note: These components have similar structure. The key difference is AllDatabasesLineageGraph uses minZoom={0.05} instead of 0.1, so keep that lower minZoom.
  </action>
  <verify>
Run TypeScript check and tests:
```bash
cd lineage-ui && npx tsc --noEmit && npm test -- LineageGraph
```
  </verify>
  <done>
- All three LineageGraph components use useSmartViewport
- fitView prop removed from ReactFlow elements
- useEffect applies smart viewport after layout
- TypeScript compiles
- Existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Export hook from hooks index and add unit tests</name>
  <files>lineage-ui/src/components/domain/LineageGraph/hooks/index.ts, lineage-ui/src/components/domain/LineageGraph/hooks/useSmartViewport.test.ts</files>
  <action>
1. Add export to hooks/index.ts:
```typescript
export { useSmartViewport } from './useSmartViewport';
```

2. Create useSmartViewport.test.ts with tests:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook } from '@testing-library/react';
import { ReactFlowProvider } from '@xyflow/react';
import { useSmartViewport } from './useSmartViewport';

// Mock useReactFlow
const mockSetViewport = vi.fn();
const mockFitView = vi.fn();
const mockGetNodes = vi.fn();

vi.mock('@xyflow/react', async () => {
  const actual = await vi.importActual('@xyflow/react');
  return {
    ...actual,
    useReactFlow: () => ({
      setViewport: mockSetViewport,
      fitView: mockFitView,
      getNodes: mockGetNodes,
    }),
  };
});

describe('useSmartViewport', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <ReactFlowProvider>{children}</ReactFlowProvider>
  );

  it('returns applySmartViewport function', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    expect(typeof result.current.applySmartViewport).toBe('function');
  });

  it('does not set viewport for empty nodes', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    result.current.applySmartViewport([]);
    expect(mockSetViewport).not.toHaveBeenCalled();
  });

  it('sets zoom to 1.0 for small graphs (<=20 nodes)', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    const smallGraph = Array.from({ length: 5 }, (_, i) => ({
      id: `node-${i}`,
      position: { x: i * 100, y: 0 },
      data: {},
    }));

    result.current.applySmartViewport(smallGraph);

    expect(mockSetViewport).toHaveBeenCalledWith(
      expect.objectContaining({ zoom: 1.0 })
    );
  });

  it('sets zoom to 0.5 for large graphs (>=50 nodes)', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    const largeGraph = Array.from({ length: 60 }, (_, i) => ({
      id: `node-${i}`,
      position: { x: i * 100, y: Math.floor(i / 10) * 100 },
      data: {},
    }));

    result.current.applySmartViewport(largeGraph);

    expect(mockSetViewport).toHaveBeenCalledWith(
      expect.objectContaining({ zoom: 0.5 })
    );
  });

  it('interpolates zoom for medium graphs', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    // 35 nodes is midway between 20 and 50
    const mediumGraph = Array.from({ length: 35 }, (_, i) => ({
      id: `node-${i}`,
      position: { x: i * 100, y: 0 },
      data: {},
    }));

    result.current.applySmartViewport(mediumGraph);

    const call = mockSetViewport.mock.calls[0][0];
    // Should be between 0.5 and 1.0 (approximately 0.75 for midpoint)
    expect(call.zoom).toBeGreaterThan(0.5);
    expect(call.zoom).toBeLessThan(1.0);
  });

  it('positions viewport at top-left of graph', () => {
    const { result } = renderHook(() => useSmartViewport(), { wrapper });
    const nodes = [
      { id: 'node-1', position: { x: 100, y: 50 }, data: {} },
      { id: 'node-2', position: { x: 300, y: 150 }, data: {} },
    ];

    result.current.applySmartViewport(nodes);

    const call = mockSetViewport.mock.calls[0][0];
    // x should be negative (shifts graph right so minX=100 is near left edge)
    // y should be negative (shifts graph down so minY=50 is near top edge)
    expect(call.x).toBeDefined();
    expect(call.y).toBeDefined();
  });

  it('respects custom options', () => {
    const { result } = renderHook(
      () => useSmartViewport({
        smallGraphThreshold: 10,
        smallGraphZoom: 1.5
      }),
      { wrapper }
    );

    const smallGraph = Array.from({ length: 5 }, (_, i) => ({
      id: `node-${i}`,
      position: { x: i * 100, y: 0 },
      data: {},
    }));

    result.current.applySmartViewport(smallGraph);

    expect(mockSetViewport).toHaveBeenCalledWith(
      expect.objectContaining({ zoom: 1.5 })
    );
  });
});
```
  </action>
  <verify>
Run the new tests:
```bash
cd lineage-ui && npm test -- useSmartViewport
```
All tests should pass.
  </verify>
  <done>
- Hook exported from hooks/index.ts
- Unit tests created and passing
- Tests cover: empty nodes, small/medium/large graphs, top-left positioning, custom options
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd lineage-ui && npx tsc --noEmit`
2. New hook tests pass: `cd lineage-ui && npm test -- useSmartViewport`
3. LineageGraph tests pass: `cd lineage-ui && npm test -- LineageGraph`
4. Full test suite passes: `cd lineage-ui && npm test`
5. Visual verification:
   - Small graph: Zoom level ~1.0, graph starts at top-left
   - Large graph: Zoom level ~0.5, more nodes visible, starts at top-left
   - User can still manually zoom/pan after initial load
   - Fit View button still centers the graph
</verification>

<success_criteria>
- Graph initial viewport starts at top-left showing root/source nodes
- Small graphs (<=20 nodes) zoom to 1.0 for readable text
- Large graphs (>=50 nodes) zoom to 0.5 to fit more nodes
- Medium graphs have interpolated zoom between 0.5 and 1.0
- User can manually adjust zoom/pan after initial fit
- Fit View toolbar button still centers graph as before
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-viewport-and-space-optimization/14-02-SUMMARY.md`
</output>
