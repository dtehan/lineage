---
phase: 29-cache-keys-ttl-full-coverage
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
  - lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
  - lineage-api/cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "All 8 endpoint-backing repository methods use cache-aside with the new key format"
    - "Each cached method uses its own TTL type (lineage, asset, search, statistics, ddl)"
    - "Constructor accepts CacheTTLConfig instead of single int TTL"
    - "main.go passes CacheTTLConfig from config to the decorator constructor"
    - "Existing 14 tests updated to use CacheTTLConfig and new key format, and still pass"
    - "New tests cover cache hit/miss for newly cached methods (ListNamespaces, GetNamespace, ListDatasets, SearchDatasets, ListFields, GetDatasetStatistics, GetDatasetDDL)"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      provides: "Cache-aside overrides for all 8 endpoint-backing methods with per-type TTL"
      contains: "CacheTTLConfig"
    - path: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go"
      provides: "Tests for all cached methods including hit, miss, delegation, error handling"
      min_lines: 500
    - path: "lineage-api/cmd/server/main.go"
      provides: "Wiring of CacheTTLConfig from config to CachedOpenLineageRepository"
      contains: "cfg.CacheTTL"
  key_links:
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      to: "lineage-api/internal/adapter/outbound/redis/cache_keys.go"
      via: "imports key builder functions"
      pattern: "LineageGraphKey|DatasetKey|NamespacesKey"
    - from: "lineage-api/cmd/server/main.go"
      to: "lineage-api/internal/infrastructure/config/config.go"
      via: "reads CacheTTL from config"
      pattern: "cfg\\.CacheTTL"
    - from: "lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go"
      to: "lineage-api/internal/infrastructure/config/config.go"
      via: "accepts CacheTTLConfig struct"
      pattern: "config\\.CacheTTLConfig"
---

<objective>
Refactor CachedOpenLineageRepository to use centralized key builders and per-type TTL config, then add cache-aside overrides for all remaining read endpoints.

Purpose: Achieve full cache coverage across all v2 API read endpoints (KEY-01 through KEY-05) -- 8 methods total use cache-aside with deterministic keys and configurable per-data-type TTLs.

Output: Refactored decorator with 8 cached methods (was 2), updated tests, updated main.go wiring.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-cache-keys-ttl--full-coverage---deterministic-key-generation-configurable-ttls-and-caching-across-all-read-endpoints/29-RESEARCH.md
@.planning/phases/29-cache-keys-ttl--full-coverage---deterministic-key-generation-configurable-ttls-and-caching-across-all-read-endpoints/29-01-SUMMARY.md
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
@lineage-api/internal/adapter/outbound/redis/cache_keys.go
@lineage-api/internal/infrastructure/config/config.go
@lineage-api/internal/domain/repository.go
@lineage-api/internal/domain/mocks/repositories.go
@lineage-api/cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor decorator to use CacheTTLConfig and key builders, add all cached methods</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
  </files>
  <action>
Refactor `cached_openlineage_repo.go`:

**1. Change the struct to use CacheTTLConfig:**

Replace the `ttl int` field with `ttls config.CacheTTLConfig`. Add import for `"github.com/lineage-api/internal/infrastructure/config"`.

```go
type CachedOpenLineageRepository struct {
    domain.OpenLineageRepository
    cache domain.CacheRepository
    ttls  config.CacheTTLConfig
}

func NewCachedOpenLineageRepository(
    inner domain.OpenLineageRepository,
    cache domain.CacheRepository,
    ttls config.CacheTTLConfig,
) *CachedOpenLineageRepository {
    return &CachedOpenLineageRepository{
        OpenLineageRepository: inner,
        cache:                 cache,
        ttls:                  ttls,
    }
}
```

**2. Update existing GetColumnLineageGraph:**
- Replace `fmt.Sprintf("ol:lineage:graph:%s:%s:%s", ...)` with `LineageGraphKey(datasetID, fieldName, direction)`
- Replace `r.ttl` with `r.ttls.LineageTTL`
- Remove `"fmt"` import if no longer needed

**3. Update existing GetDataset:**
- Replace `fmt.Sprintf("ol:dataset:%s", datasetID)` with `DatasetKey(datasetID)`
- Replace `r.ttl` with `r.ttls.AssetTTL`

**4. Add 6 new cache-aside method overrides.** Each follows the EXACT same pattern as the existing two (check cache -> miss -> inner -> populate -> return). The only variations are: key builder function, TTL type, return type, and whether the method returns a pointer or a slice.

**For pointer-returning methods (GetNamespace, GetDatasetStatistics, GetDatasetDDL):**
Use the same nil-check pattern as GetDataset. Do NOT cache nil results.

```go
func (r *CachedOpenLineageRepository) GetNamespace(ctx context.Context, namespaceID string) (*domain.OpenLineageNamespace, error) {
    key := NamespaceKey(namespaceID)
    var cached domain.OpenLineageNamespace
    if err := r.cache.Get(ctx, key, &cached); err == nil {
        slog.DebugContext(ctx, "cache hit", "key", key)
        return &cached, nil
    }
    slog.DebugContext(ctx, "cache miss", "key", key)
    result, err := r.OpenLineageRepository.GetNamespace(ctx, namespaceID)
    if err != nil { return nil, err }
    if result == nil { return nil, nil }
    if setErr := r.cache.Set(ctx, key, result, r.ttls.AssetTTL); setErr != nil {
        slog.WarnContext(ctx, "cache set failed", "key", key, "error", setErr)
    } else {
        slog.DebugContext(ctx, "cache populated", "key", key, "ttl", r.ttls.AssetTTL)
    }
    return result, nil
}
```

Apply the same pattern for `GetDatasetStatistics` (key: `DatasetStatisticsKey`, TTL: `r.ttls.StatisticsTTL`) and `GetDatasetDDL` (key: `DatasetDDLKey`, TTL: `r.ttls.DDLTTL`).

**For slice-returning methods (ListNamespaces, ListFields, SearchDatasets):**
Cache non-nil slices. nil slices are not cached (consistent with existing pattern).

```go
func (r *CachedOpenLineageRepository) ListNamespaces(ctx context.Context) ([]domain.OpenLineageNamespace, error) {
    key := NamespacesKey()
    var cached []domain.OpenLineageNamespace
    if err := r.cache.Get(ctx, key, &cached); err == nil {
        slog.DebugContext(ctx, "cache hit", "key", key)
        return cached, nil
    }
    slog.DebugContext(ctx, "cache miss", "key", key)
    result, err := r.OpenLineageRepository.ListNamespaces(ctx)
    if err != nil { return nil, err }
    if result == nil { return nil, nil }
    if setErr := r.cache.Set(ctx, key, result, r.ttls.AssetTTL); setErr != nil {
        slog.WarnContext(ctx, "cache set failed", "key", key, "error", setErr)
    } else {
        slog.DebugContext(ctx, "cache populated", "key", key, "ttl", r.ttls.AssetTTL)
    }
    return result, nil
}
```

Apply the same pattern for:
- `ListFields` (key: `FieldsKey(datasetID)`, TTL: `r.ttls.AssetTTL`)
- `SearchDatasets` (key: `DatasetSearchKey(query, limit)`, TTL: `r.ttls.SearchTTL`)

**For ListDatasets (returns slice + int + error):**
This is a special case -- it returns `([]OpenLineageDataset, int, error)`. Cache a wrapper struct:

```go
// listDatasetsResult is an internal type for caching ListDatasets responses.
type listDatasetsResult struct {
    Datasets []domain.OpenLineageDataset `json:"datasets"`
    Total    int                          `json:"total"`
}

func (r *CachedOpenLineageRepository) ListDatasets(ctx context.Context, namespaceID string, limit, offset int) ([]domain.OpenLineageDataset, int, error) {
    key := DatasetsKey(namespaceID, limit, offset)
    var cached listDatasetsResult
    if err := r.cache.Get(ctx, key, &cached); err == nil {
        slog.DebugContext(ctx, "cache hit", "key", key)
        return cached.Datasets, cached.Total, nil
    }
    slog.DebugContext(ctx, "cache miss", "key", key)
    datasets, total, err := r.OpenLineageRepository.ListDatasets(ctx, namespaceID, limit, offset)
    if err != nil { return nil, 0, err }
    if datasets == nil { return nil, 0, nil }
    wrapper := listDatasetsResult{Datasets: datasets, Total: total}
    if setErr := r.cache.Set(ctx, key, wrapper, r.ttls.AssetTTL); setErr != nil {
        slog.WarnContext(ctx, "cache set failed", "key", key, "error", setErr)
    } else {
        slog.DebugContext(ctx, "cache populated", "key", key, "ttl", r.ttls.AssetTTL)
    }
    return datasets, total, nil
}
```

Remove `"fmt"` from imports if it is no longer used (all key building now uses cache_keys.go functions).

**TTL mapping summary:**
| Method | Key Builder | TTL |
|--------|-------------|-----|
| GetColumnLineageGraph | LineageGraphKey | LineageTTL |
| GetDataset | DatasetKey | AssetTTL |
| ListNamespaces | NamespacesKey | AssetTTL |
| GetNamespace | NamespaceKey | AssetTTL |
| ListDatasets | DatasetsKey | AssetTTL |
| SearchDatasets | DatasetSearchKey | SearchTTL |
| ListFields | FieldsKey | AssetTTL |
| GetDatasetStatistics | DatasetStatisticsKey | StatisticsTTL |
| GetDatasetDDL | DatasetDDLKey | DDLTTL |

**Methods that remain delegated (NOT cached):** GetNamespaceByURI, GetField, GetJob, ListJobs, GetRun, ListRuns, GetColumnLineage -- these are NOT exposed as endpoints.
  </action>
  <verify>
```bash
cd lineage-api && go build ./internal/adapter/outbound/redis/
```
  </verify>
  <done>
- CachedOpenLineageRepository uses CacheTTLConfig instead of single int TTL
- 8 methods have cache-aside overrides using centralized key builders
- Each method uses the correct TTL type (lineage, asset, search, statistics, ddl)
- ListDatasets uses wrapper struct for multi-return caching
- 7 methods remain delegated via embedding (not exposed as endpoints)
- Package compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests and wire CacheTTLConfig in main.go</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo_test.go
    lineage-api/cmd/server/main.go
  </files>
  <action>
**Update tests in `cached_openlineage_repo_test.go`:**

1. **Update `newTestCachedRepo()` helper:** Change from `NewCachedOpenLineageRepository(mockInner, mockCache, 300)` to:
```go
func newTestCachedRepo() (*CachedOpenLineageRepository, *mocks.MockOpenLineageRepository, *mocks.MockCacheRepository) {
    mockInner := mocks.NewMockOpenLineageRepository()
    mockCache := mocks.NewMockCacheRepository()
    ttls := config.CacheTTLConfig{
        LineageTTL:    300,
        AssetTTL:      300,
        StatisticsTTL: 300,
        DDLTTL:        300,
        SearchTTL:     300,
    }
    repo := NewCachedOpenLineageRepository(mockInner, mockCache, ttls)
    return repo, mockInner, mockCache
}
```
Add import for `"github.com/lineage-api/internal/infrastructure/config"`.

2. **Update key assertions in existing tests:** The key format changed:
   - `"ol:lineage:graph:42:customer_id:both"` -> `"ol:lineage:graph:42|customer_id|both"` (pipe delimiters)
   - `"ol:lineage:graph:42:customer_id:upstream"` -> `"ol:lineage:graph:42|customer_id|upstream"`
   - `"ol:lineage:graph:42:customer_id:downstream"` -> `"ol:lineage:graph:42|customer_id|downstream"`
   - `"ol:dataset:42"` -> `"ol:dataset:get:42"` (added `:get:` operation segment)

   Update ALL assertions in existing tests that check cache key strings. Also update the `mockCache.Data` pre-population keys in cache hit tests (e.g., `TestCachedGetColumnLineageGraph_CacheHit_SkipsInner` and `TestCachedGetDataset_CacheHit_SkipsInner`).

3. **Add new tests for newly cached methods.** For each newly cached method, add at minimum a cache miss + populate test and a cache hit test. Follow the existing test patterns exactly.

   Required new tests (at minimum):
   - `TestCachedListNamespaces_CacheMiss_PopulatesCache` -- calls ListNamespaces, verifies cache Get + Set called with "ol:namespace:list"
   - `TestCachedListNamespaces_CacheHit_SkipsInner` -- pre-populate cache, verify inner not called
   - `TestCachedGetNamespace_CacheMiss_PopulatesCache` -- verifies key "ol:namespace:get:1"
   - `TestCachedGetNamespace_CacheHit_SkipsInner`
   - `TestCachedListDatasets_CacheMiss_PopulatesCache` -- verifies key and total preserved through cache
   - `TestCachedListDatasets_CacheHit_SkipsInner` -- verifies total returned correctly from cache
   - `TestCachedSearchDatasets_CacheMiss_PopulatesCache` -- verifies case normalization in key
   - `TestCachedListFields_CacheMiss_PopulatesCache`
   - `TestCachedGetDatasetStatistics_CacheMiss_PopulatesCache`
   - `TestCachedGetDatasetStatistics_NilResult_NotCached`
   - `TestCachedGetDatasetDDL_CacheMiss_PopulatesCache`

4. **Update the delegation test** (`TestCachedRepo_UncachedMethods_DelegateToInner`): The methods it currently tests (ListNamespaces, ListDatasets, SearchDatasets) are NOW cached. Update this test to verify delegation of methods that are still uncached: `GetNamespaceByURI`, `GetField`, `GetJob`, `ListJobs`, `GetRun`, `ListRuns`. Alternatively, rename the test and verify that the old "uncached" methods now DO interact with cache. Choose the approach that best validates the new behavior -- the important thing is that the test still passes and validates something meaningful.

**Update `main.go`:**

Replace the hardcoded TTL:
```go
// BEFORE:
cachedOLRepo := redisAdapter.NewCachedOpenLineageRepository(olRepo, cacheRepo, 300) // 5-min TTL

// AFTER:
cachedOLRepo := redisAdapter.NewCachedOpenLineageRepository(olRepo, cacheRepo, cfg.CacheTTL)
```

Add import for `config` package if not already imported (it should already be imported as `"github.com/lineage-api/internal/infrastructure/config"`).

Note: `cfg.CacheTTL` is of type `config.CacheTTLConfig` which is what the refactored constructor expects. The `config` package is already imported in `main.go`.
  </action>
  <verify>
```bash
# All tests pass
cd lineage-api && go test ./internal/adapter/outbound/redis/ -v

# Full application compiles and builds
cd lineage-api && go build ./cmd/server/

# Verify no other tests broken
cd lineage-api && go test ./...
```
  </verify>
  <done>
- All 14 existing tests updated with new key format (pipe delimiters, :get: operation) and CacheTTLConfig
- 11+ new tests cover cache hit/miss for all newly cached methods
- Delegation test updated for methods that remain uncached
- main.go passes cfg.CacheTTL to CachedOpenLineageRepository constructor
- All tests pass, application compiles
  </done>
</task>

</tasks>

<verification>
```bash
# 1. All redis package tests pass
cd lineage-api && go test ./internal/adapter/outbound/redis/ -v -count=1

# 2. Full test suite passes (no regressions)
cd lineage-api && go test ./... -count=1

# 3. Application binary builds
cd lineage-api && go build -o /dev/null ./cmd/server/

# 4. Verify key format in test output -- spot check for pipe delimiters
cd lineage-api && go test ./internal/adapter/outbound/redis/ -v -run "TestCachedGetColumnLineageGraph_CacheMiss" 2>&1 | grep "ol:lineage:graph"
```
</verification>

<success_criteria>
1. CachedOpenLineageRepository accepts CacheTTLConfig (not int TTL)
2. All 8 endpoint-backing methods use cache-aside with correct key builder and TTL type
3. ListDatasets caches both the dataset slice and total count via wrapper struct
4. All existing tests updated and pass with new key format
5. New tests cover cache hit/miss for all 7 newly cached methods
6. main.go wires cfg.CacheTTL from environment variables to the decorator
7. Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/29-cache-keys-ttl--full-coverage---deterministic-key-generation-configurable-ttls-and-caching-across-all-read-endpoints/29-02-SUMMARY.md`
</output>
