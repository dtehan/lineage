---
phase: 29-cache-keys-ttl-full-coverage
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lineage-api/internal/adapter/outbound/redis/cache_keys.go
  - lineage-api/internal/adapter/outbound/redis/cache_keys_test.go
  - lineage-api/internal/infrastructure/config/config.go
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Same request parameters always produce the same cache key"
    - "Different parameters always produce different cache keys"
    - "All cache keys follow the format ol:{entity}:{operation}:{params} with pipe delimiters for composite params"
    - "TTL values for lineage and asset data types are independently configurable via environment variables"
    - "Default TTLs are 30 minutes for lineage, 15 minutes for assets, 5 minutes for search"
  artifacts:
    - path: "lineage-api/internal/adapter/outbound/redis/cache_keys.go"
      provides: "Centralized cache key builder functions for all 9 cached operations"
      exports: ["LineageGraphKey", "DatasetKey", "NamespacesKey", "NamespaceKey", "DatasetsKey", "DatasetSearchKey", "FieldsKey", "DatasetStatisticsKey", "DatasetDDLKey"]
    - path: "lineage-api/internal/adapter/outbound/redis/cache_keys_test.go"
      provides: "Determinism, format, and differentiation tests for all key builders"
      min_lines: 80
    - path: "lineage-api/internal/infrastructure/config/config.go"
      provides: "CacheTTLConfig struct with per-type TTL values loaded from env vars"
      contains: "CacheTTLConfig"
    - path: ".env.example"
      provides: "Documentation of CACHE_TTL_* environment variables"
      contains: "CACHE_TTL_LINEAGE"
  key_links:
    - from: "lineage-api/internal/adapter/outbound/redis/cache_keys.go"
      to: "lineage-api/internal/adapter/outbound/redis/cache_keys_test.go"
      via: "test imports key builder functions"
      pattern: "LineageGraphKey|DatasetKey|NamespacesKey"
    - from: "lineage-api/internal/infrastructure/config/config.go"
      to: "CacheTTLConfig struct"
      via: "Viper env var loading"
      pattern: "CACHE_TTL_LINEAGE"
---

<objective>
Create centralized cache key builder functions with deterministic composite keys and per-data-type TTL configuration via environment variables.

Purpose: Standardize cache key format to `ol:{entity}:{operation}:{params}` (KEY-01, KEY-02) and make TTL values independently configurable per data type (KEY-05). These primitives are consumed by Plan 29-02 which wires them into the cache decorator.

Output: `cache_keys.go` with 9 key builder functions, `cache_keys_test.go` with determinism/format/differentiation tests, updated `config.go` with `CacheTTLConfig`, updated `.env.example`.
</objective>

<execution_context>
@/Users/Daniel.Tehan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Daniel.Tehan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-cache-keys-ttl--full-coverage---deterministic-key-generation-configurable-ttls-and-caching-across-all-read-endpoints/29-RESEARCH.md
@lineage-api/internal/adapter/outbound/redis/cached_openlineage_repo.go
@lineage-api/internal/infrastructure/config/config.go
@lineage-api/internal/domain/repository.go
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache key builder functions and tests (TDD)</name>
  <files>
    lineage-api/internal/adapter/outbound/redis/cache_keys.go
    lineage-api/internal/adapter/outbound/redis/cache_keys_test.go
  </files>
  <action>
**RED phase:** Create `cache_keys_test.go` first with tests, then create `cache_keys.go` to make them pass.

Create `cache_keys.go` in the `redis` package with 9 pure functions:

```go
package redis

import (
    "fmt"
    "strings"
)

// Cache key format: ol:{entity}:{operation}:{params}
// Composite parameters use pipe (|) as delimiter.
// Colons separate structural segments; pipes separate parameter values.

func LineageGraphKey(datasetID, fieldName, direction string) string {
    return fmt.Sprintf("ol:lineage:graph:%s|%s|%s", datasetID, fieldName, direction)
}

func DatasetKey(datasetID string) string {
    return fmt.Sprintf("ol:dataset:get:%s", datasetID)
}

func NamespacesKey() string {
    return "ol:namespace:list"
}

func NamespaceKey(namespaceID string) string {
    return fmt.Sprintf("ol:namespace:get:%s", namespaceID)
}

func DatasetsKey(namespaceID string, limit, offset int) string {
    return fmt.Sprintf("ol:dataset:list:%s|%d|%d", namespaceID, limit, offset)
}

func DatasetSearchKey(query string, limit int) string {
    // Normalize: uppercase + trim for Teradata case-insensitive matching
    return fmt.Sprintf("ol:dataset:search:%s|%d", strings.ToUpper(strings.TrimSpace(query)), limit)
}

func FieldsKey(datasetID string) string {
    return fmt.Sprintf("ol:field:list:%s", datasetID)
}

func DatasetStatisticsKey(datasetID string) string {
    return fmt.Sprintf("ol:dataset:statistics:%s", datasetID)
}

func DatasetDDLKey(datasetID string) string {
    return fmt.Sprintf("ol:dataset:ddl:%s", datasetID)
}
```

Create `cache_keys_test.go` with these test categories:

1. **Determinism tests:** Same params produce same key (for each function).
2. **Differentiation tests:** Different params produce different keys (direction, datasetID, fieldName variations).
3. **Format tests:** All keys start with `ol:` prefix and follow the `ol:{entity}:{operation}:{params}` format.
4. **Search normalization test:** `DatasetSearchKey("customers", 50)` and `DatasetSearchKey("CUSTOMERS", 50)` produce the same key. Also test whitespace trimming.
5. **Pipe delimiter test:** Composite keys use `|` not `:` between parameter values. Verify by checking that `LineageGraphKey("42", "col_a", "both")` equals `"ol:lineage:graph:42|col_a|both"`.

Use `github.com/stretchr/testify/assert` for assertions. Use table-driven tests where appropriate (e.g., format test iterating over all key builders).

**GREEN phase:** The `cache_keys.go` implementation above should make all tests pass.

Run: `cd lineage-api && go test ./internal/adapter/outbound/redis/ -run TestCache -v`
  </action>
  <verify>
All cache key tests pass:
```bash
cd lineage-api && go test ./internal/adapter/outbound/redis/ -run "TestCacheKey|TestAllKeys|TestLineageGraphKey|TestDatasetKey|TestDatasetSearchKey" -v
```
  </verify>
  <done>
- 9 key builder functions exist in cache_keys.go
- All key builders produce deterministic output (same input = same output)
- Different inputs produce different keys
- All keys follow ol:{entity}:{operation}:{params} format
- DatasetSearchKey normalizes case and trims whitespace
- Composite parameters use pipe (|) delimiter, not colon
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CacheTTLConfig to config and update .env.example</name>
  <files>
    lineage-api/internal/infrastructure/config/config.go
    .env.example
  </files>
  <action>
In `config.go`:

1. Add `CacheTTLConfig` struct (NOT in the `redis` package -- keep it in `config` alongside `ValidationConfig`):

```go
// CacheTTLConfig holds per-data-type cache TTL values in seconds.
type CacheTTLConfig struct {
    LineageTTL    int // Lineage graph queries (default: 1800s = 30 min)
    AssetTTL      int // Asset listings: namespaces, datasets, fields (default: 900s = 15 min)
    StatisticsTTL int // Dataset statistics (default: 900s = 15 min)
    DDLTTL        int // Dataset DDL (default: 1800s = 30 min)
    SearchTTL     int // Search results (default: 300s = 5 min)
}
```

2. Add `CacheTTL CacheTTLConfig` field to the `Config` struct.

3. In `Load()`, add Viper defaults AFTER existing defaults:
```go
viper.SetDefault("CACHE_TTL_LINEAGE", 1800)
viper.SetDefault("CACHE_TTL_ASSETS", 900)
viper.SetDefault("CACHE_TTL_STATISTICS", 900)
viper.SetDefault("CACHE_TTL_DDL", 1800)
viper.SetDefault("CACHE_TTL_SEARCH", 300)
```

4. In the `cfg` construction, add:
```go
CacheTTL: CacheTTLConfig{
    LineageTTL:    viper.GetInt("CACHE_TTL_LINEAGE"),
    AssetTTL:      viper.GetInt("CACHE_TTL_ASSETS"),
    StatisticsTTL: viper.GetInt("CACHE_TTL_STATISTICS"),
    DDLTTL:        viper.GetInt("CACHE_TTL_DDL"),
    SearchTTL:     viper.GetInt("CACHE_TTL_SEARCH"),
},
```

In `.env.example`:

Add a new section after the Validation section:

```
# =============================================================================
# Cache TTL Configuration (seconds)
# =============================================================================
# Each data type can have a different TTL. Lineage graphs are expensive to
# compute and change infrequently. Search results change more often.

CACHE_TTL_LINEAGE=1800     # Lineage graph queries (default: 30 minutes)
CACHE_TTL_ASSETS=900       # Namespace/dataset/field listings (default: 15 minutes)
CACHE_TTL_STATISTICS=900   # Dataset statistics (default: 15 minutes)
CACHE_TTL_DDL=1800         # Dataset DDL (default: 30 minutes)
CACHE_TTL_SEARCH=300       # Search results (default: 5 minutes)
```

Do NOT add validation for TTL values -- zero and negative are intentional operator overrides (see research doc).
  </action>
  <verify>
Application compiles and config loads correctly:
```bash
cd lineage-api && go build ./cmd/server/
```
  </verify>
  <done>
- CacheTTLConfig struct exists in config package with 5 TTL fields
- Config struct includes CacheTTL field
- Viper defaults set: lineage=1800, assets=900, statistics=900, ddl=1800, search=300
- .env.example documents all 5 CACHE_TTL_* environment variables
- Application compiles successfully
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass (existing + new)
cd lineage-api && go test ./internal/adapter/outbound/redis/ -v

# Application compiles
cd lineage-api && go build ./cmd/server/

# Key format verification (spot check from test output)
# All keys start with "ol:" and use pipe delimiters for composite params
```
</verification>

<success_criteria>
1. 9 cache key builder functions exist and produce deterministic keys
2. All keys follow `ol:{entity}:{operation}:{params}` format with pipe delimiters
3. CacheTTLConfig struct loaded from 5 environment variables with correct defaults
4. .env.example documents all CACHE_TTL_* variables
5. All existing tests still pass (no regressions)
6. Application compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/29-cache-keys-ttl--full-coverage---deterministic-key-generation-configurable-ttls-and-caching-across-all-read-endpoints/29-01-SUMMARY.md`
</output>
